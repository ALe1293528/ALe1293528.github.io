<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SQL预编译——预编译真的能完美防御SQL注入吗 | ALe's Blog</title><meta name="author" content="ALe"><meta name="copyright" content="ALe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SQL注入原理sql注入是指攻击者拼接恶意SQL语句到接受外部参数的动态SQL查询中，程序本身未对插入的SQL语句进行过滤，导致SQL语句直接被服务端执行。拼接的SQL查询例如，通过在id变量后插入or 1&#x3D;1这样的条件，来绕过身份验证，获得未授权数据的访问权。 1SELECT * FROM user WHERE id &#x3D; -1 or 1&#x3D;1  由于or 1&#x3D;1 满足永真结果，">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL预编译——预编译真的能完美防御SQL注入吗">
<meta property="og:url" content="https://ale1293528.github.io/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/index.html">
<meta property="og:site_name" content="ALe&#39;s Blog">
<meta property="og:description" content="SQL注入原理sql注入是指攻击者拼接恶意SQL语句到接受外部参数的动态SQL查询中，程序本身未对插入的SQL语句进行过滤，导致SQL语句直接被服务端执行。拼接的SQL查询例如，通过在id变量后插入or 1&#x3D;1这样的条件，来绕过身份验证，获得未授权数据的访问权。 1SELECT * FROM user WHERE id &#x3D; -1 or 1&#x3D;1  由于or 1&#x3D;1 满足永真结果，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ale1293528.github.io/img/mygo7.jpg">
<meta property="article:published_time" content="2025-08-07T11:20:50.000Z">
<meta property="article:modified_time" content="2025-08-07T11:22:21.714Z">
<meta property="article:author" content="ALe">
<meta property="article:tag" content="web安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ale1293528.github.io/img/mygo7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SQL预编译——预编译真的能完美防御SQL注入吗",
  "url": "https://ale1293528.github.io/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/",
  "image": "https://ale1293528.github.io/img/mygo7.jpg",
  "datePublished": "2025-08-07T11:20:50.000Z",
  "dateModified": "2025-08-07T11:22:21.714Z",
  "author": [
    {
      "@type": "Person",
      "name": "ALe",
      "url": "https://ale1293528.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ale1293528.github.io/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SQL预编译——预编译真的能完美防御SQL注入吗',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/anon1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/mygo7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ALe's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">SQL预编译——预编译真的能完美防御SQL注入吗</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SQL预编译——预编译真的能完美防御SQL注入吗</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-08-07T11:20:50.000Z" title="Created 2025-08-07 19:20:50">2025-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-08-07T11:22:21.714Z" title="Updated 2025-08-07 19:22:21">2025-08-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>sql注入是指攻击者拼接恶意SQL语句到接受外部参数的动态SQL查询中，程序本身<br>未对插入的SQL语句进行过滤，导致SQL语句直接被服务端执行。<br>拼接的SQL查询例如，通过在id变量后插入or 1&#x3D;1这样的条件，来绕过身份验证，获<br>得未授权数据的访问权。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE id = -1 or 1=1</span><br></pre></td></tr></table></figure>

<p>由于or 1&#x3D;1 满足永真结果，sql语句会执行输出user中的全部内容。</p>
<p>那么这么危险的漏洞，有没有办法进行阻止呢</p>
<p><strong>有的兄弟，有的</strong></p>
<p>预编译就能解决大部分的SQL注入问题</p>
<h2 id="什么是预编译（Prepared-Statement）？"><a href="#什么是预编译（Prepared-Statement）？" class="headerlink" title="什么是预编译（Prepared Statement）？"></a>什么是预编译（Prepared Statement）？</h2><p>预编译就是<strong>在执行 SQL 前，把 SQL 语句先告诉数据库服务器，编译好结构，然后再单独传参数进去执行</strong>！</p>
<p>它的全名叫：</p>
<p><strong>Prepared Statement（预处理语句 &#x2F; 预编译语句）</strong></p>
<h2 id="正常写-SQL-是怎样的？"><a href="#正常写-SQL-是怎样的？" class="headerlink" title="正常写 SQL 是怎样的？"></a><strong>正常写 SQL 是怎样的？</strong></h2><p>我们先看看普通的拼接 SQL 是怎样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = input(&quot;请输入用户名：&quot;)</span><br><span class="line">sql = &quot;SELECT * FROM users WHERE username = &#x27;&quot; + username + &quot;&#x27;&quot;</span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure>

<p>这就好像直接把“用户输入”和“SQL语句”拼成一整句话。<br>用户只要输入了奇怪的东西，就能控制整个 SQL 的逻辑！Σ(っ °Д °;)っ</p>
<h2 id="使用预编译是这样写的："><a href="#使用预编译是这样写的：" class="headerlink" title="使用预编译是这样写的："></a><strong>使用预编译是这样写的：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = input(&quot;请输入用户名：&quot;)</span><br><span class="line">sql = &quot;SELECT * FROM users WHERE username = ?&quot;</span><br><span class="line">cursor.execute(sql, (username,))</span><br></pre></td></tr></table></figure>

<p>**重点就是<br>****SQL 写的时候，用 占位符（?） 或者 命名参数（:name），<br>**<strong>参数是后面传进去的！不是拼进去的！</strong></p>
<h2 id="预编译的执行流程（详细版！）"><a href="#预编译的执行流程（详细版！）" class="headerlink" title="预编译的执行流程（详细版！）"></a><strong>预编译的执行流程（详细版！）</strong></h2><ol>
<li>**发送 SQL 模板给数据库服务器<br>**比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = ?</span><br></pre></td></tr></table></figure>

<p>这个时候数据库就把这个 SQL 的结构编译好了，生成了“执行计划”</p>
<ol start="2">
<li>**服务器把这个语句存起来<br>**存的是“只差参数”的 SQL 模板。</li>
<li>**客户端发送参数<br>**比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&quot;admin&quot;,)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>**数据库执行之前编译好的 SQL<br>**把你传进去的参数当成“纯数据”，直接放进语句执行！</li>
</ol>
<h2 id="为什么这样能防止-SQL-注入？"><a href="#为什么这样能防止-SQL-注入？" class="headerlink" title="为什么这样能防止 SQL 注入？"></a>为什么这样能防止 SQL 注入？</h2><p>因为参数<strong>永远只是值</strong>，不会被当作 SQL 代码执行！<br>哪怕用户输入的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; OR &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>

<p>数据库也会当成一个完整的字符串 <code>&#39; OR &#39;1&#39;=&#39;1</code> 来处理，<strong>它不会让它改变 SQL 语句的逻辑结构</strong></p>
<p>但是预编译真的能完美防御SQL注入吗？笔者在写这篇文章前一直没有思考过这个问题，一是因为知识面浅薄，没有想这么多；二是因为确实没怎么研究过防御漏洞相关的知识，直到翻到了某篇blog<a target="_blank" rel="noopener" href="https://fushuling.com/index.php/2023/10/27/%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8Esql%E6%B3%A8%E5%85%A5/">预编译与sql注入 – fushulingのblog</a><a target="_blank" rel="noopener" href="https://fushuling.com/index.php/2025/03/30/%e5%86%8d%e8%b0%88%e9%a2%84%e7%bc%96%e8%af%91%e4%b8%8esql%e6%b3%a8%e5%85%a5/">再谈预编译与sql注入 – fushulingのblog</a></p>
<p>假设就用上面的例子，例子中 where语句中的内容是被参数化的。这就是说，预编译仅仅只能防御住可参数化位置的sql注入。那么，对于不可参数化的位置，预编译将没有任何办法。</p>
<p>那么不可参数化的位置都有哪些？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表名、列名</span><br><span class="line">order by、group by</span><br><span class="line">limit</span><br><span class="line">join</span><br><span class="line">等</span><br></pre></td></tr></table></figure>

<p>我们以order by举例，现在有一个sql语句如下（以下为伪代码）</p>
<p><code>SELECT * FROM users ORDER BY &#123;user_input&#125;;</code></p>
<pre><code>其中user_input是传递过来的参数，例如 id
</code></pre>
<p><code>SELECT * FROM users ORDER BY id;</code></p>
<pre><code>这个语句是正确的，但是如果user_input输入 id;drop table users --
</code></pre>
<p><code>SELECT * FROM users ORDER BY id;drop table users --</code></p>
<p>这样就被成功注入了，而这种位置是不可被参数化的，所以是无法通过预编译防御的。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsdb/p/12084038.html">SQL预编译中order by后为什么不能参数化原因 - 诸子流 - 博客园</a></p>
<p>这篇文章中提到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">不能参数化的根本原因</span><br><span class="line">2.1 以java为例进行说明</span><br><span class="line">典型的java写的sql执行代码片段如下：</span><br><span class="line"></span><br><span class="line">Connection conn = DBConnect.getConnection();</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">String sql = &quot; SELECT passwd FROM test_table1 WHERE username = ? &quot;;</span><br><span class="line"></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"># 通过setString()指明该参数是字符串类型</span><br><span class="line">ps.setString(1, username);</span><br><span class="line"># 另外还有setInt()等一些其他方法</span><br><span class="line"># ps.setInt(2, test_param);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">ps.setString(1, username)会自动给值加上引号。比如假设username=“ls”，那么拼凑成的语句会是String sql = &quot; SELECT passwd FROM test_table1 WHERE username = &#x27;ls&#x27; &quot;;</span><br><span class="line"></span><br><span class="line">再看order by，order by后一般是接字段名，而字段名是不能带引号的，比如 order by username；如果带上引号成了order by &#x27;username&#x27;，那username就是一个字符串不是字段名了，这就产生了语法错误。</span><br><span class="line"></span><br><span class="line">所以order by后不能参数化的本质是：一方面预编译又只有自动加引号的setString()方法，没有不加引号的方法；而另一方面order by后接的字段名不能有引号。（至于为什么不弄个能不自动加引号的set方法那就不太懂了）</span><br><span class="line"></span><br><span class="line">更本质的说法是：不只order by，凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名表名字段名函数名等等。</span><br></pre></td></tr></table></figure>

<p>大概就是说order by的后面是字段，字段不能用引号，但是预编译又只有用引号的setString()这一种方法，所以导致一切是字符串但又不能加引号的位置都不能参数化</p>
<p>原文以java为例进行说明，但是php中又是怎样呢</p>
<h3 id="模拟预编译"><a href="#模拟预编译" class="headerlink" title="模拟预编译"></a>模拟预编译</h3><p>网上一般讲的预编译是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = $_POST[&#x27;username&#x27;];</span><br><span class="line">$db = new PDO(&quot;mysql:host=localhost;dbname=test&quot;, &quot;root&quot;, &quot;root123&quot;);</span><br><span class="line">$stmt = $db-&gt;prepare(&quot;SELECT password FROM test where username= :username&quot;);</span><br><span class="line">$stmt-&gt;bindParam(&#x27;:username&#x27;, $username);</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line">$result = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line">var_dump($result);</span><br><span class="line">$db = null;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这里如果post传参<code>username=root</code>，就可以正常查到值，但是传<code>&#39;root&#39;</code>就查不到，通过查看日志可以发现在sql执行的过程中其实根本没有参数绑定、预编译的过程，本质上只是对符号做了过滤</p>
<p>这里参考文献中的作者将其称为虚假的预编译</p>
<blockquote>
<p>为什么开发者要做一个虚假的预编译呢，那是因为一个参数——PDO::ATTR_EMULATE_PREPARES，这个选项用来配置PDO是否使用模拟预编译，默认是true，因此默认情况下PDO采用的是模拟预编译模式，设置成false以后，才会使用真正的预编译。开启这个选项主要是用来兼容部分不支持预编译的数据库(如sqllite与低版本MySQL)，对于模拟预编译，会由客户端程序内部参数绑定这一过程(而不是数据库)，内部prepare之后再将拼接的sql语句发给数据库执行。</p>
</blockquote>
<h3 id="真正的预编译"><a href="#真正的预编译" class="headerlink" title="真正的预编译"></a>真正的预编译</h3><p>我们在原先的代码上把ATTR_EMULATE_PREPARES设为false取消模拟预编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = $_POST[&#x27;username&#x27;];</span><br><span class="line"></span><br><span class="line">$db = new PDO(&quot;mysql:host=localhost;dbname=test&quot;, &quot;root&quot;, &quot;root123&quot;);</span><br><span class="line">$db -&gt; setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</span><br><span class="line"></span><br><span class="line">$stmt = $db-&gt;prepare(&quot;SELECT password FROM test where username= :username&quot;);</span><br><span class="line"></span><br><span class="line">$stmt-&gt;bindParam(&#x27;:username&#x27;, $username);</span><br><span class="line"></span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">$result = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line"></span><br><span class="line">var_dump($result);</span><br><span class="line"></span><br><span class="line">$db = null;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>我们post一个username&#x3D;root</p>
<p>这时数据库中执行的顺序变成了：先连接，然后准备语句，用问号?占位，接着用输入替换问号?执行语句，专业点的说法叫做：</p>
<ol>
<li>建立连接；</li>
<li>构建语法树；</li>
<li>执行</li>
</ol>
<p>这也是为什么我们之前说的，预编译的作用是让整个语句的功能已经提前定死，消除了sql语句的歧义。当我们输入username&#x3D; ‘root’同样会没有任何输出</p>
<h2 id="模拟预编译的注入点"><a href="#模拟预编译的注入点" class="headerlink" title="模拟预编译的注入点"></a>模拟预编译的注入点</h2><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-10-22T13:12:13.619960Z	    9 Query	SELECT password FROM test where username= &#x27;\&#x27;root\&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>从模拟预编译的日志，我们可以发现这里仅仅是用到\的转义，所以我们是否可以进行宽字节注入呢</p>
<p> 答案当然是可以的吗，但是我没复现</p>
<h3 id="没有参数绑定"><a href="#没有参数绑定" class="headerlink" title="没有参数绑定"></a>没有参数绑定</h3><p><strong>没有参数绑定的预编译等于没有预编译</strong>，无论是真编译还是模拟预编译，没有参数绑定等于没编译，并且由于pdo默认支持堆叠注入，我们可以通过堆叠注入先插入值然后查询插入的值获取输出结果。</p>
<p>这两个的复现具体可以看下面这个文章：</p>
<p><a target="_blank" rel="noopener" href="https://fushuling.com/index.php/2023/10/27/%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8Esql%E6%B3%A8%E5%85%A5/">https://fushuling.com/index.php/2023/10/27/%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8Esql%E6%B3%A8%E5%85%A5/</a></p>
<hr>
<p>对于order by、ground by这种无法进行预编译的场景我们该怎么防御呢，比如Mybaits必须使用${}order by参数，可通过白名单思路对传入的参数进行判断，或者使用间接对象引用，前端传递引用数字等，用于与后端排序参数做数组映射，避免前端直接传入order by参数造成sql注入。</p>
<p>比如我们想执行select xx order by name，那么前端就不要传入name这个值，而是数字比如1，然后在后端将1与真正想查询的参数name进行对应，然后再执行sql语句。比如映射表为1-&gt;name，2-&gt;age，3-&gt;gender，想要查询order by name、age、gender的结果前端只用传入1、2、3即可，通过防止直接执行用户传入的值来从根本上防止sql注入的产生。</p>
<p>ps：order by后面以及group by 后面的注入，有报错回显的直接报错注入就行了，这个简单，没有报错的话我们可以通过构造布尔条件进行注入：随rand()中值真假的不同，排序出来的结果也是不同的，因此可以通过这个特征进行布尔注入，比如输入rand(ascii(mid((select database()),1,1))&gt;96)，如果成立和不成立输出结果显然是不同的，如果我们成功注入，输出应该是root dingzhen admin的顺序</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://ale1293528.github.io">ALe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://ale1293528.github.io/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/">https://ale1293528.github.io/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web%E5%AE%89%E5%85%A8/">web安全</a></div><div class="post-share"><div class="social-share" data-image="/img/mygo7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/08/%E6%A0%A1%E8%B5%9B%E9%A2%98%E7%9B%AE%E6%8E%A8%E6%96%AD/" title="校赛题目推断"><img class="cover" src="/img/mygo5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">校赛题目推断</div></div><div class="info-2"><div class="info-item-1">之前因为期末的原因没有去打，现在闲下来了突然想起来，但是现在已经不开放了，所以就进行一个通过题目名称猜测题目内容的活动，也是水一篇blog，顺便鉴定一下学长的成分（ 下面是题目列表 1234567891011121314151617181920212223MiscHTTPS怎么也不安全	张静媛学姐的秘密文件	段涵涵学姐最爱的音乐	流量分析-1	流量分析-2	流量分析-3	流量分析-4	流量分析-5	流量分析-6	流量分析-7	流量分析-8CryptoBase141	RSA你太baby了	愤怒的笑笑Webbusy_search	can_u_escape	ez?upload2	ez_upload	give!me!money!	lottery签到重生版	pop之我又双叒叕重生了	u_know?	函数重生版	小猿口算签到重生版Reversemaze	IDA	Xor	rere	sw1f7&#x27;s TEA	sw1f7&#x27;s XXTEAMobilease_androidOSINT杜浩学姐の朋友圈	杜浩学姐の旅行  MISC总体还是比较难猜，直接放弃 WEB还是这个稍稍好猜一点点，...</div></div></div></a><a class="pagination-related" href="/2025/08/05/2021%20OWASP%20TOP%2010/" title="2021 OWASP TOP 10"><img class="cover" src="/img/anon1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">2021 OWASP TOP 10</div></div><div class="info-2"><div class="info-item-1">近些年漏洞的威胁分类也发生了很大变化，王道SQL注入也慢慢淡出历史的舞台，最新OWASP Top Ten | OWASP Foundation版，分类和排名都变化了很多  [TOP1]失效的访问控制访问控制失效指的是：系统没有正确限制用户访问资源或功能，导致用户可以访问本不该访问的内容或操作 具体的例子：用户越权访问 用户 A 修改自己的资料：  1POST /api/user/update?id=1001   他把 ID 改成了管理员的 ID：  1POST /api/user/update?id=1   没有权限校验？那就直接修改管理员信息成功了  水平越权普通用户访问了其他用户的数据，比如： 1GET /api/orders/123456  → 返回了别人的订单信息（严重泄露） 垂直越权普通用户调用了管理员接口： 1POST /api/admin/delete_user?id=2  如果没检查角色权限，就能直接删号 前端控制误信前端隐藏了按钮，认为“用户就点不到”： 12&lt;!-- 管理员按钮 --&gt;&lt;button style=&quot;display: ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/05/2021%20OWASP%20TOP%2010/" title="2021 OWASP TOP 10"><img class="cover" src="/img/anon1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-05</div><div class="info-item-2">2021 OWASP TOP 10</div></div><div class="info-2"><div class="info-item-1">近些年漏洞的威胁分类也发生了很大变化，王道SQL注入也慢慢淡出历史的舞台，最新OWASP Top Ten | OWASP Foundation版，分类和排名都变化了很多  [TOP1]失效的访问控制访问控制失效指的是：系统没有正确限制用户访问资源或功能，导致用户可以访问本不该访问的内容或操作 具体的例子：用户越权访问 用户 A 修改自己的资料：  1POST /api/user/update?id=1001   他把 ID 改成了管理员的 ID：  1POST /api/user/update?id=1   没有权限校验？那就直接修改管理员信息成功了  水平越权普通用户访问了其他用户的数据，比如： 1GET /api/orders/123456  → 返回了别人的订单信息（严重泄露） 垂直越权普通用户调用了管理员接口： 1POST /api/admin/delete_user?id=2  如果没检查角色权限，就能直接删号 前端控制误信前端隐藏了按钮，认为“用户就点不到”： 12&lt;!-- 管理员按钮 --&gt;&lt;button style=&quot;display: ...</div></div></div></a><a class="pagination-related" href="/2025/07/24/ADS%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/" title="ADS数据流实现隐藏文件"><img class="cover" src="/img/anon1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="info-item-2">ADS数据流实现隐藏文件</div></div><div class="info-2"><div class="info-item-1">ADS：Alternate DataStreams，全称 NTFS 交换数据流，是 NTFS 磁盘格式的一个特性，在 NTFS 文件系统下，每个文件都可以存在多个数据流。简单来说，就是其他文件可以寄宿在某个文件身上。利用 ADS 数据流可以做很多有趣的事情 在NTFS分区创建ADS数据流文件有两种形式：  一是指定宿主文件； 二是创建单独的ADS文件。  创建的指令有两个：echo 和 type  echo 用于常规字符 type 用于将文件附加到某个文件  使用方法1. 使用宿主文件1echo test &gt; 1.txt:flag.txt 正常用 dir 是无法查看到的，可以使用 dir &#x2F;r 123456789101112131415161718192021222324C:\test&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025...</div></div></div></a><a class="pagination-related" href="/2025/08/21/Python-Bottle-SSTI/" title="Python Bottle SSTI"><img class="cover" src="/img/mygo7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">Python Bottle SSTI</div></div><div class="info-2"><div class="info-item-1">XYCTF 中碰到的 Bottle 框架，当时做题根本没想到通过审计框架代码找漏洞点，也是学到新东西了  Bottle 简介Bottle 是一个 Python 的轻量级 Web 框架，完全依赖标准库（除了 wsgi 的部分），体积非常小（一个 .py 文件就能运行），适合写小型 Web 应用、API 或原型系统。它的设计理念是 “单文件、零依赖”，所以部署非常方便。 主要特点   特点 说明    单文件 框架代码就是一个 bottle.py 文件，方便直接打包或拷贝   零依赖 除了 Python 标准库外不需要额外安装其它库   内置开发服务器 用 run() 就能启动 HTTP 服务   支持多模板引擎 默认内置 SimpleTemplate，也支持 Jinja2、Mako 等   路由简洁 使用装饰器 @route() 定义 URL 对应的处理函数   WSGI兼容 可以在任何 WSGI 服务器（如 gunicorn、uWSGI）上部署   内置常用工具 请求&#x2F;响应处理、静态文件服务、Cookie、表单解析等   基本结构示例1234567from bottle...</div></div></div></a><a class="pagination-related" href="/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/" title="python 内存马"><img class="cover" src="/img/mygo6.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="info-item-2">python 内存马</div></div><div class="info-2"><div class="info-item-1">之前一直想学内存马，但是碍于对 java 的了解近乎为0，对jndi的了解也是只停留在会背面经的层面，所以一直没有去学，直到后来翻一些文章发现 python 也可以利用 SSTI 进行内存马注入，于是迅速开整 Flask常见的 Python Web 框架如 Django 和 Flask 都有可能存在 SSTI（Server-Side Template Injection，服务端模板注入）漏洞 在 Flask 中，使用 render_template_string() 渲染模板时，若将用户输入直接传入而未做过滤处理，就可能导致 SSTI 漏洞。攻击者可通过该漏洞注入恶意模板代码，从而实现 代码执行，甚至进一步植入 内存马 内存马注入原理（Flask 路由机制）Flask 常规注册路由的方式是通过装饰器 @app.route()，但底层实际是调用了： 1self.add_url_rule(rule, endpoint=None, view_func=None)  各参数说明如下：  rule：URL 路径（必须以 / 开头），与 @app.route() 中的路径一致 endpoin...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/anon1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ALe</div><div class="author-info-description">从渗透测试到网安烧烤的一生</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ALe1293528"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">恐惧扼住咽喉，如枷锁禁锢我的双臂 我向沉默发问，沉默却愈发震耳欲聋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">SQL注入原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%88Prepared-Statement%EF%BC%89%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是预编译（Prepared Statement）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E5%86%99-SQL-%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">正常写 SQL 是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">使用预编译是这样写的：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%81%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">预编译的执行流程（详细版！）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%83%BD%E9%98%B2%E6%AD%A2-SQL-%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">为什么这样能防止 SQL 注入？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">6.1.</span> <span class="toc-text">模拟预编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">6.2.</span> <span class="toc-text">真正的预编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%B3%A8%E5%85%A5%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">模拟预编译的注入点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5"><span class="toc-number">7.1.</span> <span class="toc-text">宽字节注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">7.2.</span> <span class="toc-text">没有参数绑定</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/21/Python-Bottle-SSTI/" title="Python Bottle SSTI"><img src="/img/mygo7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python Bottle SSTI"/></a><div class="content"><a class="title" href="/2025/08/21/Python-Bottle-SSTI/" title="Python Bottle SSTI">Python Bottle SSTI</a><time datetime="2025-08-21T10:13:50.000Z" title="Created 2025-08-21 18:13:50">2025-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/15/LilCTF2025-wp/" title="LilCTF2025-wp"><img src="/img/mygo3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LilCTF2025-wp"/></a><div class="content"><a class="title" href="/2025/08/15/LilCTF2025-wp/" title="LilCTF2025-wp">LilCTF2025-wp</a><time datetime="2025-08-15T12:53:12.000Z" title="Created 2025-08-15 20:53:12">2025-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/XYCTF2025-wp/" title="XYCTF2025-wp"><img src="/img/mygo4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XYCTF2025-wp"/></a><div class="content"><a class="title" href="/2025/08/09/XYCTF2025-wp/" title="XYCTF2025-wp">XYCTF2025-wp</a><time datetime="2025-08-09T10:31:38.000Z" title="Created 2025-08-09 18:31:38">2025-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/%E6%A0%A1%E8%B5%9B%E9%A2%98%E7%9B%AE%E6%8E%A8%E6%96%AD/" title="校赛题目推断"><img src="/img/mygo5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="校赛题目推断"/></a><div class="content"><a class="title" href="/2025/08/08/%E6%A0%A1%E8%B5%9B%E9%A2%98%E7%9B%AE%E6%8E%A8%E6%96%AD/" title="校赛题目推断">校赛题目推断</a><time datetime="2025-08-08T14:56:49.000Z" title="Created 2025-08-08 22:56:49">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/" title="SQL预编译——预编译真的能完美防御SQL注入吗"><img src="/img/mygo7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL预编译——预编译真的能完美防御SQL注入吗"/></a><div class="content"><a class="title" href="/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/" title="SQL预编译——预编译真的能完美防御SQL注入吗">SQL预编译——预编译真的能完美防御SQL注入吗</a><time datetime="2025-08-07T11:20:50.000Z" title="Created 2025-08-07 19:20:50">2025-08-07</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By ALe</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>